################################################################################
#
#                                d R e g i o n s
#
#
#   Authors: |Anthony|
#   Version: 0.3
#   dScript Version: 0.9.6-DEV_b140
#
#
#   Dependencies:
#
#    - dWorldEditor
#      - Integrates with region selection wand
#      - https://github.com/AnthonyAMC/Public-Denizen-Scripts/blob/master/dWE/dWorldEditor.yml
#
#    - ConfigFileGenerator
#      - Used to build default config files and data storage.
#      - https://github.com/AnthonyAMC/Public-Denizen-Scripts/blob/master/ConfigFileGenerator.yml
#
#    - Flags
#      - All the flags for dRegions. It will be bundled in eventually.
#      - https://github.com/AnthonyAMC/Public-Denizen-Scripts/blob/master/dRegions/flags.dscript
#
#_______________________________________________________________________________
#
#--- About dRegions
#
#  dRegions is an advanced region management and world protection system written
# with the Denizen Scripting Engine. Heavily inspired by WorldGuard, the goal is
# to have an extremely efficient events system supporting an exhaustive set of
# region flags and configuration options. dRegions offers an intuitive command
# interface and provides thorough TAB completion.
#
#
#--- Installation & Setup
#
#  Install Flags, ConfigFileGenerator, dWorldEditor, and dRegions to your scripts
# folder and reload scripts. /denizen reload scripts
#
#  All config and data storage files will be automatically generated in your
# Denizen plugin folder. /plugins/Denizen/dRegions
#
#
#--- Permissions & Commands
#
#  Here's a list of all the permissions and commands with a brief description
# of each. More verbose usage info can be found in game. /drg help
#
#  dRegions provides thorough TAB completion! Use this to your benefit!
#
#  The permissions system isn't fully realized yet. Meanwhile, we have a list of
# generic permissions to get you by.
#
#  Command                Permission                   Description
#
#  /drg help [arg/#]      dregions.help                Specify a page number or command arg
#  /drg define            dregions.define              Define a region
#  /drg redefine          dregions.redefine            Update region to new selection
#  /drg claim             dregions.claim               Claim the selected region
#  /drg select            dregions.select              Select a region by id
#  /drg remove            dregions.remove              Remove a region
#  /drg list              dregions.list                List regions
#  /drg info              dregions.info                See info on a region
#  /drg addowner          dregions.addowner            Add a player or perm group as a region owner
#  /drg removeowner       dregions.removeowner         Remove a player or perm group from region owner
#  /drg addmember         dregions.addmember           Add a player or perm group as a region member
#  /drg removemember      dregions.removemember        Remove a player or perm group from region member
#  /drg flag              dregions.flag                Set region flags
#  /drg setpriority       dregions.setpriority         Set region priority
#  /drg setparent         dregions.setparent           Set region parent
#  /drg teleport          dregions.teleport            Teleport to region
#  /drg reload            dregions.reload              Reload all config files
#  /drg restart           dregions.restart             Restart dRegions for whatever reason
#                         dregions.admin               Override permission for all things dRegions
#
#                         dregions.invincible          Makes the player totally invincible
#                         dregions.invincible.<cause>  Player can't be damaged by specific cause(s)
#
#--- Basic Usage Tutorial
#
#  After you've gotten installed, setup, and permissions assigned (op-only mode
# is fine too), you will need to give yourself a region wand. /dwe wand
#
#  Mark your region selection using the wand as directed.
#
#  Define your region noting any owners (player or -g group) you want
#   - /drg define myRegion notch herobrine -g members -g vip
#
#  Your region is now protected! *Still indev! Not all protections implemented!*
#
#  Set region priority
#   - /drg setpriority myRegion 10
#
#  Set any region flags you need
#   - /drg flag myRegion greeting Hello <player.name>!
#
#--- TODO
#
#  - Make sure players can't exit a vehicle if they do not have permission to
#    get back into it.
#  - Add vehicle-enter and vehicle-exit flags and respective list flags.
#  - Add vehicle-placelist flag.
#  - Make all minecarts work with entity-interactlist flag.
#  - Make the player-damage flag cover the hurt command
#  - Fix eating in regions with the hunger flag set
#
################################################################################
#
#  dRegions World Events Script
#
#  This should cover all dRegions related world events.
#
#




#dRegions_testing_debug:
#  type: world
#  speed: 0
#  debug: true
#  events:
#    on player enters notable cuboid:
#    # Should we fire an event when the player exits the global region?
#    - if <c.from.cuboids.is_empty> {
#      - event 'player exits notable cuboid' 'context:cuboids|<c.from.cuboids.escaped>|from|<c.from>|to|<c.to>' save:exit
#      - if <entry[exit].determinations.get[1]||null> == cancelled {
#        - determine cancelled
#        }
#      }
#    - define world '<c.to.world.name.to_lowercase>'
#    - define cuboids '<c.to.cuboids.unescaped.as_list>'
#    - if <def[cuboids].is_empty> {
#      - define cache '<player.flag[dRegions.cache.%world%.__global__.entry]||null>'
#      - if %cache% == null {
#        - define FlagScript 's@dRegions_Flag_Entry'
#        - inject s@dRegions_Flag_Entry p:event-global
#        - queue clear
#        }
#      - if !%cache% {
#        - run s@dRegions_Flag_Entry p:msg delay:1t
#        - determine cancelled
#        }
#      - run s@dRegions_Flag_Entry p:entered-global delay:1t player:<player> def:%world%|__global__
#      - queue clear
#      }
#    - define regionPri 'li@'
#    - foreach <def[cuboids].parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
#      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
#      }
#    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
#    - define FlagScript 's@dRegions_Flag_Entry'
#    - inject s@dRegions_Flag_Entry p:event





dRegions:
  type: world
  speed: 0
  debug: false
  events:
##################################################
#
#  World Events
#
#
    on server start:
    - inject locally start

    on server shutdown:
    - foreach <server.list_worlds.parse[name.to_lowercase]> {
      - yaml 'savefile:dRegions/worlds/%value%/cache.yml' 'id:dRegions_%value%_cache'
      }

    on world initializes:
    - run locally loadYaml instantly

    on script reload:
    - run locally start instantly


    on command:
    - if <context.server||false> {
      - queue clear
      }
    - define world '<player.world.name>'
    - define target '<c.command.to_lowercase> <c.raw_args.to_lowercase>'
    - if <c.cuboids.is_empty||true> {
      - define FlagScript 's@dRegions_Flag_Commands'
      - inject s@dRegions_Flag_Commands p:event-global
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Commands'
    - inject s@dRegions_Flag_Commands p:event


#    on structure grows:
#    - announce "Grew <context.structure>"
#    - announce "<player.name||unknown>"

    on block ignites:
    - define world '<c.location.world.name>'
    - define target '<c.location.material.bukkit_enum>'
    - define readPath 'fire.<c.cause>'
    - inject s@dRegions p:event_PreProc_Config
    - if <c.cause> == FLINT_AND_STEEL {
      - define cause 'Lighter'
      }
      else if <c.cause> == LAVA {
      - define cause 'Lava-Fire'
      }
      else {
      - define cause 'Fire-Spread'
      }
    - if %cause% == Lighter {
      - if <player.permission[dRegions.admin]||false> || <player.is_op> queue clear
      - if <c.location.cuboids.alphanumeric.unseparated> == <player.location.cuboids.alphanumeric.unseparated> {
        - define sameRegion 'true'
        - define rateLimit '<player.flag[dRegions.rateLimit.lighter]||null>'
        - if %rateLimit% != null {
          - if %rateLimit% {
            - queue clear
            }
            else {
            - run s@dRegions_Flag_Lighter p:msg delay:1t
            - determine cancelled
            }
          }
        }
        else {
        - define sameRegion 'false'
        }
      }
    - if <c.location.cuboids.is_empty> {
      - if %cause% == Lighter {
        - define cache '<player.flag[dRegions.cache.%world%.__global__.lighter]||null>'
        - if %cache% == null {
          - define FlagScript 's@dRegions_Flag_Lighter'
          - inject s@dRegions_Flag_Lighter p:event-global
          - queue clear
          }
        - if !%cache% {
          - if %sameRegion% flag <player> dRegions.rateLimit.lighter:false d:10s
          - run s@dRegions_Flag_Lighter p:msg delay:1t
          - determine cancelled
          }
        - if %sameRegion% flag <player> dRegions.rateLimit.lighter:true d:10s
        - queue clear
        }

      - if %cause% == Lava-Fire {
        - define cache '<yaml[dRegions_%world%_cache].read[cache.boolean.__global__.lava-fire]||null>'
        - if %cache% == null {
          - define FlagScript 's@dRegions_Flag_Lava-Fire'
          - inject s@dRegions_Flag_Lava-Fire p:event-global
          - queue clear
          }
        - if !%cache% {
          - determine cancelled
          }
        - queue clear
        }

      - define cache '<yaml[dRegions_%world%_cache].read[cache.state-withTarget.__global__.%cause%.%target%]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_%cause%'
        - inject s@dRegions_Flag_%cause% p:event-global
        - queue clear
        }
      - if !%cache% {
        - determine cancelled
        }
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_%cause%'
    - inject %FlagScript% p:event

    on block burns:
    - define world '<c.location.world.name>'
    - define target '<c.location.material.bukkit_enum>'
    - define readPath 'fire.destroyBlocks'
    - inject s@dRegions p:event_PreProc_Config
    - if <c.location.cuboids.is_empty> {
      - define cache '<yaml[dRegions_%world%_cache].read[cache.state-withTarget.__global__.fire-destroy.%target%]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Fire-Destroy'
        - inject s@dRegions_Flag_Fire-Destroy p:event-global
        }
        else if !%cache% {
        - determine cancelled
        }
      - define cache '<yaml[dRegions_%world%_cache].read[cache.state-withTarget.__global__.fire-spread.%target%]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Fire-Spread'
        - inject s@dRegions_Flag_Fire-Spread p:event-global
        - queue clear
        }
      - if !%cache% {
        - determine cancelled
        }
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Fire-Destroy'
    - inject s@dRegions_Flag_Fire-Destroy p:event
    - define FlagScript 's@dRegions_Flag_Fire-Spread'
    - inject s@dRegions_Flag_Fire-Spread p:event

    on ice forms:
    - define world '<c.location.world.name>'
    - define readPath 'blockform.ice'
    - inject s@dRegions p:event_PreProc_Config-NoTarget
    - if <c.location.cuboids.is_empty> {
      - define cache '<yaml[dRegions_%world%_cache].read[cache.boolean.__global__.ice-form]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Ice-Form'
        - inject s@dRegions_Flag_Ice-Form p:event-global
        - queue clear
        }
      - if !%cache% {
        - determine cancelled
        }
      - queue clear
      }
#    - define lCache '<yaml[dRegions_%world%_cache].read[cache.locations.<c.location.simple>]||null>'
#    - if %lCache% != null {
#      - define orderedRegions '%lCache%'
#      }
#      else {
#      - define regionPri 'li@'
#      - foreach <c.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
#        - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
#        }
#      - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
#      - yaml set 'cache.locations.<c.location.simple>:%orderedRegions%' 'id:dRegions_%world%_cache'
#      }
    - define regionPri 'li@'
    - foreach <c.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Ice-Form'
    - inject s@dRegions_Flag_Ice-Form p:event

    on snow forms:
    - define world '<c.location.world.name>'
    - define target '<c.location.sub[0,1,0].material.bukkit_enum>'
    - define readPath 'blockform.snow'
    - inject s@dRegions p:event_PreProc_Config
    - if <c.location.cuboids.is_empty> {
      - define cache '<yaml[dRegions_%world%_cache].read[cache.state-withTarget.__global__.snow-fall.%target%]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Snow-Fall'
        - inject s@dRegions_Flag_Snow-Fall p:event-global
        - queue clear
        }
      - if !%cache% {
        - determine cancelled
        }
      - queue clear
      }
#    - define lCache '<yaml[dRegions_%world%_cache].read[cache.locations.<c.location.simple>]||null>'
#    - if %lCache% != null {
#      - define orderedRegions '%lCache%'
#      }
#      else {
#      - define regionPri 'li@'
#      - foreach <c.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
#        - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
#        }
#      - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
#      - yaml set 'cache.locations.<c.location.simple>:%orderedRegions%' 'id:dRegions_%world%_cache'
#      }
    - define regionPri 'li@'
    - foreach <c.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Snow-Fall'
    - inject s@dRegions_Flag_Snow-Fall p:event

    on soil fades:
    - define world '<c.location.world.name>'
    - define readPath 'blockfade.soil'
    - inject s@dRegions p:event_PreProc_Config-NoTarget
    - if <c.location.cuboids.is_empty> {
      - define cache '<yaml[dRegions_%world%_cache].read[cache.boolean.__global__.soil-dry]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Soil-Dry'
        - inject s@dRegions_Flag_Soil-Dry p:event-global
        - queue clear
        }
      - if !%cache% {
        - determine cancelled
        }
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Soil-Dry'
    - inject s@dRegions_Flag_Soil-Dry p:event

    on ice fades:
    - define world '<c.location.world.name>'
    - define readPath 'blockfade.ice'
    - inject s@dRegions p:event_PreProc_Config-NoTarget
    - if <c.location.cuboids.is_empty> {
      - define cache '<yaml[dRegions_%world%_cache].read[cache.boolean.__global__.ice-melt]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Ice-Melt'
        - inject s@dRegions_Flag_Ice-Melt p:event-global
        - queue clear
        }
      - if !%cache% {
        - determine cancelled
        }
      - queue clear
      }
#    - define lCache '<yaml[dRegions_%world%_cache].read[cache.locations.<c.location.simple>]||null>'
#    - if %lCache% != null {
#      - define orderedRegions '%lCache%'
#      }
#      else {
#      - define regionPri 'li@'
#      - foreach <c.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
#        - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
#        }
#      - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
#      - yaml set 'cache.locations.<c.location.simple>:%orderedRegions%' 'id:dRegions_%world%_cache'
#      }
    - define regionPri 'li@'
    - foreach <c.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Ice-Melt'
    - inject s@dRegions_Flag_Ice-Melt p:event

    on snow fades:
    - define world '<c.location.world.name>'
    - define readPath 'blockfade.snow'
    - inject s@dRegions p:event_PreProc_Config-NoTarget
    - if <c.location.cuboids.is_empty> {
      - define cache '<yaml[dRegions_%world%_cache].read[cache.boolean.__global__.snow-melt]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Snow-Melt'
        - inject s@dRegions_Flag_Snow-Melt p:event-global
        - queue clear
        }
      - if !%cache% {
        - determine cancelled
        }
      - queue clear
      }
#    - define lCache '<yaml[dRegions_%world%_cache].read[cache.locations.<c.location.simple>]||null>'
#    - if %lCache% != null {
#      - define orderedRegions '%lCache%'
#      }
#      else {
#      - define regionPri 'li@'
#      - foreach <c.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
#        - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
#        }
#      - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
#      - yaml set 'cache.locations.<c.location.simple>:%orderedRegions%' 'id:dRegions_%world%_cache'
#      }
    - define regionPri 'li@'
    - foreach <c.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Snow-Melt'
    - inject s@dRegions_Flag_Snow-Melt p:event

    on block spreads:
    - define mat '<c.material.bukkit_enum.split[_].last>'
    - if li@grass|mycel|mushroom|vines !contains %mat% queue clear
    - define world '<c.location.world.name>'
    - define readPath 'spread.%mat%'
    - inject s@dRegions p:event_PreProc_Config-NoTarget
    - if <c.location.cuboids.is_empty> {
      - define cache '<yaml[dRegions_%world%_cache].read[cache.boolean.__global__.%mat%-spread]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_%mat%-Spread'
        - inject s@dRegions_Flag_%mat%-Spread p:event-global
        - queue clear
        }
      - if !%cache% {
        - determine cancelled
        }
      }
    - define regionPri 'li@'
    - foreach <c.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_%mat%-Spread'
    - inject %FlagScript% p:event

    on liquid spreads:
    - if <c.location.material.bukkit_enum> == <c.destination.material.bukkit_enum> queue clear
    - define mat '<c.location.material.bukkit_enum.split[_].last>'
    - if li@water|lava !contains %mat% queue clear
    - define target '<c.destination.material.bukkit_enum>'
    - define world '<c.location.world.name>'
    - define readPath 'spread.%mat%'
    - inject s@dRegions p:event_PreProc_Config
    - if <c.destination.cuboids.include[<c.location.cuboids>].is_empty||true> {
      - define cache '<yaml[dRegions_%world%_cache].read[cache.state-withTarget.__global__.%mat%-spread.%target%]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_%mat%-Spread'
        - inject s@dRegions_Flag_%mat%-Spread p:event-global
        - queue clear
        }
      - if !%cache% {
        - determine cancelled
        }
      - queue clear
      }
    # Build list of dRegions for <c.destination> in priority order
    - define regionPri 'li@'
    - foreach <c.destination.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    # Block liquid from crossing region borders
    - if <c.location.cuboids.alphanumeric.unseparated||null> != <c.destination.cuboids.alphanumeric.unseparated||null> {
      # Build list of dRegions for <c.location> in priority order
      - define regionPri 'li@'
      - foreach <c.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
        - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
        }
      - define oldLoc '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]].get[1]>'
      - if %oldLoc% != <def[orderedRegions].get[1]> {
        - determine cancelled
        }
      }
    - define FlagScript 's@dRegions_Flag_%mat%-Spread'
    - inject s@dRegions_Flag_%mat%-Spread p:event

    on lightning strikes:
    - define world '<c.world.name>'
    - define target '<c.location.below.material.bukkit_enum>'
    - define readPath 'lightning-strike'
    - inject s@dRegions p:event_PreProc_Config
    - if <c.location.cuboids.is_empty||true> {
      - define cache '<yaml[dRegions_%world%_cache].read[cache.state-withTarget.__global__.lightning-strikes.%target%]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Lightning-Strikes'
        - inject s@dRegions_Flag_Lightning-Strikes p:event-global
        - queue clear
        }
      - if !%cache% {
        - determine cancelled
        }
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Lightning-Strikes'
    - inject s@dRegions_Flag_Lightning-Strikes p:event

    on leaves decay:
    - define world '<c.location.world.name>'
    - define readPath 'leaf-decay'
    - inject s@dRegions p:event_PreProc_Config-NoTarget
    - if <c.location.cuboids.is_empty> {
      - define cache '<yaml[dRegions_%world%_cache].read[cache.boolean.__global__.leaf-decay]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Leaf-Decay'
        - inject s@dRegions_Flag_Leaf-Decay p:event-global
        - queue clear
        }
      - if !%cache% {
        - determine cancelled
        }
      - queue clear
      }
#    - define lCache '<yaml[dRegions_%world%_cache].read[cache.locations.<c.location.simple>]||null>'
#    - if %lCache% != null {
#      - define orderedRegions '%lCache%'
#      }
#      else {
#      - define regionPri 'li@'
#      - foreach <c.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
#        - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
#        }
#      - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
#      - yaml set 'cache.locations.<c.location.simple>:%orderedRegions%' 'id:dRegions_%world%_cache'
#      }
    - define regionPri 'li@'
    - foreach <c.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Leaf-Decay'
    - inject s@dRegions_Flag_Leaf-Decay p:event

    on portal created:
    - define world '<c.world.name.to_lowercase>'
    - define readPath 'portal.create'
    - inject s@dRegions p:event_PreProc_Config-NoTarget

    on potion splash:
    # This will cancel the splash if any entity is in a protected region!
    - define world '<c.location.world.name>'
    - define cuboids '<c.entities.parse[location.cuboids].deduplicate>'
    - if <def[cuboids].is_empty||true> {
      - define cache '<yaml[dRegions_%world%_cache].read[cache.boolean.__global__.potion-throw]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Potion-Throw'
        - inject s@dRegions_Flag_Potion-Throw p:event-global
        - queue clear
        }
      - if !%cache% {
        - determine cancelled
        }
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <def[cuboids].parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Potion-Throw'
    - inject s@dRegions_Flag_Potion-Throw p:event

    on piston extends:
    - define world '<c.location.world.name>'
    - define lastBlock '<tern[<c.length.is[==].to[0]||true>]:<c.relative>||<c.relative.sub[<c.location>].add[<c.blocks.last>]>>'
    - if <c.blocks.include[%lastBlock%].parse[cuboids].is_empty||true> {
      - define cache '<yaml[dRegions_%world%_cache].read[cache.boolean.__global__.pistons]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Pistons'
        - inject s@dRegions_Flag_Pistons p:event-global
        - queue clear
        }
      - if !%cache% {
        - determine cancelled
        }
      - queue clear
      }
    - if <c.location.cuboids.alphanumeric.unseparated||null> != <c.blocks.include[%lastBlock%].parse[cuboids].deduplicate.alphanumeric.unseparated||null> {
      - define regionPri 'li@'
      - foreach <c.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
        - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
        }
      - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
      - define pistonCuboid '<def[orderedRegions].get[1]>'
      - foreach <c.blocks.include[%lastBlock%]> {
        - define cuboids <def[value].cuboids>
        - define regionPri 'li@'
        - foreach <def[cuboids].parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
          - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
          }
        - define nextLocCuboids '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
        - if <def[pistonCuboid].is[!=].to[<def[nextLocCuboids].get[1]>]> {
          - determine cancelled
          }
        }
      }
    - if <def[orederedRegions].exists.not> {
      - define regionPri 'li@'
      - foreach <c.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
        - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
        }
      - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
      }
    - define FlagScript 's@dRegions_Flag_Pistons'
    - inject s@dRegions_Flag_Pistons p:event

    on piston retracts:
    - define world '<c.location.world.name>'
    - define lastBlock '<tern[<c.length.is[==].to[0]||true>]:<c.relative>||<c.relative.sub[<c.location>].add[<c.blocks.last>]>>'
    - if <c.blocks.include[%lastBlock%].parse[cuboids].is_empty||true> {
      - define cache '<yaml[dRegions_%world%_cache].read[cache.boolean.__global__.pistons]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Pistons'
        - inject s@dRegions_Flag_Pistons p:event-global
        - queue clear
        }
      - if !%cache% {
        - determine cancelled
        }
      - queue clear
      }
    - if <c.location.cuboids.alphanumeric.unseparated||null> != <c.blocks.include[%lastBlock%].parse[cuboids].deduplicate.alphanumeric.unseparated||null> {
      - define regionPri 'li@'
      - foreach <c.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
        - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
        }
      - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
      - define pistonCuboid '<def[orderedRegions].get[1]>'
      - foreach <c.blocks.include[%lastBlock%]> {
        - define cuboids <def[value].cuboids>
        - define regionPri 'li@'
        - foreach <def[cuboids].parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
          - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
          }
        - define nextLocCuboids '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
        - if <def[pistonCuboid].is[!=].to[<def[nextLocCuboids].get[1]>]> {
          - determine cancelled
          }
        }
      }
    - if <def[orederedRegions].exists.not> {
      - define regionPri 'li@'
      - foreach <c.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
        - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
        }
      - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
      }
    - define FlagScript 's@dRegions_Flag_Pistons'
    - inject s@dRegions_Flag_Pistons p:event


#
#  END World Events
##################################################
#
#  Player Events
#
#
#    on player clicks block:
#    - narrate "item <c.item||i@air>"
#    - narrate "mat <c.location.material.bukkit_enum||air>"
#    - narrate "type <c.click_type||unknown>"
#    - define world '<player.world.name.to_lowercase>'
#    - define cuboids '<c.cuboids>'
#    - inject s@dRegions p:event_PreProc_OrderRegionsGlobal
#    - define allFlagScripts '<server.list_scripts.filter[starts_with[s@dRegions_Flag_]]||li@>'

#    - inject s@dRegions p:use_<c.item||null>
#    - inject s@dRegions p:playerClick_<c.type||null>

    on player changes world:
#    - event 'player exits notable cuboid' 'context:cuboids|<c.from.cuboids.escaped>|from|<c.from>|to|<c.to>' save:exit
#    - if <entry[exit].determinations.get[1]||null> == cancelled {
#      - determine cancelled
#      }
    - flag <player> dRegions.cache:!

    on player joins:
    - flag <player> dRegions.cache:!
    - flag <player> dRegions.rateLimit:!

    on player chats:
    - define world '<player.world.name>'
    - define sameRegion 'true'
    - define rateLimit '<player.flag[dRegions.rateLimit.send-chat]||null>'
    - if %rateLimit% != null {
      - if !%rateLimit% {
        - run s@dRegions_Flag_Send-Chat p:msg delay:1t
        - determine cancelled
        }
      - determine 'recipients:<context.recipients.exclude[<server.flag[dRegions.Chat.Deaf].as_list||li@>]>'
      - queue clear
      }
    - if <player.location.cuboids.is_empty> {
      - define cache '<player.flag[dRegions.cache.%world%.__global__.send-chat]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Send-Chat'
        - inject s@dRegions_Flag_Send-Chat p:event-global
        - determine 'recipients:<context.recipients.exclude[<server.flag[dRegions.Chat.Deaf].as_list||li@>]>'
        - queue clear
        }
      - if !%cache% {
        - if %sameRegion% flag <player> dRegions.rateLimit.send-chat:false d:10s
        - run s@dRegions_Flag_Send-Chat p:msg delay:1t
        - determine cancelled
        }
      - if %sameRegion% flag <player> dRegions.rateLimit.send-chat:true d:10s
      - determine 'recipients:<context.recipients.exclude[<server.flag[dRegions.Chat.Deaf].as_list||li@>]>'
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <player.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Send-Chat'
    - inject s@dRegions_Flag_Send-Chat p:event
    - determine 'recipients:<context.recipients.exclude[<server.flag[dRegions.Chat.Deaf].as_list||li@>]>'

    on player destroys vehicle:
    - if <c.vehicle.location.cuboids.alphanumeric.unseparated> == <player.location.cuboids.alphanumeric.unseparated> {
      - define sameRegion 'true'
      - define rateLimit '<player.flag[dRegions.rateLimit.vehicle-destroy]||null>'
      - if %rateLimit% != null {
        - if %rateLimit% {
          - queue clear
          }
          else {
          - run s@dRegions_Flag_vehicle-destroy p:msg delay:1t 'def:<c.vehicle.entity_type.to_lowercase.replace[_].with[ ]>'
          - determine cancelled
          }
        }
      }
      else {
      - define sameRegion 'false'
      }
    - define world '<player.world.name.to_lowercase>'
    - if <c.vehicle.location.cuboids.is_empty> {
      - define cache '<player.flag[dRegions.cache.%world%.__global__.vehicle-destroy]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Vehicle-Destroy'
        - inject s@dRegions_Flag_Vehicle-Destroy p:event-global
        - queue clear
        }
      - if !%cache% {
        - if %sameRegion% flag <player> dRegions.rateLimit.vehicle-destroy:false d:10s
        - run s@dRegions_Flag_vehicle-destroy delay:1t p:msg 'def:<c.vehicle.entity_type.to_lowercase.replace[_].with[ ]>'
        - determine cancelled
        }
      - if %sameRegion% flag <player> dRegions.rateLimit.vehicle-destroy:true d:10s
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.vehicle.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Vehicle-Destroy'
    - inject s@dRegions_Flag_Vehicle-Destroy p:event

    on player stands on:
    - if <player.permission[dRegions.admin]||false> || <player.is_op> queue clear
    - define target '<c.location.material.bukkit_enum>'
    - if %target% == soil queue clear
    - define sameRegion 'true'
    - define rateLimit '<player.flag[dRegions.rateLimit.use-switches.%target%]||null>'
    - if %rateLimit% != null {
      - if %rateLimit% {
        - queue clear
        }
        else {
        - run s@dRegions_Flag_Use-Switches p:msg delay:1t 'def:<def[target].to_lowercase.replace[_].with[ ]>'
        - determine cancelled
        }
      }
    - define player '<player>'
    - define world '<player.world.name>'
    - if <c.cuboids.is_empty||true> {
      - define cache '<player.flag[dRegions.cache.%world%.__global__.use-switches.%target%]||null>'
      - if %cache% == null {
        - define flagScript 's@dRegions_Flag_Use-Switches'
        - inject s@dRegions_Flag_Use-Switches p:event-global
        - queue clear
        }
      - if !%cache% {
        - flag <player> dRegions.rateLimit.use-switches.%target%:false d:10s
        - run s@dRegions_Flag_use-switches p:msg delay:1t 'def:<def[target].to_lowercase.replace[_].with[ ]>'
        - determine cancelled
        }
      - flag <player> dRegions.rateLimit.use-switches.%target%:true d:10s
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define flagScript 's@dRegions_Flag_Use-Switches'
    - inject s@dRegions_Flag_Use-Switches p:event

    on player right clicks block with boat:
    - define world '<player.world.name>'
    - if <c.cuboids.is_empty||true> {
      - define FlagScript 's@dRegions_Flag_Vehicle-Place'
      - inject s@dRegions_Flag_Vehicle-Place p:event-global
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Vehicle-Place'
    - inject s@dRegions_Flag_Vehicle-Place p:event

    on player right clicks with potion:
    - if !<c.item.potion_effect.is_splash||false> {
      - queue clear
      }
    - define world '<player.world.name>'
    - if <player.location.cuboids.is_empty> {
      - define cache '<yaml[dRegions_%world%_cache].read[cache.boolean.__global__.potion-throw]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Potion-Throw'
        - inject s@dRegions_Flag_Potion-Throw p:event-global
        - queue clear
        }
      - if !%cache% {
        - determine cancelled
        }
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <player.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Potion-Throw'
    - inject s@dRegions_Flag_Potion-Throw p:event

    on player consumes potion:
    - define world '<player.world.name>'
    - define sameRegion 'true'
    - define rateLimit '<player.flag[dRegions.rateLimit.potion-drink]||null>'
    - if %rateLimit% != null {
      - if %rateLimit% {
        - queue clear
        }
        else {
        - run s@dRegions_Flag_Potion-Drink p:msg delay:1t
        - determine cancelled
        }
      }
    - if <player.location.cuboids.is_empty> {
      - define cache '<player.flag[dRegions.cache.%world%.__global__.potion-drink]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Potion-Drink'
        - inject s@dRegions_Flag_Potion-Drink p:event-global
        - queue clear
        }
      - if !%cache% {
        - if %sameRegion% flag <player> dRegions.rateLimit.potion-drink:false d:10s
        - run s@dRegions_Flag_Potion-Drink p:msg delay:1t
        - determine cancelled
        }
      - if %sameRegion% flag <player> dRegions.rateLimit.potion-drink:true d:10s
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <player.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Potion-Drink'
    - inject s@dRegions_Flag_Potion-Drink p:event

    on player right clicks block with armor_stand:
    - if <player.permission[dRegions.admin]||false> || <player.is_op> queue clear
    - define world '<player.world.name>'
    - if <c.cuboids.alphanumeric.unseparated> == <player.location.cuboids.alphanumeric.unseparated> {
      - define sameRegion 'true'
      - define rateLimit '<player.flag[dRegions.rateLimit.build]||null>'
      - if %rateLimit% != null {
        - if %rateLimit% {
          - queue clear
          }
          else {
          - run s@dRegions_Flag_Build p:msg delay:1t
          - determine cancelled
          }
        }
      }
      else {
      - define sameRegion 'false'
      }
    - if <c.cuboids.is_empty||true> {
      - define cache '<player.flag[dRegions.cache.%world%.__global__.build]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Build'
        - inject s@dRegions_Flag_Build p:event-global
        - queue clear
        }
      - if !%cache% {
        - if %sameRegion% flag <player> dRegions.rateLimit.build:false d:10s
        - run s@dRegions_Flag_Build p:msg delay:1t
        - determine cancelled
        }
      - if %sameRegion% flag <player> dRegions.rateLimit.build:true d:10s
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Build'
    - inject s@dRegions_Flag_Build p:event

    on player right clicks block with monster_egg:
    - if <player.permission[dRegions.admin]||false> || <player.is_op> queue clear
    - define world '<player.world.name>'
    - if <c.cuboids.alphanumeric.unseparated> == <player.location.cuboids.alphanumeric.unseparated> {
      - define sameRegion 'true'
      - define rateLimit '<player.flag[dRegions.rateLimit.build]||null>'
      - if %rateLimit% != null {
        - if %rateLimit% {
          - queue clear
          }
          else {
          - run s@dRegions_Flag_Build p:msg delay:1t
          - determine cancelled
          }
        }
      }
      else {
      - define sameRegion 'false'
      }
    - if <c.cuboids.is_empty||true> {
      - define cache '<player.flag[dRegions.cache.%world%.__global__.build]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Build'
        - inject s@dRegions_Flag_Build p:event-global
        - queue clear
        }
      - if !%cache% {
        - if %sameRegion% flag <player> dRegions.rateLimit.build:false d:10s
        - run s@dRegions_Flag_Build p:msg delay:1t
        - determine cancelled
        }
      - if %sameRegion% flag <player> dRegions.rateLimit.build:true d:10s
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Build'
    - inject s@dRegions_Flag_Build p:event

    on player throws hatching egg:
    - if <player.permission[dRegions.admin]||false> || <player.is_op> queue clear
    - define world '<player.world.name>'
    - if <c.egg.location.cuboids.alphanumeric.unseparated> == <player.location.cuboids.alphanumeric.unseparated> {
      - define sameRegion 'true'
      - define rateLimit '<player.flag[dRegions.rateLimit.build]||null>'
      - if %rateLimit% != null {
        - if %rateLimit% {
          - queue clear
          }
          else {
          - run s@dRegions_Flag_Build p:msg delay:1t
          - determine cancelled
          }
        }
      }
      else {
      - define sameRegion 'false'
      }
    - if <c.egg.location.cuboids.is_empty> {
      - define cache '<player.flag[dRegions.cache.%world%.__global__.build]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Build'
        - inject s@dRegions_Flag_Build p:event-global
        - queue clear
        }
      - if !%cache% {
        - if %sameRegion% flag <player> dRegions.rateLimit.build:false d:10s
        - run s@dRegions_Flag_Build p:msg delay:1t
        - determine cancelled
        }
      - if %sameRegion% flag <player> dRegions.rateLimit.build:true d:10s
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.egg.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Build'
    - inject s@dRegions_Flag_Build p:event

    on player right clicks:
    - if <player.permission[dRegions.admin]||false> || <player.is_op> {
      - queue clear
      }
    - define player '<player>'
    - define target '<c.location.material.bukkit_enum.to_lowercase||air>'
    - define item '<c.item.material.bukkit_enum.to_lowercase||air>'
    - if %item% == air {
      - define FlagScript '<s@dRegions_Map_Interactions.yaml_key[block.%target%]||null>'
      }
      else {
      - define eventObj '<s@dRegions_Map_Interactions.yaml_key[block_withItem.%target%]||li@>'
      - if <def[eventObj].split[/].get[2].as_list||li@> contains %item% {
        - define FlagScript '<def[eventObj].split[/].get[1]>'
        }
        else {
        - define FlagScript '<s@dRegions_Map_Interactions.yaml_key[block.%target%]||null>'
        }
      }
    - if %FlagScript% == null {
      - queue clear
      }
    - define flag '<def[FlagScript].after_last[_]>'

    - if <c.location.cuboids.alphanumeric.unseparated||null> == <player.location.cuboids.alphanumeric.unseparated||null> {
      - define sameRegion 'true'
      - if li@Build|Vehicle-Place contains %flag% {
        - define rateLimit '<player.flag[dRegions.rateLimit.%flag%]||null>'
        }
        else {
        - define rateLimit '<player.flag[dRegions.rateLimit.%flag%.%target%]||null>'
        }
      - if %rateLimit% != null {
        - if %rateLimit% {
          - queue clear
          }
          else {
          - run s@dRegions_Flag_%flag% p:msg delay:1t 'def:<def[target].replace[_].with[ ]>'
          - determine cancelled
          }
        }
      }
      else {
      - define sameRegion 'false'
      }

    - define world '<player.world.name>'
    - define cuboids '<c.cuboids||<player.location.cursor_on[5].cuboids||li@>>'
    - if <def[cuboids].is_empty||true> {
      - if li@Build|Vehicle-Place contains %flag% {
        - define cache '<player.flag[dRegions.cache.%world%.__global__.%flag%]||null>'
        - if %cache% == null {
          - define FlagScript 's@dRegions_Flag_%flag%'
          - inject s@dRegions_Flag_%flag% p:event-global
          - queue clear
          }
        - if !%cache% {
          - if %sameRegion% flag <player> dRegions.rateLimit.%flag%:false d:10s
          - run s@dRegions_Flag_%flag% p:msg delay:1t
          - determine cancelled
          }
        - if %sameRegion% flag <player> dRegions.rateLimit.%flag%:true d:10s
        - queue clear
        }
      - define cache '<player.flag[dRegions.cache.%world%.__global__.%flag%.%target%]||null>'
      - if %cache% == null {
        - inject s@dRegions_Flag_%flag% p:event-global
        - queue clear
        }
      - if !%cache% {
        - if %sameRegion% flag <player> dRegions.rateLimit.%flag%.%target%:false d:10s
        - run s@dRegions_Flag_%flag% p:msg delay:1t 'def:<def[target].to_lowercase.replace[_].with[ ]>'
        - determine cancelled
        }
      - if %sameRegion% flag <player> dRegions.rateLimit.%flag%.%target%:true d:10s
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <def[cuboids].parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - inject %FlagScript% p:event

    on player right clicks npc:
    - define world '<player.world.name>'
    - if <c.cuboids.alphanumeric.unseparated> == <player.location.cuboids.alphanumeric.unseparated> {
      - define sameRegion 'true'
      - define rateLimit '<player.flag[dRegions.rateLimit.npc-interact]||null>'
      - if %rateLimit% != null {
        - if %rateLimit% {
          - queue clear
          }
          else {
          - run s@dRegions_Flag_NPC-Interact p:msg delay:1t
          - determine cancelled
          }
        }
      }
      else {
      - define sameRegion 'false'
      }
    - if <c.cuboids.is_empty> {
      - define cache '<player.flag[dRegions.cache.%world%.__global__.npc-interact]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_NPC-Interact'
        - inject s@dRegions_Flag_NPC-Interact p:event-global
        - queue clear
        }
      - if !%cache% {
        - if %sameRegion% flag <player> dRegions.rateLimit.npc-interact:false d:10s
        - run s@dRegions_Flag_NPC-Interact p:msg delay:1t
        - determine cancelled
        }
      - if %sameRegion% flag <player> dRegions.rateLimit.npc-interact:true d:10s
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_NPC-Interact'
    - inject s@dRegions_Flag_NPC-Interact p:event

    on player right clicks entity:
    - if <c.entity.is_player> || <c.entity.is_npc> || <c.entity.entity_type> == item_frame {
      - queue clear
      }
    - define target '<c.entity.entity_type>'
    - if <c.location.cuboids.alphanumeric.unseparated||null> == <player.location.cuboids.alphanumeric.unseparated||null> {
      - define sameRegion 'true'
      - define rateLimit '<player.flag[dRegions.rateLimit.entity-interact.%target%]||null>'
      - if %rateLimit% != null {
        - if %rateLimit% {
          - queue clear
          }
          else {
          - run s@dRegions_Flag_entity-interact p:msg delay:1t 'def:<def[target].to_lowercase.replace[_].with[ ]>'
          - determine cancelled
          }
        }
      }
      else {
      - define sameRegion 'false'
      }
    - if <player.permission[dRegions.admin]||false> || <player.is_op> {
      - if %sameRegion% flag <player> dRegions.rateLimit.entity-interact.%target%:true d:10s
      - queue clear
      }
    - define world '<player.world.name>'
    - define player '<player>'
    - if <c.location.cuboids.is_empty||true> {
      - define cache '<player.flag[dRegions.cache.%world%.__global__.entity-interact.%target%]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Entity-Interact'
        - inject s@dRegions_Flag_Entity-Interact p:event-global
        - queue clear
        }
      - if !%cache% {
        - if %sameRegion% flag <player> dRegions.rateLimit.entity-interact.%target%:false d:10s
        - run s@dRegions_Flag_Entity-Interact p:msg delay:1t 'def:<def[target].to_lowercase.replace[_].with[ ]>'
        - determine cancelled
        }
      - if %sameRegion% flag <player> dRegions.rateLimit.entity-interact.%target%:true d:10s
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Entity-Interact'
    - inject s@dRegions_Flag_Entity-Interact p:event

# This isn't even needed. The clicks entity event handles it without this.
# The client side glitch still exists. Such a shame to waste magic like this :/
#
#    on player dyes sheep:
#    - define color '<s@dRegions_Map_Interactions.yaml_key[dye_colors.<c.color>]>'
#    - define player '<c.entity.location.find.players.within[5].filter[item_in_hand.material.bukkit_enum.is[==].to[ink_sack]].filter[item_in_hand.material.data.is[==].to[%color%]].get[1]>'
#    - event player:%player% 'player right clicks entity' 'context:entity|<c.entity>|location|<c.entity.location>|dye|true' save:event
#    - if <entry[event].determinations.get[1]||null> == cancelled {
#      - determine cancelled
#      }

    on player enters bed:
    # Do we need to fire events for region enter, exit, and toggle?
    # This is a cheat so we don't have to mess about with firing a region entry event.
    - if <c.location.cuboids.alphanumeric.unseparated> == <player.location.cuboids.alphanumeric.unseparated> {
      - define sameRegion 'true'
      - define rateLimit '<player.flag[dRegions.rateLimit.sleep]||null>'
      - if %rateLimit% != null {
        - if %rateLimit% {
          - queue clear
          }
          else {
          - run s@dRegions_Flag_Sleep p:msg delay:1t
          - determine cancelled
          }
        }
      }
      else {
      - determine cancelled
      }
    - define world '<player.world.name>'
    - if <c.location.cuboids.is_empty> {
      - define cache '<player.flag[dRegions.cache.%world%.__global__.sleep]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Sleep'
        - inject s@dRegions_Flag_Sleep p:event-global
        - queue clear
        }
      - if !%cache% {
        - if %sameRegion% flag <player> dRegions.rateLimit.sleep:false d:10s
        - run s@dRegions_Flag_Sleep p:msg delay:1t
        - determine cancelled
        }
      - if %sameRegion% flag <player> dRegions.rateLimit.sleep:true d:10s
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Sleep'
    - inject s@dRegions_Flag_Sleep p:event

# Looks like this isn't needed since the cuboid enter/exit event fires
#    on player enters vehicle:
#    # Should be doing a check if the cart is in a different cuboid before firing
#    # the regionEnter and regionToggle events.
#    # Do we need to fire events for regionExit as well?
#    # Make vehicle-enter flag for this event!
#    - if <c.vehicle.location.cuboids.alphanumeric.unseparated||null> == <player.location.cuboids.alphanumeric.unseparated||null> {
#      - queue clear
#      }
#    - define world '<player.world.name.to_lowercase>'
#    - define isEnter ''
#    - if <c.vehicle.location.cuboids.is_empty||true> {
#      - define FlagScript 's@dRegions_Flag_Sleep'
#      - inject %FlagScript% p:event-global
#      - queue clear
#      }
#    - define regionPri 'li@'
#    - foreach <c.vehicle.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
#      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
#      }
#    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
#    - foreach <server.flag[dRegions_FlagMap].filter[contains_any[regionEnter|regionToggle]].parse[after[/]].alphanumeric.parse[split[/].get[2]]> {
#      - define FlagScript '%value%'
#      - inject %value% p:event
#      }


    on player enters notable cuboid:
    # Should we fire an event when the player exits the global region?
    - if <c.from.cuboids.is_empty> {
      - event 'player exits notable cuboid' 'context:cuboids|<c.from.cuboids.escaped>|from|<c.from>|to|<c.to>' save:exit
      - if <entry[exit].determinations.get[1]||null> == cancelled {
        - determine cancelled
        }
      }
    - define world '<c.to.world.name.to_lowercase>'
    - define cuboids '<c.to.cuboids.unescaped.as_list>'
    - if <def[cuboids].is_empty> {
      - define cache '<player.flag[dRegions.cache.%world%.__global__.entry]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Entry'
        - inject s@dRegions_Flag_Entry p:event-global
        - queue clear
        }
      - if !%cache% {
        - run s@dRegions_Flag_Entry p:msg delay:1t
        - determine cancelled
        }
      - inject s@dRegions_Flag_Entry p:event-global player:<player>
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <def[cuboids].parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Entry'
    - inject s@dRegions_Flag_Entry p:event

    on player exits notable cuboid:
    - define world '<c.from.world.name.to_lowercase>'
    - define cuboids '<c.from.cuboids.unescaped.as_list>'
    - if <def[cuboids].is_empty> {
      - define cache '<player.flag[dRegions.cache.%world%.__global__.exit]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Exit'
        - inject s@dRegions_Flag_Exit p:event-global
        - queue clear
        }
      - if !%cache% {
        - run s@dRegions_Flag_Exit p:msg delay:1t
        - determine cancelled
        }
      - inject s@dRegions_Flag_Exit p:event-global player:<player>
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <def[cuboids].parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Exit'
    - inject s@dRegions_Flag_Exit p:event
    - event 'player enters notable cuboid' 'context:cuboids|<c.to.cuboids.escaped>|from|<c.from>|to|<c.to>' save:enter
    - if <entry[enter].determinations.get[1]||null> == cancelled {
      - determine cancelled
      }

    on player breaks block:
    - define target '<c.material.bukkit_enum>'
    - if <c.cuboids.alphanumeric.unseparated> == <player.location.cuboids.alphanumeric.unseparated> {
      - define sameRegion 'true'
      - define rateLimit '<player.flag[dRegions.rateLimit.build]||null>'
      - if %rateLimit% != null {
        - if !%rateLimit% {
          - run s@dRegions_Flag_Build p:msg delay:1t
          - determine cancelled
          }
        }
      - define rateLimit '<player.flag[dRegions.rateLimit.block-break.%target%]||null>'
      - if %rateLimit% != null {
        - if %rateLimit% {
          - queue clear
          }
          else {
          - run s@dRegions_Flag_Block-Break p:msg delay:1t 'def:<def[target].to_lowercase.replace[_].with[ ]>'
          - determine cancelled
          }
        }
      }
      else {
      - define sameRegion 'false'
      }
    - if <player.permission[dRegions.admin]||false> || <player.is_op> {
      - if %sameRegion% flag <player> dRegions.rateLimit.build:true d:10s
      - if %sameRegion% flag <player> dRegions.rateLimit.block-break.%target%:true d:10s
      - queue clear
      }
    - define world '<player.world.name>'
    - if <c.cuboids.is_empty> {
      - define cache '<player.flag[dRegions.cache.%world%.__global__.build]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Build'
        - inject s@dRegions_Flag_Build p:event-global
        }
        else if !%cache% {
        - if %sameRegion% flag <player> dRegions.rateLimit.build:false d:10s
        - run s@dRegions_Flag_Build p:msg delay:1t
        - determine cancelled
        }
      - if %sameRegion% flag <player> dRegions.rateLimit.build:true d:10s
      - define cache '<player.flag[dRegions.cache.%world%.__global__.block-break.%target%]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_block-break'
        - inject s@dRegions_Flag_block-break p:event-global
        - queue clear
        }
      - if !%cache% {
        - if %sameRegion% flag <player> dRegions.rateLimit.block-break.%target%:false d:10s
        - run s@dRegions_Flag_block-break p:msg delay:1t 'def:<def[target].to_lowercase.replace[_].with[ ]>'
        - determine cancelled
        }
      - if %sameRegion% flag <player> dRegions.rateLimit.block-break.%target%:true d:10s
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Build'
    - inject s@dRegions_Flag_Build p:event
    - define FlagScript 's@dRegions_Flag_Block-Break'
    - inject s@dRegions_Flag_Block-Break p:event

    on player places block:
    - define target '<c.material.bukkit_enum>'
    - if <c.cuboids.alphanumeric.unseparated> == <player.location.cuboids.alphanumeric.unseparated> {
      - define sameRegion 'true'
      - define rateLimit '<player.flag[dRegions.rateLimit.build]||null>'
      - if %rateLimit% != null {
        - if !%rateLimit% {
          - run s@dRegions_Flag_Build p:msg delay:1t
          - determine cancelled
          }
        }
      - define rateLimit '<player.flag[dRegions.rateLimit.block-place.%target%]||null>'
      - if %rateLimit% != null {
        - if %rateLimit% {
          - queue clear
          }
          else {
          - run s@dRegions_Flag_Block-Place p:msg delay:1t 'def:<def[target].to_lowercase.replace[_].with[ ]>'
          - determine cancelled
          }
        }
      }
      else {
      - define sameRegion 'false'
      }
    - if <player.permission[dRegions.admin]||false> || <player.is_op> {
      - if %sameRegion% flag <player> dRegions.rateLimit.build:true d:10s
      - if %sameRegion% flag <player> dRegions.rateLimit.block-place.%target%:true d:10s
      - queue clear
      }
    - define world '<player.world.name>'
    - if <c.cuboids.is_empty> {
      - define cache '<player.flag[dRegions.cache.%world%.__global__.build]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Build'
        - inject s@dRegions_Flag_Build p:event-global
        }
        else if !%cache% {
        - if %sameRegion% flag <player> dRegions.rateLimit.build:false d:10s
        - run s@dRegions_Flag_Build p:msg delay:1t
        - determine cancelled
        }
      - if %sameRegion% flag <player> dRegions.rateLimit.build:true d:10s
      - define cache '<player.flag[dRegions.cache.%world%.__global__.block-place.%target%]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_block-place'
        - inject s@dRegions_Flag_block-place p:event-global
        - queue clear
        }
      - if !%cache% {
        - if %sameRegion% flag <player> dRegions.rateLimit.block-place.%target%:false d:10s
        - run s@dRegions_Flag_block-place p:msg delay:1t 'def:<def[target].to_lowercase.replace[_].with[ ]>'
        - determine cancelled
        }
      - if %sameRegion% flag <player> dRegions.rateLimit.block-place.%target%:true d:10s
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Build'
    - inject s@dRegions_Flag_Build p:event
    - define FlagScript 's@dRegions_Flag_Block-Place'
    - inject s@dRegions_Flag_Block-Place p:event

    on player empties bucket:
    - if <player.permission[dRegions.admin]||false> || <player.is_op> queue clear
    - define world '<player.world.name>'
    - if <c.relative.cuboids.alphanumeric.unseparated> == <player.location.cuboids.alphanumeric.unseparated> {
      - define sameRegion 'true'
      - define rateLimit '<player.flag[dRegions.rateLimit.bucket-empty]||null>'
      - if %rateLimit% != null {
        - if %rateLimit% {
          - queue clear
          }
          else {
          - run s@dRegions_Flag_Bucket-Empty p:msg delay:1t
          - determine cancelled
          }
        }
      }
      else {
      - define sameRegion 'false'
      }
    - if <c.relative.cuboids.is_empty> {
      - define cache '<player.flag[dRegions.cache.%world%.__global__.bucket-empty]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Bucket-Empty'
        - inject s@dRegions_Flag_Bucket-Empty p:event-global
        - queue clear
        }
      - if !%cache% {
        - if %sameRegion% flag <player> dRegions.rateLimit.bucket-empty:false d:10s
        - run s@dRegions_Flag_Bucket-Empty p:msg delay:1t
        - determine cancelled
        }
      - if %sameRegion% flag <player> dRegions.rateLimit.bucket-empty:true d:10s
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.relative.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Bucket-Empty'
    - inject s@dRegions_Flag_Bucket-Empty p:event

    on player fills bucket:
    - if <player.permission[dRegions.admin]||false> || <player.is_op> queue clear
    - define world '<player.world.name>'
    - if <c.location.cuboids.alphanumeric.unseparated> == <player.location.cuboids.alphanumeric.unseparated> {
      - define sameRegion 'true'
      - define rateLimit '<player.flag[dRegions.rateLimit.bucket-fill]||null>'
      - if %rateLimit% != null {
        - if %rateLimit% {
          - queue clear
          }
          else {
          - run s@dRegions_Flag_Bucket-Fill p:msg delay:1t
          - determine cancelled
          }
        }
      }
      else {
      - define sameRegion 'false'
      }
    - if <c.location.cuboids.is_empty||true> {
      - define cache '<player.flag[dRegions.cache.%world%.__global__.bucket-fill]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Bucket-Fill'
        - inject s@dRegions_Flag_Bucket-Fill p:event-global
        - queue clear
        }
      - if !%cache% {
        - if %sameRegion% flag <player> dRegions.rateLimit.bucket-fill:false d:10s
        - run s@dRegions_Flag_Bucket-Fill p:msg delay:1t
        - determine cancelled
        }
      - if %sameRegion% flag <player> dRegions.rateLimit.bucket-fill:true d:10s
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Bucket-Fill'
    - inject s@dRegions_Flag_Bucket-Fill p:event

    on player drops item:
    - define world '<player.world.name>'
    - if <c.location.cuboids.alphanumeric.unseparated> == <player.location.cuboids.alphanumeric.unseparated> {
      - define sameRegion 'true'
      - define rateLimit '<player.flag[dRegions.rateLimit.player-drops]||null>'
      - if %rateLimit% != null {
        - if %rateLimit% {
          - queue clear
          }
          else {
          - run s@dRegions_Flag_Player-Drops p:msg delay:1t
          - determine cancelled
          }
        }
      }
      else {
      - define sameRegion 'false'
      }
    - define cuboids '<player.location.cuboids.include[<c.location.cuboids>].deduplicate||li@>'
    - if <def[cuboids].is_empty> {
      - define cache '<player.flag[dRegions.cache.%world%.__global__.player-drops]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Player-Drops'
        - inject s@dRegions_Flag_Player-Drops p:event-global
        - queue clear
        }
      - if !%cache% {
        - if %sameRegion% flag <player> dRegions.rateLimit.player-drops:false d:10s
        - run s@dRegions_Flag_Player-Drops p:msg delay:1t
        - determine cancelled
        }
      - if %sameRegion% flag <player> dRegions.rateLimit.player-drops:true d:10s
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <def[cuboids].parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Player-Drops'
    - inject s@dRegions_Flag_Player-Drops p:event

    on player picks up item:
    - define world '<player.world.name>'
    - if <c.location.cuboids.alphanumeric.unseparated> == <player.location.cuboids.alphanumeric.unseparated> {
      - define sameRegion 'true'
      - define rateLimit '<player.flag[dRegions.rateLimit.player-pickup]||null>'
      - if %rateLimit% != null {
        - if %rateLimit% {
          - queue clear
          }
          else {
          - run s@dRegions_Flag_Player-Pickup p:msg delay:1t
          - determine cancelled
          }
        }
      }
      else {
      - define sameRegion 'false'
      }
    - define cuboids '<player.location.cuboids.include[<c.location.cuboids>].deduplicate||li@>'
    - if <def[cuboids].is_empty> {
      - define cache '<player.flag[dRegions.cache.%world%.__global__.player-pickup]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Player-Pickup'
        - inject s@dRegions_Flag_Player-Pickup p:event-global
        - queue clear
        }
      - if !%cache% {
        - if %sameRegion% flag <player> dRegions.rateLimit.player-pickup:false d:10s
        - run s@dRegions_Flag_Player-Pickup p:msg delay:1t
        - determine cancelled
        }
      - if %sameRegion% flag <player> dRegions.rateLimit.player-pickup:true d:10s
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <def[cuboids].parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Player-Pickup'
    - inject s@dRegions_Flag_Player-Pickup p:event

    on player places hanging:
    - if <player.permission[dRegions.admin]||false> || <player.is_op> queue clear
    - define world '<player.world.name>'
    - if <c.location.cuboids.alphanumeric.unseparated> == <player.location.cuboids.alphanumeric.unseparated> {
      - define sameRegion 'true'
      - define rateLimit '<player.flag[dRegions.rateLimit.build]||null>'
      - if %rateLimit% != null {
        - if !%rateLimit% {
          - run s@dRegions_Flag_Build p:msg delay:1t
          - determine cancelled
          }
        }
      - define rateLimit '<player.flag[dRegions.rateLimit.hanging-place]||null>'
      - if %rateLimit% != null {
        - if %rateLimit% {
          - queue clear
          }
          else {
          - run s@dRegions_Flag_Hanging-Blace p:msg delay:1t
          - determine cancelled
          }
        }
      }
      else {
      - define sameRegion 'false'
      }
    - if <c.location.cuboids.is_empty||true> {
      - define cache '<player.flag[dRegions.cache.%world%.__global__.build]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Build'
        - inject s@dRegions_Flag_Build p:event-global
        }
        else if !%cache% {
        - if %sameRegion% flag <player> dRegions.rateLimit.build:false d:10s
        - run s@dRegions_Flag_Build p:msg delay:1t
        - determine cancelled
        }
      - if %sameRegion% flag <player> dRegions.rateLimit.build:true d:10s
      - define cache '<player.flag[dRegions.cache.%world%.__global__.hanging-place]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Hanging-Place'
        - inject s@dRegions_Flag_Hanging-Place p:event-global
        - queue clear
        }
      - if !%cache% {
        - if %sameRegion% flag <player> dRegions.rateLimit.hanging-place:false d:10s
        - run s@dRegions_Flag_Build p:msg delay:1t
        - determine cancelled
        }
      - if %sameRegion% flag <player> dRegions.rateLimit.hanging-place:true d:10s
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Build'
    - inject s@dRegions_Flag_Build p:event
    - define FlagScript 's@dRegions_Flag_Hanging-Place'
    - inject s@dRegions_Flag_Hanging-Place p:event

    on player right clicks at armor_stand:
    - if <player.permission[dRegions.admin]||false> || <player.is_op> queue clear
    - define world '<player.world.name>'
    - if <c.entity.location.cuboids.alphanumeric.unseparated> == <player.location.cuboids.alphanumeric.unseparated> {
      - define sameRegion 'true'
      - define rateLimit '<player.flag[dRegions.rateLimit.build]||null>'
      - if %rateLimit% != null {
        - if %rateLimit% {
          - queue clear
          }
          else {
          - run s@dRegions_Flag_Build p:msg delay:1t
          - determine cancelled
          }
        }
      }
      else {
      - define sameRegion 'false'
      }
    - if <c.entity.location.cuboids.is_empty||true> {
      - define cache '<player.flag[dRegions.cache.%world%.__global__.build]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Build'
        - inject s@dRegions_Flag_Build p:event-global
        - queue clear
        }
      - if !%cache% {
        - if %sameRegion% flag <player> dRegions.rateLimit.build:false d:10s
        - run s@dRegions_Flag_Build p:msg delay:1t
        - determine cancelled
        }
      - if %sameRegion% flag <player> dRegions.rateLimit.build:true d:10s
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.entity.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Build'
    - inject s@dRegions_Flag_Build p:event

    on player right clicks item_frame:
    - if <player.permission[dRegions.admin]||false> || <player.is_op> queue clear
    - define world '<player.world.name>'
    - if <c.entity.location.cuboids.alphanumeric.unseparated> == <player.location.cuboids.alphanumeric.unseparated> {
      - define sameRegion 'true'
      - define rateLimit '<player.flag[dRegions.rateLimit.build]||null>'
      - if %rateLimit% != null {
        - if %rateLimit% {
          - queue clear
          }
          else {
          - run s@dRegions_Flag_Build p:msg delay:1t
          - determine cancelled
          }
        }
      }
      else {
      - define sameRegion 'false'
      }
    - if <c.entity.location.cuboids.is_empty||true> {
      - define cache '<player.flag[dRegions.cache.%world%.__global__.build]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Build'
        - inject s@dRegions_Flag_Build p:event-global
        - queue clear
        }
      - if !%cache% {
        - if %sameRegion% flag <player> dRegions.rateLimit.build:false d:10s
        - run s@dRegions_Flag_Build p:msg delay:1t
        - determine cancelled
        }
      - if %sameRegion% flag <player> dRegions.rateLimit.build:true d:10s
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.entity.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Build'
    - inject s@dRegions_Flag_Build p:event

    on player damages item_frame:
    - if <player.permission[dRegions.admin]||false> || <player.is_op> queue clear
    - define world '<player.world.name>'
    - if <c.entity.location.cuboids.alphanumeric.unseparated> == <player.location.cuboids.alphanumeric.unseparated> {
      - define sameRegion 'true'
      - define rateLimit '<player.flag[dRegions.rateLimit.build]||null>'
      - if %rateLimit% != null {
        - if %rateLimit% {
          - queue clear
          }
          else {
          - run s@dRegions_Flag_Build p:msg delay:1t
          - determine cancelled
          }
        }
      }
      else {
      - define sameRegion 'false'
      }
    - if <c.entity.location.cuboids.is_empty||true> {
      - define cache '<player.flag[dRegions.cache.%world%.__global__.build]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Build'
        - inject s@dRegions_Flag_Build p:event-global
        - queue clear
        }
      - if !%cache% {
        - if %sameRegion% flag <player> dRegions.rateLimit.build:false d:10s
        - run s@dRegions_Flag_Build p:msg delay:1t
        - determine cancelled
        }
      - if %sameRegion% flag <player> dRegions.rateLimit.build:true d:10s
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.entity.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Build'
    - inject s@dRegions_Flag_Build p:event

    on player damages player:
    - if <player.permission[dRegions.admin]||false> || <player.is_op> queue clear
    - define world '<c.entity.world.name>'
    - if <c.entity.location.cuboids.is_empty> {
      - define cache '<yaml[dRegions_%world%_cache].read[cache.boolean.__global__.pvp]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_PVP'
        - inject s@dRegions_Flag_PVP p:event-global
        - queue clear
        }
      - if !%cache% {
        - determine cancelled
        }
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.entity.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_PVP'
    - inject s@dRegions_Flag_PVP p:event

    on player damages armor_stand:
    - if <player.permission[dRegions.admin]||false> || <player.is_op> queue clear
    - define world '<c.entity.world.name>'
    - if <c.entity.location.cuboids.alphanumeric.unseparated> == <player.location.cuboids.alphanumeric.unseparated> {
      - define sameRegion 'true'
      - define rateLimit '<player.flag[dRegions.rateLimit.build]||null>'
      - if %rateLimit% != null {
        - if %rateLimit% {
          - queue clear
          }
          else {
          - run s@dRegions_Flag_Build p:msg delay:1t
          - determine cancelled
          }
        }
      }
      else {
      - define sameRegion 'false'
      }
    - if <c.entity.location.cuboids.is_empty||true> {
      - define cache '<player.flag[dRegions.cache.%world%.__global__.build]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Build'
        - inject s@dRegions_Flag_Build p:event-global
        - queue clear
        }
      - if !%cache% {
        - if %sameRegion% flag <player> dRegions.rateLimit.build:false d:10s
        - run s@dRegions_Flag_Build p:msg delay:1t
        - determine cancelled
        }
      - if %sameRegion% flag <player> dRegions.rateLimit.build:true d:10s
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.entity.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Build'
    - inject %FlagScript% p:event

    on player damages entity:
    - if li@armor_stand|player|item_frame contains <c.entity.entity_type> {
      - queue clear
      }
    - if <player.permission[dRegions.admin]||false> || <player.is_op> queue clear
    - define target '<c.entity.entity_type>'
    - define player '<c.damager>'
    - if <c.entity.location.cuboids.alphanumeric.unseparated||null> == <player.location.cuboids.alphanumeric.unseparated||null> {
      - define sameRegion 'true'
      - define rateLimit '<player.flag[dRegions.rateLimit.pve.%target%]||null>'
      - if %rateLimit% != null {
        - if %rateLimit% {
          - queue clear
          }
          else {
          - remove <c.projectile||li@>
          - run s@dRegions_Flag_pve p:msg delay:1t 'def:<def[target].to_lowercase.replace[_].with[ ]>'
          - determine cancelled
          }
        }
      }
      else {
      - define sameRegion 'false'
      }
    - define world '<c.entity.world.name>'
    - if <c.entity.location.cuboids.is_empty> {
      - define cache '<player.flag[dRegions.cache.%world%.__global__.pve.%target%]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_pve'
        - inject s@dRegions_Flag_pve p:event-global
        - queue clear
        }
      - if !%cache% {
        - if %sameRegion% flag <player> dRegions.rateLimit.pve.%target%:false d:10s
        - remove <c.projectile||li@>
        - run s@dRegions_Flag_pve p:msg delay:1t 'def:<def[target].to_lowercase.replace[_].with[ ]>'
        - determine cancelled
        }
      - if %sameRegion% flag <player> dRegions.rateLimit.pve.%target%:true d:10s
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.entity.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_PVE'
    - inject %FlagScript% p:event

    on player left clicks block:
    - if <c.relative.material.name> != fire {
      - queue clear
      }
    - if <player.permission[dRegions.admin]||false> || <player.is_op> queue clear
    - define world '<player.world.name>'
    - if <c.relative.cuboids.alphanumeric.unseparated> == <player.location.cuboids.alphanumeric.unseparated> {
      - define sameRegion 'true'
      - define rateLimit '<player.flag[dRegions.rateLimit.build]||null>'
      - if %rateLimit% != null {
        - if %rateLimit% {
          - queue clear
          }
          else {
          - run s@dRegions_Flag_Build p:msg delay:1t
          - determine cancelled
          }
        }
      }
      else {
      - define sameRegion 'false'
      }
    - if <c.relative.cuboids.is_empty||true> {
      - define cache '<player.flag[dRegions.cache.%world%.__global__.build]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Build'
        - inject s@dRegions_Flag_Build p:event-global
        - queue clear
        }
      - if !%cache% {
        - if %sameRegion% flag <player> dRegions.rateLimit.build:false d:10s
        - run s@dRegions_Flag_Build p:msg delay:1t
        - determine cancelled
        }
      - if %sameRegion% flag <player> dRegions.rateLimit.build:true d:10s
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.relative.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Build'
    - inject s@dRegions_Flag_Build p:event

    on player clicks block with bone_meal:
    - if <player.permission[dRegions.admin]||false> || <player.is_op> queue clear
    - define world '<player.world.name>'
    - if <c.cuboids.alphanumeric.unseparated> == <player.location.cuboids.alphanumeric.unseparated> {
      - define sameRegion 'true'
      - define rateLimit '<player.flag[dRegions.rateLimit.build]||null>'
      - if %rateLimit% != null {
        - if %rateLimit% {
          - queue clear
          }
          else {
          - run s@dRegions_Flag_Build p:msg delay:1t
          - determine cancelled
          }
        }
      }
      else {
      - define sameRegion 'false'
      }
    - if <c.cuboids.is_empty> {
      - define cache '<player.flag[dRegions.cache.%world%.__global__.build]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Build'
        - inject s@dRegions_Flag_Build p:event-global
        - queue clear
        }
      - if !%cache% {
        - if %sameRegion% flag <player> dRegions.rateLimit.build:false d:10s
        - run s@dRegions_Flag_Build p:msg delay:1t
        - determine cancelled
        }
      - if %sameRegion% flag <player> dRegions.rateLimit.build:true d:10s
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Build'
    - inject s@dRegions_Flag_Build p:event

    on player damaged:
    - define rateLimit '<player.flag[dRegions.rateLimit.player-damage.<c.cause>]||null>'
    - define sameRegion 'true'
    - if %rateLimit% != null {
      - if %rateLimit% {
        - queue clear
        }
        else {
        - determine cancelled
        }
      }
    - if ( <player.permission[dregions.invincible]> || <player.permission[dregions.invincible.<c.cause>]> ) && !<player.is_op> {
      - flag <player> dRegions.rateLimit.player-damage.%target%:false d:5s
      - adjust <player> 'fire_time:0'
      - determine cancelled
      }
    - define world '<c.entity.world.name>'
    - define target '<c.cause>'
    - define player '<player>'
    - define readPath 'player-damage'
    - inject s@dRegions p:event_PreProc_Config
    - if <c.entity.location.cuboids.is_empty||true> {
      - define cache '<player.flag[dRegions.cache.%world%.__global__.player-damage.%target%]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Player-Damage'
        - inject s@dRegions_Flag_Player-Damage p:event-global
        - queue clear
        }
      - if !%cache% {
        - flag <player> dRegions.rateLimit.player-damage.%target%:false d:10s
        - adjust <player> 'fire_time:0'
        - determine cancelled
        }
      - flag <player> dRegions.rateLimit.player-damage.%target%:true d:10s
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.entity.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Player-Damage'
    - inject s@dRegions_Flag_Player-Damage p:event

    on player changes food level:
    - if <c.food> >= <player.food_level> queue clear
    - define sameRegion 'true'
    - define rateLimit '<player.flag[dRegions.rateLimit.hunger]||null>'
    - if %rateLimit% != null {
      - if %rateLimit% {
        - queue clear
        }
        else {
        - determine cancelled
        }
      }
    - define world '<player.world.name>'
    - if <player.location.cuboids.is_empty> {
      - define cache '<player.flag[dRegions.cache.%world%.__global__.hunger]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Hunger'
        - inject s@dRegions_Flag_Hunger p:event-global
        - queue clear
        }
      - if !%cache% {
        - if %sameRegion% flag <player> dRegions.rateLimit.hunger:false d:10s
        - determine cancelled
        }
      - if %sameRegion% flag <player> dRegions.rateLimit.hunger:true d:10s
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <player.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Hunger'
    - inject s@dRegions_Flag_Hunger p:event

    on player teleports:
    - if <c.origin.world> != <c.destination.world> {
      - if <c.origin.cuboids.is_empty> && <c.destination.cuboids.is_empty> {
        - event 'player enters notable cuboid' 'context:cuboids|<c.origin.cuboids.escaped>|from|<c.origin>|to|<c.destination>' save:enter
        - if <entry[enter].determinations.get[1]||null> == cancelled {
          - determine cancelled
          }
        }
      }
    - if <c.cause> != ender_pearl queue clear
    - if <player.permission[dRegions.admin]||false> || <player.is_op> queue clear
    - if <c.origin.location.cuboids.alphanumeric.unseparated> == <c.destination.location.cuboids.alphanumeric.unseparated> {
      - define sameRegion 'true'
      - define rateLimit '<player.flag[dRegions.rateLimit.enderpearl]||null>'
      - if %rateLimit% != null {
        - if %rateLimit% {
          - queue clear
          }
          else {
          - run s@dRegions_Flag_Enderpearl p:msg delay:1t
          - determine cancelled
          }
        }
      }
      else {
      - define sameRegion 'false'
      }
    - define world '<player.world.name>'
    - define cuboids '<c.origin.cuboids.include[<c.destination.cuboids>].deduplicate||li@>'
    - if <def[cuboids].is_empty> {
      - define cache '<player.flag[dRegions.cache.%world%.__global__.enderpearl]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Enderpearl'
        - inject s@dRegions_Flag_Enderpearl p:event-global
        - queue clear
        }
      - if !%cache% {
        - if %sameRegion% flag <player> dRegions.rateLimit.enderpearl:false d:10s
        - run s@dRegions_Flag_Enderpearl p:msg delay:1t
        - determine cancelled
        }
      - if %sameRegion% flag <player> dRegions.rateLimit.enderpearl:true d:10s
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <def[cuboids].parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Enderpearl'
    - inject s@dRegions_Flag_Enderpearl p:event

    on player respawns:
    - if <player.has_flag[dRegions_Respawn]> {
      - adjust <player> 'health:<player.health.max>'
      - determine passively '<player.flag[dRegions_Respawn].as_location||<world.spawn_location>>'
      - wait 10t
      - flag <player> 'dRegions_Respawn:!'
      }

#
#  END Player Events
##################################################
#
#  Mob Events
#
    on entity targets entity:
    - if <c.target.prefix> == player {
      - queue clear
      }
    - define world '<c.entity.world.name>'
    - define attacker '<c.entity>'
    - define defender '<c.target>'
    - define atarget '<c.entity.entity_type>'
    - define dtarget '<c.target.entity_type>'
    - if <c.target.location.cuboids.is_empty||true> {
      - define cache '<yaml[dRegions_%world%_cache].read[cache.state-withTarget.__global__.mob-attack.%atarget%]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Mob-Attack'
        - inject s@dRegions_Flag_Mob-Attack p:event-global
        }
        else if !%cache% {
        - remove <c.projectile||li@>
        - attack %attacker% target:cancel
        - run s@dRegions_Flag_Mob-Attack p:wander delay:1t def:%attacker%
        - determine cancelled
        }
      - define cache '<yaml[dRegions_%world%_cache].read[cache.state-withTarget.__global__.eve.%dtarget%]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_EVE'
        - inject s@dRegions_Flag_EVE p:event-global
        - queue clear
        }
      - if !%cache% {
        - remove <c.projectile||li@>
        - attack %attacker% target:cancel
        - run s@dRegions_Flag_EVE p:wander delay:1t def:%attacker%
        - determine cancelled
        }
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.target.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Mob-Attack'
    - inject s@dRegions_Flag_Mob-Attack p:event
    - define FlagScript 's@dRegions_Flag_EVE'
    - inject s@dRegions_Flag_EVE p:event

    on entity targets player:
    - define target '<c.entity.entity_type>'
    - define attacker '<c.entity>'
    - if <c.entity.location.cuboids.alphanumeric.unseparated||null> == <c.target.location.cuboids.alphanumeric.unseparated||null> {
      - define sameRegion 'true'
      - define rateLimit '<c.target.flag[dRegions.rateLimit.mob-target.%target%]||null>'
      - if %rateLimit% != null {
        - if %rateLimit% {
          - queue clear
          }
          else {
          - attack %attacker% target:cancel
          - run delay:1t s@dRegions_Flag_Mob-Target p:wander 'def:%attacker%'
          - determine cancelled
          }
        }
      }
      else {
      - define sameRegion 'false'
      }
    - define player '<c.target>'
    - define world '<c.entity.world.name>'
    - if <c.target.location.cuboids.is_empty> {
      - define cache '<c.target.flag[dRegions.cache.%world%.__global__.flag.%target%]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Mob-Target'
        - inject s@dRegions_Flag_Mob-Target p:event-global
        - queue clear
        }
      - if !%cache% {
        - attack %attacker% target:cancel
        - if %sameRegion% flag %player% dRegions.rateLimit.mob-target.%target%:false d:10s
        - run delay:1t s@dRegions_Flag_Mob-Target p:wander 'def:%attacker%'
        - determine cancelled
        }
      - if %sameRegion% flag <c.target> dRegions.rateLimit.mob-target.%target%:true d:10s
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.target.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Mob-Target'
    - inject s@dRegions_Flag_Mob-Target p:event

#  This needs to be rewritten cause... idk
#
#    on entity damaged by block_explosion:
#    - announce "block_explosion <c.cause>"
#    - define world '<c.entity.world.name>'
#    - if <c.entity.location.cuboids.is_empty||true> {
#      - define FlagScript 's@dRegions_Flag_Entity-Explode'
#      - inject s@dRegions_Flag_Entity-Explode p:event-global
#      - queue clear
#      }
#    - define regionPri 'li@'
#    - foreach <c.entity.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
#      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
#      }
#    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
#    - define FlagScript 's@dRegions_Flag_Entity-Explode'
#    - inject s@dRegions_Flag_Entity-Explode p:event

    on entity damages entity:
    - if li@<c.damager.prefix>|<c.entity.prefix> contains player {
      - queue clear
      }
    - define world '<c.entity.world.name>'
    - define attacker '<c.damager>'
    - define defender '<c.entity>'
    - define atarget '<c.damager.entity_type>'
    - define dtarget '<c.entity.entity_type>'
    - if <c.entity.location.cuboids.is_empty||true> {
#      - if <c.cause> == entity_explosion {
#        - define target '%atarget%'
#        - define cache '<yaml[dRegions_%world%_cache].read[cache.state-withTarget.__global__.mob-attack.%atarget%]||null>'
#        - if %cache% != null {
#          - if !%cache% {
#            - determine cancelled
#            }
#          }
#          else {
#          - define FlagScript 's@dRegions_Flag_Entity-Explode'
#          - inject s@dRegions_Flag_Entity-Explode p:event-global
#          }
#        }
      - define FlagScript 's@dRegions_Flag_Mob-Attack'
      - inject s@dRegions_Flag_Mob-Attack p:event-global
      - define FlagScript 's@dRegions_Flag_EVE'
      - inject s@dRegions_Flag_EVE p:event-global
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.entity.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
#    - if <c.cause> == entity_explosion {
#      - define target '%atarget%'
#      - define FlagScript 's@dRegions_Flag_Entity-Explode'
#      - inject s@dRegions_Flag_Entity-Explode p:event
#      }
    - define FlagScript 's@dRegions_Flag_Mob-Attack'
    - inject s@dRegions_Flag_Mob-Attack p:event
    - define FlagScript 's@dRegions_Flag_EVE'
    - inject s@dRegions_Flag_EVE p:event


    on entity damages player:
    - if <c.damager.prefix> == player {
      - queue clear
      }
    - define attacker '<c.damager>'
    - define target '<c.damager.entity_type>'
    - define player '<c.entity>'
    - if <c.damager.location.cuboids.alphanumeric.unseparated||null> == <c.entity.location.cuboids.alphanumeric.unseparated||null> {
      - define sameRegion 'true'
      - define rateLimit '<c.entity.flag[dRegions.rateLimit.mob-damage.%target%]||null>'
      - if %rateLimit% != null {
        - if %rateLimit% {
          - queue clear
          }
          else {
          - remove <c.projectile||li@>
          - attack %attacker% target:cancel
          - run delay:1t s@dRegions_Flag_Mob-Damage p:wander 'def:%attacker%'
          - determine cancelled
          }
        }
      }
      else {
      - define sameRegion 'false'
      }
    - define world '<c.entity.world.name>'
    - if <c.entity.location.cuboids.is_empty||true> {
#      - if <c.cause> == entity_explosion {
#        - define FlagScript 's@dRegions_Flag_Entity-Explode'
#        - inject s@dRegions_Flag_Entity-Explode p:event-global
#        }
      - define cache '<c.entity.flag[dRegions.cache.%world%.__global__.flag.%target%]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Mob-Damage'
        - inject s@dRegions_Flag_Mob-Damage p:event-global
        - queue clear
        }
      - if !%cache% {
        - flag <c.entity> dRegions.rateLimit.mob-damage.%target%:false d:10s
        - remove <c.projectile||li@>
        - attack %attacker% target:cancel
        - run delay:1t s@dRegions_Flag_Mob-Damage p:wander 'def:%attacker%'
        - determine cancelled
        }
      - if %sameRegion% flag <c.entity> dRegions.rateLimit.mob-damage.%target%:true d:10s
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.entity.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
#    - if <c.cause> == entity_explosion {
#      - define FlagScript 's@dRegions_Flag_Entity-Explode'
#      - inject s@dRegions_Flag_Entity-Explode p:event
#      }
    - define FlagScript 's@dRegions_Flag_Mob-Damage'
    - inject s@dRegions_Flag_Mob-Damage p:event

    on player dies:
    - define world '<c.entity.world.name>'
    - define target '<c.entity.entity_type>'
    - define sameRegion 'true'
    - if <c.entity.location.cuboids.is_empty||true> {
      - run player:<c.entity> s@dRegions_Flag_Spawn p:event-global def:%world% delay:1t
      - define FlagScript 's@dRegions_Flag_Player-KeepItems'
      - inject s@dRegions_Flag_Player-KeepItems p:event-global
      - define FlagScript 's@dRegions_Flag_Player-Drops-OnDeath'
      - inject s@dRegions_Flag_Player-Drops-OnDeath p:event-global
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.entity.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - run player:<c.entity> s@dRegions_Flag_Spawn p:event def:%world%|<def[orderedRegions].escaped> delay:1t
    - define FlagScript 's@dRegions_Flag_Player-KeepItems'
    - inject s@dRegions_Flag_Player-KeepItems p:event
    - define FlagScript 's@dRegions_Flag_Player-Drops-OnDeath'
    - inject s@dRegions_Flag_Player-Drops-OnDeath p:event

    on entity dies:
    - if <c.entity.prefix> == player {
      - queue clear
      }
    - define world '<c.entity.world.name>'
    - define target '<c.entity.entity_type>'
    - if <c.entity.location.cuboids.is_empty||true> {
      - define cache '<yaml[dRegions_%world%_cache].read[cache.state-withTarget.__global__.entity-drops-ondeath.%target%]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Entity-Drops-OnDeath'
        - inject s@dRegions_Flag_Entity-Drops-OnDeath p:event-global
        - queue clear
        }
      - if !%cache% {
        - determine no_drops
        }
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.entity.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Entity-Drops-OnDeath'
    - inject s@dRegions_Flag_Entity-Drops-OnDeath p:event

    on entity spawns:
    - define world '<c.entity.world.name>'
    - define target '<c.entity.entity_type>'
    - if <c.entity.location.cuboids.is_empty||true> {
      - define cache '<yaml[dRegions_%world%_cache].read[cache.state-withTarget.__global__.mob-spawn.%target%]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Mob-Spawn'
        - inject s@dRegions_Flag_Mob-Spawn p:event-global
        - queue clear
        }
      - if !%cache% {
        - determine cancelled
        }
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Mob-Spawn'
    - inject s@dRegions_Flag_Mob-Spawn p:event

    on entity enters portal:
    - define world '<c.location.world.name.to_lowercase>'
    - define readPath 'portal.<tern[<c.entity.is_player>]:player||entity>-enter'
    - inject s@dRegions p:event_PreProc_Config-NoTarget

    on entity changes soil:
    - define world '<c.location.world.name>'
    - define type '<c.entity.prefix>'
    - define readPath 'trample-crops.%type%'
    - inject s@dRegions p:event_PreProc_Config-NoTarget
    - if <c.location.cuboids.is_empty> {
      - define cache '<yaml[dRegions_%world%_cache].read[cache.boolean.__global__.trample-crops-%type%]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Trample-Crops-%type%'
        - inject s@dRegions_Flag_Trample-Crops-%type% p:event-global
        - queue clear
        }
      - if !%cache% {
        - determine cancelled
        }
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Trample-Crops-%type%'
    - inject %FlagScript% p:event

    on falling_block changes block:
    - define mat '<c.entity.fallingblock_material.bukkit_enum>'
    - if li@sand|gravel !contains %mat% queue clear
    - define world '<c.location.world.name>'
    - define readPath 'physics.%mat%'
    - define FlagScript 's@dRegions_Flag_Falling-%mat%'
    - inject s@dRegions p:event_PreProc_Config-NoTarget
    - if <c.location.cuboids.is_empty> {
      - define cache '<yaml[dRegions_%world%_cache].read[cache.boolean.__global__.falling-%mat%]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Falling-%mat%'
        - inject s@dRegions_Flag_Falling-%mat% p:event-global
        - queue clear
        }
      - if !%cache% {
        - determine cancelled
        }
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Falling-%mat%'
    - inject %FlagScript% p:event

    on entity changes block:
    # Maybe we want to check block changes here for explosions?
    # It's currently disabled because even if the explosion is cancelled, the block
    # change event(s) still fire (yes, one explosion can have multiple block changes)
    - if <c.old_material.bukkit_enum> == soil || li@falling_block|creeper|primed_tnt contains <c.entity.entity_type> {
      - queue clear
      }
    - define world '<c.location.world.name>'
    - define readPath 'entity.changeBlock'
    - define target '<c.entity.entity_type>'
    - inject s@dRegions p:event_PreProc_Config
    - if <c.location.cuboids.is_empty> {
      - define cache '<yaml[dRegions_%world%_cache].read[cache.state-withTarget.__global__.entity-grief.%target%]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Entity-Grief'
        - inject s@dRegions_Flag_Entity-Grief p:event-global
        - queue clear
        }
      - if !%cache% {
#        - run s@dRegions_Flag_Entity-Grief offthread delay:1t def:<c.entity.uuid>
        - determine cancelled
        }
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Entity-Grief'
    - inject s@dRegions_Flag_Entity-Grief p:event

    on entity forms block:
#    - if <c.entity.has_flag[dRegions_NoGrief]> determine cancelled
    - if <server.has_flag[dRegions.EntityGrief.<c.entity.uuid>]> {
      - determine cancelled
      }
    - define world '<c.location.world.name>'
    - define readPath 'entity.changeBlock'
    - define target '<c.entity.entity_type||other>'
    - inject s@dRegions p:event_PreProc_Config
    - if <c.location.cuboids.is_empty> {
      - define cache '<yaml[dRegions_%world%_cache].read[cache.state-withTarget.__global__.entity-grief.%target%]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Entity-Grief'
        - inject s@dRegions_Flag_Entity-Grief p:event-global
        - queue clear
        }
      - if !%cache% {
        - run s@dRegions_Flag_Entity-Grief offthread delay:1t def:<c.entity.uuid>
        - determine cancelled
        }
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Entity-Grief'
    - inject s@dRegions_Flag_Entity-Grief p:event

    on entity explodes:
    - define world '<c.location.world.name>'
    - define readPath 'entity.explode'
    - define attacker '<c.entity>'
    - define target '<c.entity.entity_type>'
    - inject s@dRegions p:event_PreProc_Config
    - if <c.location.cuboids.is_empty> {
      - define cache '<yaml[dRegions_%world%_cache].read[cache.state-withTarget.__global__.entity-explode.%target%]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Entity-Explode'
        - inject s@dRegions_Flag_Entity-Explode p:event-global
        - queue clear
        }
      - if !%cache% {
        - determine cancelled
        }
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Entity-Explode'
    - inject s@dRegions_Flag_Entity-Explode p:event

    on entity breaks hanging:
    - if <c.entity.prefix> == player {
      - queue clear
      }
    - define world '<c.entity.world.name>'
    - define type '<c.hanging.entity_type.replace[_]>'
    - define readPath 'entity-break-%type%'
    - inject s@dRegions p:event_PreProc_Config-NoTarget
    - if <c.hanging.location.cuboids.is_empty> {
      - define cache '<yaml[dRegions_%world%_cache].read[cache.boolean.__global__.entity-break-%type%]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Entity-Break-%type%'
        - inject s@dRegions_Flag_Entity-Break-%type% p:event-global
        - queue clear
        }
      - if !%cache% {
        - determine cancelled
        }
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.hanging.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Entity-Break-%type%'
    - inject %FlagScript% p:event

    on player breaks hanging:
    - if <player.permission[dRegions.admin]||false> || <player.is_op> queue clear
    - define world '<c.entity.world.name>'
    - if <c.hanging.location.cuboids.alphanumeric.unseparated> == <player.location.cuboids.alphanumeric.unseparated> {
      - define sameRegion 'true'
      - define rateLimit '<player.flag[dRegions.rateLimit.build]||null>'
      - if %rateLimit% != null {
        - if !%rateLimit% {
          - run s@dRegions_Flag_Build p:msg delay:1t
          - determine cancelled
          }
        }
      - define rateLimit '<player.flag[dRegions.rateLimit.hanging-break]||null>'
      - if %rateLimit% != null {
        - if %rateLimit% {
          - queue clear
          }
          else {
          - run s@dRegions_Flag_Hanging-Break p:msg delay:1t
          - determine cancelled
          }
        }
      }
      else {
      - define sameRegion 'false'
      }
    - if <c.hanging.location.cuboids.is_empty> {
      - define cache '<player.flag[dRegions.cache.%world%.__global__.build]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Build'
        - inject s@dRegions_Flag_Build p:event-global
        }
        else if !%cache% {
        - if %sameRegion% flag <player> dRegions.rateLimit.build:false d:10s
        - run s@dRegions_Flag_Build p:msg delay:1t
        - determine cancelled
        }
      - if %sameRegion% flag <player> dRegions.rateLimit.build:true d:10s
      - define cache '<player.flag[dRegions.cache.%world%.__global__.hanging-break]||null>'
      - if %cache% == null {
        - define FlagScript 's@dRegions_Flag_Hanging-Break'
        - inject s@dRegions_Flag_Hanging-Break p:event-global
        - queue clear
        }
      - if !%cache% {
        - if %sameRegion% flag <player> dRegions.rateLimit.hanging-break:false d:10s
        - run s@dRegions_Flag_Hanging-Break p:msg delay:1t
        - determine cancelled
        }
      - if %sameRegion% flag <player> dRegions.rateLimit.hanging-break:true d:10s
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <c.hanging.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - define FlagScript 's@dRegions_Flag_Build'
    - inject s@dRegions_Flag_Build p:event
    - define FlagScript 's@dRegions_Flag_Hanging-Break'
    - inject s@dRegions_Flag_Hanging-Break p:event



#
#  END Mob Events
##################################################
#
#  Utility Subscripts
#

  testinga:
    - ^define world '<player.location.world.name.to_lowercase>'
    - define regionPri 'li@'
    - foreach <player.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]]>|__global__ {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - ^narrate %orderedRegions%


  testingb:
    - ^define world '<player.location.world.name.to_lowercase>'
    - define regionPri 'li@'
    - foreach <player.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - foreach <server.flag[dRegions_FlagMap].filter[contains_any[regionEnter|regionToggle]].parse[after[/]].alphanumeric.parse[split[/].get[2]]> {
      - define FlagScript '%value%'
      }

  testingc:
    - define owners '<yaml[dRegions_WGImport_Station].read[regions.flakeslayer-restaurant.owners.unique-ids]>'
    - foreach %owners% {
      - narrate %value%
      }



  start:
    - inject locally loadYaml
    - define flags '<server.list_flags.filter[starts_with[dRegions]]>'
    - foreach %flags% {
      - flag server %value%:!
      }
    - define flagScripts '<server.list_scripts.filter[starts_with[s@dRegions_Flag_]]||li@>'
    - flag server 'dRegions_Flags:!'
    - flag server 'dRegions_Flags:|:%flagScripts%'
    - if <queue.exists[dRegions_saveCache]> {
      - queue q@dRegions_saveCache stop
      }
    - run locally saveCache delay:5s id:dRegions_saveCache


  event_PreProc_Config:
  # Reusable code block injected from events.
  # This pre-processor handles events in the global and world config files before
  # any regions even get a chance. World configs are processed before global.
  # This way worlds can deny events that global allows, but global has ultimate
  # control for denying events. Denying an event takes precedence over allowing.
  # Default is 'true' on most events for this reason.
  #
  # Events that take a block list are handled here as well. Blocklists can
  # operate in whitelist or blacklist modes.
  #
  # Blacklist mode.
  # When an event is set to 'false' and no blocks are specified in the
  # blocklist, it will always cancel the event. If there are blocks specified,
  # it will only cancel events involving those blocks listed.
  #
  # Whitelist mode.
  # When an event is set to 'true' and no blocks are specified in the blocklist,
  # it will always allow the event. If there are blocks specifed, it will only
  # allow events involving those blocks listed.
  #
    - define targetList '<yaml[dRegions_%world%_config].read[config.%readPath%-list]||li@>'
    - if <yaml[dRegions_%world%_config].read[config.%readPath%]||true> {
      - if !<def[targetList].is_empty> && %targetList% !contains %target% {
        - determine cancelled
        }
      }
      else {
      - if <def[targetList].is_empty> || %targetList% contains %target% {
        - determine cancelled
        }
      }

    - define targetList '<yaml[dRegions_global_config].read[config.%readPath%-list]||li@>'
    - if <yaml[dRegions_global_config].read[config.%readPath%]||true> {
      - if !<def[targetList].is_empty> && %targetList% !contains %target% {
        - determine cancelled
        }
      }
      else {
      - if <def[targetList].is_empty> || %targetList% contains %target% {
        - determine cancelled
        }
      }

  event_PreProc_Config-NoTarget:
    - if !<yaml[dRegions_%world%_config].read[config.%readPath%]||true> {
      - determine cancelled
      }

    - if !<yaml[dRegions_global_config].read[config.%readPath%]||true> {
      - determine cancelled
      }


  loadYaml:
  # Reloads the yaml files and generates default files if they don't exist.
  # Rewrites config files that do not match internal version number!
    - announce "<&b>dRegions<&co><&3> Loading system config files..." to_console
    - define world 'global'
    - define file 'config'
    - if !<server.has_file[dRegions/config.yml]> {
      - if <player.is[!=].to[null]||false> {
        - flag <player> ConfigFileGeneratorNotify:true
        - inject locally createConfigFile instantly
        - flag <player> ConfigFileGeneratorNotify:!
        - run s@dRegions_Msg 'def:<&7><&o>Created <&f><&o>%world%<&7><&o> config file!'
        }
        else {
        - inject locally createConfigFile
        }
      - announce "<&b>dRegions<&co> <&7><&o>Created <&f><&o>%world%<&7><&o> config file!" to_console
      }
    - if <yaml.list.contains[dRegions_global_config]> {
      - yaml unload 'id:dRegions_global_config'
      }
    - yaml 'load:dRegions/config.yml' 'id:dRegions_global_config'

    - if <yaml[dRegions_<def[world]>_config].read[config.version].is[!=].to[<s@dRegions_Configurations.yaml_key[config.version]>]||false> {
      - define isUpdate ''
      - if <player.is[!=].to[null]||false> {
        - flag <player> ConfigFileGeneratorNotify:true
        - inject locally createConfigFile
        - flag <player> ConfigFileGeneratorNotify:!
        - run s@dRegions_Msg 'def:<&7><&o>Updated <&f><&o>%world%<&7><&o> config file!'
        }
        else {
        - inject locally createConfigFile
        }
      - define isUpdate:!
      - announce "<&b>dRegions<&co> <&7><&o>Updated <&f><&o>%world%<&7><&o> config file!" to_console
      }

    - foreach <server.list_worlds.parse[name.to_lowercase]> {
      - define world '<def[value]>'
      - define file 'worlds/%world%/config'

      - if !<server.has_file[dRegions/%file%.yml]> {
        - if <player.is[!=].to[null]||false> {
          - flag <player> ConfigFileGeneratorNotify:true
          - inject locally createConfigFile
          - flag <player> ConfigFileGeneratorNotify:!
          - run s@dRegions_Msg 'def:<&7><&o>Created <&f><&o>%world%<&7><&o> config file!'
          }
          else {
          - inject locally createConfigFile
          }
        - announce "<&b>dRegions<&co> <&7><&o>Created <&f><&o>%world%<&7><&o> config file!" to_console
        }
      - if <yaml.list.contains[dRegions_%world%_config]> {
        - yaml unload 'id:dRegions_%world%_config'
        }
      - yaml 'load:dRegions/%file%.yml' 'id:dRegions_%world%_config'

      - if <yaml[dRegions_<def[world]>_config].read[config.version].is[!=].to[<s@dRegions_Configurations.yaml_key[config.version]>]||false> {
        - define isUpdate ''
        - if <player.is[!=].to[null]||false> {
          - flag <player> ConfigFileGeneratorNotify:true
          - inject locally createConfigFile
          - flag <player> ConfigFileGeneratorNotify:!
          - run s@dRegions_Msg 'def:<&7><&o>Updated <&f><&o>%world%<&7><&o> config file!'
          }
          else {
          - inject locally createConfigFile
          }
        - define isUpdate:!
        - announce "<&b>dRegions<&co> <&7><&o>Updated <&f><&o>%world%<&7><&o> config file!" to_console
        }

      - define file 'worlds/%world%/regions'
      - if !<server.has_file[dRegions/%file%.yml]> {
        - define region '__global__'
        - if <player.is[!=].to[null]||false> {
          - flag <player> ConfigFileGeneratorNotify:true
          - inject locally createRegionFile
          - flag <player> ConfigFileGeneratorNotify:!
          - run s@dRegions_Msg 'def:<&7><&o>Created <&f><&o>%world%<&7><&o> regions file!'
          }
          else {
          - inject locally createRegionFile
          }
        - announce "<&b>dRegions<&co> <&7><&o>Created <&f><&o>%world%<&7><&o> regions file!" to_console
        }
      - if <yaml.list.contains[dRegions_%world%_regions]> {
        - yaml unload 'id:dRegions_%world%_regions'
        }
      - yaml 'load:dRegions/%file%.yml' 'id:dRegions_%world%_regions'

      - define file 'worlds/%world%/inventories'
      - if !<server.has_file[dRegions/%file%.yml]> {
        - if <player.is[!=].to[null]||false> {
          - flag <player> ConfigFileGeneratorNotify:true
          - inject locally createInventoryFile
          - flag <player> ConfigFileGeneratorNotify:!
          - run s@dRegions_Msg 'def:<&7><&o>Created <&f><&o>%world%<&7><&o> regions file!'
          }
          else {
          - inject locally createInventoryFile
          }
        - announce "<&b>dRegions<&co> <&7><&o>Created <&f><&o>%world%<&7><&o> inventory file!" to_console
        }
      - if <yaml.list.contains[dRegions_%world%_inventories]> {
        - yaml unload 'id:dRegions_%world%_inventories'
        }
      - yaml 'load:dRegions/%file%.yml' 'id:dRegions_%world%_inventories'

      - define file 'worlds/%world%/cache'
      - if !<server.has_file[dRegions/%file%.yml]> {
        - if <player.is[!=].to[null]||false> {
          - flag <player> ConfigFileGeneratorNotify:true
          - inject locally createCacheFile
          - flag <player> ConfigFileGeneratorNotify:!
          - run s@dRegions_Msg 'def:<&7><&o>Created <&f><&o>%world%<&7><&o> cache file!'
          }
          else {
          - inject locally createCacheFile
          }
        - announce "<&b>dRegions<&co> <&7><&o>Created <&f><&o>%world%<&7><&o> cache file!" to_console
        }
      - if <yaml.list.contains[dRegions_%world%_cache]> {
        - yaml unload 'id:dRegions_%world%_cache'
        }
      - yaml 'load:dRegions/%file%.yml' 'id:dRegions_%world%_cache'
      }
    - announce "<&b>dRegions<&co><&a> System config files Loaded!" to_console


  reloadYaml:
  # A simpler reload
    - announce "<&b>dRegions<&co><&3> Reloading system config files..." to_console
    - run s@dRegions_Msg 'def:<&7><&o>Reloading system config files...'
    - if <yaml.list.contains[dRegions_global_config]> {
      - yaml unload 'id:dRegions_global_config'
      }
    - yaml 'load:dRegions/config.yml' 'id:dRegions_global_config'
    - foreach <server.list_worlds.parse[name.to_lowercase]> {
      - define world '<def[value]>'
      - if <yaml.list.contains[dRegions_%world%_config]> {
        - yaml unload 'id:dRegions_%world%_config'
        }
      - yaml 'load:dRegions/worlds/%world%/config.yml' 'id:dRegions_%world%_config'
      - if <yaml.list.contains[dRegions_%world%_regions]> {
        - yaml unload 'id:dRegions_%world%_regions'
        }
      - yaml 'load:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - if <yaml.list.contains[dRegions_%world%_inventories]> {
        - yaml unload 'id:dRegions_%world%_inventories'
        }
      - yaml 'load:dRegions/worlds/%world%/inventories.yml' 'id:dRegions_%world%_inventories'
      - if <yaml.list.contains[dRegions_%world%_cache]> {
        - yaml unload 'id:dRegions_%world%_cache'
        }
      - yaml 'load:dRegions/worlds/%world%/cache.yml' 'id:dRegions_%world%_cache'
      }
    - announce "<&b>dRegions<&co><&a> System config files Loaded!" to_console
    - run s@dRegions_Msg 'def:<&7><&o>System config files Loaded!'


  createConfigFile:
    - define readID 'dRegions_Configurations'
    - define writeID 'dRegions_%world%_config'
    - if !<yaml.list.contains[%readID%]> {
      - yaml fix_formatting 'load:<script.relative_filename>' 'id:%readID%'
      }
    - if !<yaml.list.contains[%readID%]> {
      - announce to_console "Loaded <script.relative_filename>"
      }
    - yaml create 'id:%writeID%'
    - define readPath '%readID%.config'
    - define writePath 'config'
    - if <def[isUpdate].exists||false> {
      - run s@ConfigFileGenerator def:%readID%|%writeID%|%readPath%|%writePath%|false|false|true instantly
      }
      else {
      - run s@ConfigFileGenerator def:%readID%|%writeID%|%readPath%|%writePath%|false|false|false instantly
      }
    - yaml unload 'id:%readID%'
    - yaml 'savefile:dRegions/%file%.yml' 'id:%writeID%'


  createRegionFile:
    - define readID 'dRegions_Configurations'
    - define writeID 'dRegions_%world%_regions'
    - if !<yaml.list.contains[%readID%]> {
      - yaml fix_formatting 'load:<script.relative_filename>' 'id:%readID%'
      }
    - yaml create 'id:%writeID%'
    - define readPath '%readID%.regions.__global__'
    - define writePath 'regions.%region%'
    - run s@ConfigFileGenerator def:%readID%|%writeID%|%readPath%|%writePath%|false|false|false instantly
    - yaml unload 'id:%readID%'
    - yaml 'savefile:dRegions/%file%.yml' 'id:%writeID%'


  createInventoryFile:
    - define readID 'dRegions_Configurations'
    - define writeID 'dRegions_%world%_inventories'
    - if !<yaml.list.contains[%readID%]> {
      - yaml fix_formatting 'load:<script.relative_filename>' 'id:%readID%'
      }
    - yaml create 'id:%writeID%'
    - define readPath '%readID%.inventories'
    - define writePath 'inventories'
    - run s@ConfigFileGenerator def:%readID%|%writeID%|%readPath%|%writePath%|false|false|false instantly
    - yaml unload 'id:%readID%'
    - yaml 'savefile:dRegions/%file%.yml' 'id:%writeID%'


  createCacheFile:
    - define readID 'dRegions_Configurations'
    - define writeID 'dRegions_%world%_cache'
    - if !<yaml.list.contains[%readID%]> {
      - yaml fix_formatting 'load:<script.relative_filename>' 'id:%readID%'
      }
    - yaml create 'id:%writeID%'
    - define readPath '%readID%.cache'
    - define writePath 'cache'
    - run s@ConfigFileGenerator def:%readID%|%writeID%|%readPath%|%writePath%|false|false|false instantly
    - yaml unload 'id:%readID%'
    - yaml 'savefile:dRegions/%file%.yml' 'id:%writeID%'


  createRegionEntry:
    - if !<yaml.list.contains[dRegions_%world%_regions]> {
      yaml 'load:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      }
    - yaml set 'regions.%name%.type:cuboid' 'id:dRegions_%world%_regions'
    - yaml set 'regions.%name%.min:<def[selectedCuboid].min.simple>' 'id:dRegions_%world%_regions'
    - yaml set 'regions.%name%.max:<def[selectedCuboid].max.simple>' 'id:dRegions_%world%_regions'
    - yaml set 'regions.%name%.priority:0' 'id:dRegions_%world%_regions'
    - yaml set 'regions.%name%.flags:|:' 'id:dRegions_%world%_regions'
    - yaml set 'regions.%name%.owners:|:' 'id:dRegions_%world%_regions'
    - foreach <def[ownerGroups]||li@> {
      - yaml set 'regions.%name%.owners.groups:->:%value%' 'id:dRegions_%world%_regions'
      }
    - foreach <def[ownerPlayers]||li@> {
      - yaml set 'regions.%name%.owners.players:->:%value%' 'id:dRegions_%world%_regions'
      }
    - yaml set 'regions.%name%.members:|:' 'id:dRegions_%world%_regions'
    - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
    - note cu@<def[selectedCuboid].min.simple>|<def[selectedCuboid].max.simple> 'as:dregions_%world%_%name%'

  clearCache:
    - ^define region %1%
    - ^define world %2%
    - ^define flag %3%
    - ^define type '<s@dRegions_Flag_%flag%.yaml_key[flag_type]>'
    - ^if %type% == list {
      - define type '<s@dRegions_Flag_%flag%.yaml_key[flag_parent].as_script.yaml_key[flag_type]>'
      - define flag '<s@dRegions_Flag_%flag%.yaml_key[flag_parent].after_last[_]>'
      }
    - ^define children '<yaml[dRegions_%world%_regions].read[regions.%region%.children]||li@>'

    - ^if li@boolean|state-withTarget contains %type% {
      - foreach <def[children].include[%region%]> {
        - yaml set 'cache.%type%.%value%.%flag%:!' 'id:dRegions_%world%_cache'
        }
      - yaml 'savefile:dRegions/worlds/%world%/cache.yml' 'id:dRegions_%world%_cache'
      }
      else if li@state-withGroup|state-withTarget-withGroup|state-withTargetString-withGroup contains %type% {
      - foreach <w@%world%.players> {
        - define player '%value%'
        - foreach <def[children].include[%region%]> {
          - flag %player% dRegions.cache.%world%.%value%.%flag%:!
          }
        }
      }

  saveCache:
    - while true {
      - wait 5m
      - foreach <server.list_worlds.parse[name.to_lowercase]> {
        - if !<yaml.list.contains[dRegions_%value%_cache]> {
          - yaml 'load:dRegions/worlds/%value%/cache.yml' 'id:dRegions_%value%_cache'
          }
        - yaml 'savefile:dRegions/worlds/%value%/cache.yml' 'id:dRegions_%value%_cache'
        }
      }

#
#  END Utility Subscripts
##################################################
#
#  Message format
#


dRegions_Msg:
  type: item
  speed: 0
  debug: false
  material: i@human_skull
  display name: "<&4>  [<&6>dRegions<&4>]"
  lore:
  - <&5>Click for Help
  script:
# JSON is broken in denizen. Just narrate for now.
#    - ^define text '<&4>[<&6>dRegions<&4>]'
#    - ^define hover '<&chr[007B]><i@dRegions_Msg.json><&chr[007D]>'
#    - ^define click '/dregions help'
#    - ^define button "text:'%text%',clickEvent:<&chr[007B]>action:run_command,value:'%click%'<&chr[007D]>,hoverEvent:<&chr[007B]>action:show_item,value:'%hover%'<&chr[007d]>"
#    - ^define spacer "text:'  '"
#    - ^define msg "text:'%1%'"
    - ^if <player.is_player||false> {
#      - execute as_server "tellraw <player.name> <&chr[007B]>text:'',extra:[<&chr[007B]>%button%<&chr[007D]>,<&chr[007B]>%spacer%<&chr[007D]>,<&chr[007B]>%msg%<&chr[007D]>]<&chr[007D]>"
      - narrate '<&4>[<&6>dRegions<&4>] %1%'
      }
      else {
      - announce to_console "%1%"
      }


################################################################################
#
#  dRegions Command Script Container
#
# This script covers all dRegions commands
#
#
#
#--------------------------------------
#
#  dRegions Command Script Basics
#
# The basic stuff required in a command script container
#
dRegions_Commands:
  type: command
  speed: 0
  debug: false
  name: dregions
  description: Denizen Regions Manager
  usage: /dregions
  aliases:
  - drg
  allowed help:
  - determine true

  commandArgs:
    help:
      usage: '/drg help <&lt>arg/<&ns><&gt>'
      permissions: []
    about:
      usage: '/drg about'
      permissions: []
    reload:
      usage: '/drg reload'
      permissions:
        - dregions.reload
    restart:
      usage: '/drg restart'
      permissions:
        - dregions.restart
    define:
      usage: '/drg define [ID] (g:group) (player)'
      permissions:
        - dregions.define
    redefine:
      usage: '/drg redefine [ID]'
      permissions:
        - dregions.redefine
        - dregions.redefine.own.*
        - dregions.redefine.own.%region%
        - dregions.redefine.member.*
        - dregions.redefine.member.%region%
    claim:
      usage: '/drg claim [ID]'
      permissions: []
    select:
      usage: '/drg select [ID] -w world'
      permissions: []
    info:
      usage: '/drg info [ID] -w world'
      permissions:
        - dregions.info
        - dregions.info.own.*
        - dregions.info.own.%region%
        - dregions.info.member.*
        - dregions.info.member.%region%
    addowner:
      usage: '/drg addowner [ID] g:group player -w world'
      permissions:
        - dregions.addowner
        - dregions.addowner.own.*
        - dregions.addowner.own.%region%
        - dregions.addowner.member.*
        - dregions.addowner.member.%region%
    removeowner:
      usage: '/drg removeowner [ID] g:group player -w world'
      permissions:
        - dregions.removeowner
        - dregions.removeowner.own.*
        - dregions.removeowner.own.%region%
        - dregions.removeowner.member.*
        - dregions.removeowner.member.%region%
    addmember:
      usage: '/drg addmember [ID] g:group player -w world'
      permissions:
        - dregions.addmember
        - dregions.addmember.own.*
        - dregions.addmember.own.%region%
        - dregions.addmember.member.*
        - dregions.addmember.member.%region%
    removemember:
      usage: '/drg removemember [ID] g:group player -w world'
      permissions:
        - dregions.removemember
        - dregions.removemember.own.*
        - dregions.removemember.own.%region%
        - dregions.removemember.member.*
        - dregions.removemember.member.%region%
    list:
      usage: '/drg list (page<&ns>) -h -r region -w world -p player'
      permissions:
        - dregions.list
        - dregions.list.own.*
        - dregions.list.own.%region%
        - dregions.list.member.*
        - dregions.list.member.%region%
    flag:
      usage: '/drg flag [ID] [flag] [value] -g group -w world'
      permissions:
        - dregions.flags.*
        - dregions.flags.<def[flag]>
        - dregions.flag
        - dregions.flag.flags.*
        - dregions.flag.flags.<def[flag]>
        - dregions.flag.own.*
        - dregions.flag.own.<def[region]>
        - dregions.flag.member.*
        - dregions.flag.member.<def[region]>
    setpriority:
      usage: '/drg setpriority [ID] [<&ns>]'
      permissions:
        - dregions.setpriority
        - dregions.setpriority.own.*
        - dregions.setpriority.own.%region%
        - dregions.setpriority.member.*
        - dregions.setpriority.member.%region%
    setparent:
      usage: '/drg setparent [ID] [parent]'
      permissions:
        - dregions.setparent
        - dregions.setparent.own.*
        - dregions.setparent.own.%region%
        - dregions.setparent.member.*
        - dregions.setparent.member.%region%
    teleport:
      usage: '/drg teleport [ID] -w world'
      permissions:
        - dregions.teleport
        - dregions.teleport.own.*
        - dregions.teleport.own.%region%
        - dregions.teleport.member.*
        - dregions.teleport.member.%region%
    remove:
      usage: '/drg remove [ID] -w world'
      permissions:
        - dregions.remove
        - dregions.remove.own.*
        - dregions.remove.own.%region%
        - dregions.remove.member.*
        - dregions.remove.member.%region%

  tab complete:
    - define args '<script.list_keys[commandArgs].alphanumeric.to_lowercase||li@>'
    - define arg '<c.args.get[1]||null>'
    - if <def[arg].is[==].to[null]>
      || !<def[args].contains[%arg%]> {
      - inject locally tab_arg_1
      }
      else {
      - inject locally tab_%arg%
      }
    - determine '<def[result]||li@>'

  script:
    - define command '<c.args.get[1].escaped||help>'
    - define args '<script.list_keys[commandArgs].alphanumeric.to_lowercase||li@>'
    - if !<def[args].contains[%command%]> {
      - inject locally help
      }
      else {
      - inject locally %command%
      }


#
#  END dRegions Command Script Basics
#--------------------------------------
#
#  dRegions Command TAB Completion
#
# Each of these subscripts handles TAB completion for the positional argument.
#
#
  tab_arg_1:
    # This Excludes args from the original args
    - foreach %args% {
      - if !<player.permission[dregions.%value%]||<player.is_op||false>> {
        - define args '<def[args].exclude[%value%]||%args%>'
        }
      }
    - if <def[args].is_empty||true> {
      - define result 'li@'
      }
      else {
      - define result '<def[args].filter[starts_with[%arg%]]||li@> '
      - if <def[result].is_empty||true> {
        - define result '%args%'
        }
      }

  tab_help:
    - define spaces '<c.raw_args.to_list.count[ ]||0>'
    - if <def[spaces].is[==].to[0]> {
      - define result 'help [command]'
      }
      else if <def[spaces].is[==].to[1]> {
      - define result 'li@'
      - foreach %args% {
        - if <player.permission[dregions.%value%]||<player.is_op||false>> {
          - define result '<def[result].include[%value%]||%result%>'
          }
          else {
          - foreach next
          }
        }
      - if <c.args.get[2].is[!=].to[null]||false> {
        - define result '<def[args].filter[starts_with[<c.args.get[2]>]]||li@>'
        - if <def[result].is_empty> {
          - foreach %args% {
            - if <player.permission[dregions.%value%]||<player.is_op||false>> {
              - define result '<def[result].include[%value%]||%result%>'
              }
              else {
              - foreach next
              }
            }
          }
        }
      }

  tab_about:
    - define result 'li@'

  tab_reload:
    - define result 'li@'

  tab_restart:
    - define result 'li@'

  tab_define:
  # /drg define [ID] (g:group) (player)
    - if <player.permission[dregions.define]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - if <def[spaces].is[==].to[0]> {
        - define result 'define [ID]'
        }

        else if <def[spaces].is[==].to[1]> {
        - if <c.args.get[2].is[==].to[null]||true> {
          - define result '[ID] (g:group) (player)'
          }
          else {
          - define result '<c.args.get[2]> (g:group) (player)'
          }
        }

        else if <def[spaces].is[OR_MORE].than[2]> {
        - define owners '<c.args.remove[1|2]||li@>'
        - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
          - define owners '<def[owners].remove[<def[owners].find[-w]>|<def[owners].find[-w].add[1].as_int>]||li@>'
          }
        - define owner '<def[owners].last||li@>'
        - if <def[owner].starts_with[g:]||false> {
          - define group '<def[owner].replace[g:]>'
          - define groups '<server.list_permission_groups.filter[starts_with[%group%]]||li@>'
          - if <def[groups].is_empty> {
            - define groups '<server.list_permission_groups||li@>'
            }
          - define result '<def[groups].parse[replace[regex:^].with[g:]]>'
          }
          else {
          - define result '<server.match_player[%owner%].name||null>'
          - if <def[result].is[==].to[null]||true> {
            - define result '<server.list_online_players.parse[name]>'
            }
          }
        }
        else {
        - define result 'li@'
        }
      }
      else {
      - define result 'li@'
      }

  tab_redefine:
  # /drg redefine [ID]
    - if <player.permission[dregions.redefine]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
      - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
      - if !<player.permission[dregions.admin]||<player.is_op||true>> {
        - foreach %regions% {
          - if <proc[dRegions_IsOwner].context[%value%|%world%|<player>].not> {
            - define regions '<def[regions].exclude[%value%]||%regions%>'
            }
          }
        }
      - if <def[spaces].is[==].to[0]> {
        - define result '<def[regions].parse[replace[regex:^].with[redefine ]]>'
        }
        else if <def[spaces].is[==].to[1]> {
        - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||li@>'
        - if <def[result].is_empty||true> {
          - define result '%regions%'
          }
        }
        else {
        - define result 'li@'
        }
      }
      else {
      - define result 'li@'
      }

  tab_claim:
    - if <player.permission[dregions.claim]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
      - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
      - if !<player.permission[dregions.admin]||<player.is_op||false>> {
        - foreach %regions% {
          - if <proc[dRegions_IsOwner].context[%value%|%world%|<player>].not> {
            - define regions '<def[regions].exclude[%value%]||%regions%>'
            }
          }
        }
      - if <def[spaces].is[==].to[0]> {
        - define result '<def[regions].parse[replace[regex:^].with[claim ]]>'
        }
        else if <def[spaces].is[==].to[1]> {
        - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||li@>'
        - if <def[result].is_empty||true> {
          - define result '%regions%'
          }
        }
        else {
        - define result 'li@'
        }
      }
      else {
      - define result 'li@'
      }

  tab_select:
  # /drg select [ID] -w world
    - if <player.permission[dregions.select]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
      - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
      - if !<player.permission[dregions.admin]||<player.is_op||false>> {
        - foreach %regions% {
          - if <proc[dRegions_IsOwner].context[%value%|%world%|<player>].not> {
            - define regions '<def[regions].exclude[%value%]||%regions%>'
            }
          }
        }
      - if <def[spaces].is[==].to[0]> {
        - define result '<def[regions].parse[replace[regex:^].with[select ]]>'
        }
        else if <def[spaces].is[==].to[1]> {
        - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped||null>]]||li@>'
        - if <def[result].is_empty||true> {
          - define result '%regions%'
          }
        }
        else {
        - define result 'li@'
        }
      }
      else {
      - define result 'li@'
      }

  tab_info:
  # /drg info [ID] -w world
    - if <player.permission[dregions.info]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
      - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
      - if !<player.permission[dregions.admin]||<player.is_op||false>> {
        - foreach %regions% {
          - if <proc[dRegions_IsOwner].context[%value%|%world%|<player>].not> {
            - define regions '<def[regions].exclude[%value%]||%regions%>'
            }
          }
        }
      - if <def[spaces].is[==].to[0]> {
        - define result '<def[regions].parse[replace[regex:^].with[info ]]>'
        }
        else if <def[spaces].is[==].to[1]> {
        - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped||null>]]||li@>'
        - if <def[result].is_empty||true> {
          - define result '%regions%'
          }
        }
        else {
        - define result 'li@'
        }
      }
      else {
      - define result 'li@'
      }

  tab_addowner:
  # /drg addowner [ID] g:group player -w world
    - if <player.permission[dregions.addowner]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
      - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
      - if !<player.permission[dregions.admin]||<player.is_op||false>> {
        - foreach %regions% {
          - if <proc[dRegions_IsOwner].context[%value%|%world%|<player>].not> {
            - define regions '<def[regions].exclude[%value%]||%regions%>'
            }
          }
        }
      - if <def[spaces].is[==].to[0]> {
        - define result '<def[regions].parse[replace[regex:^].with[addowner ]]>'
        }
        else if <def[spaces].is[==].to[1]> {
        - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped||null>]]||li@>'
        - if <def[result].is_empty||true> {
          - define result '%regions%'
          }
        }
        else if <def[spaces].is[OR_MORE].than[2]> {
        - define owners '<c.args.remove[1|2]||li@>'
        - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
          - define owners '<def[owners].remove[<def[owners].find[-w]>|<def[owners].find[-w].add[1].as_int>]||li@>'
          }
        - define owner '<def[owners].last||li@>'
        - if <def[owner].starts_with[g:]||false> {
          - define group '<def[owner].replace[g:]>'
          - define groups '<server.list_permission_groups.filter[starts_with[%group%]]||li@>'
          - if <def[groups].is_empty> {
            - define groups '<server.list_permission_groups.alphanumeric||li@>'
            }
          - define result '<def[groups].parse[replace[regex:^].with[g:]]>'
          }
          else {
          - define result '<server.match_player[%owner%].name||null>'
          - if <def[result].is[==].to[null]||true> {
            - define result '<server.list_online_players.parse[name].alphanumeric>'
            }
          }
        }
        else {
        - define result 'li@'
        }
      }
      else {
      - define result 'li@'
      }

  tab_removeowner:
  # /drg removeowner [ID] g:group player -w world
    - if <player.permission[dregions.removeowner]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
      - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
      - if !<player.permission[dregions.admin]||<player.is_op||false>> {
        - foreach %regions% {
          - if <proc[dRegions_IsOwner].context[%value%|%world%|<player>].not> {
            - define regions '<def[regions].exclude[%value%]||%regions%>'
            }
          }
        }
      - if <def[spaces].is[==].to[0]> {
        - define result '<def[regions].parse[replace[regex:^].with[removeowner ]]>'
        }
        else if <def[spaces].is[==].to[1]> {
        - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||li@>'
        - if <def[result].is_empty||true> {
          - define result '%regions%'
          }
        }
        else if <def[spaces].is[OR_MORE].than[2]> {
        - define owners '<c.args.remove[1|2]||li@>'
        - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
          - define owners '<def[owners].remove[<def[owners].find[-w]>|<def[owners].find[-w].add[1].as_int>]||li@>'
          }
        - define owner '<def[owners].last||li@>'
        - if <def[owner].starts_with[g:]||false> {
          - define group '<def[owner].replace[g:]>'
          - define groups '<server.list_permission_groups.filter[starts_with[%group%]]||li@>'
          - if <def[groups].is_empty> {
            - define groups '<server.list_permission_groups.alphanumeric||li@>'
            }
          - define result '<def[groups].parse[replace[regex:^].with[g:]]>'
          }
          else {
          - define result '<server.match_player[%owner%].name||null>'
          - if <def[result].is[==].to[null]||true> {
            - define result '<server.list_online_players.parse[name].alphanumeric>'
            }
          }
        }
        else {
        - define result 'li@'
        }
      }
      else {
      - define result 'li@'
      }

  tab_addmember:
  # /drg addmember [ID] g:group player -w world
    - if <player.permission[dregions.addmember]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
      - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
      - if !<player.permission[dregions.admin]||<player.is_op||false>> {
        - foreach %regions% {
          - if <proc[dRegions_IsOwner].context[%value%|%world%|<player>].not> {
            - define regions '<def[regions].exclude[%value%]||%regions%>'
            }
          }
        }
      - if <def[spaces].is[==].to[0]> {
        - define result '<def[regions].parse[replace[regex:^].with[addmember ]]>'
        }
        else if <def[spaces].is[==].to[1]> {
        - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||li@>'
        - if <def[result].is_empty||true> {
          - define result '%regions%'
          }
        }
        else if <def[spaces].is[OR_MORE].than[2]> {
        - define members '<c.args.remove[1|2]||li@>'
        - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
          - define members '<def[members].remove[<def[members].find[-w]>|<def[members].find[-w].add[1].as_int>]||li@>'
          }
        - define member '<def[members].last||li@>'
        - if <def[member].starts_with[g:]||false> {
          - define group '<def[member].replace[g:]>'
          - define groups '<server.list_permission_groups.filter[starts_with[%group%]]||li@>'
          - if <def[groups].is_empty> {
            - define groups '<server.list_permission_groups.alphanumeric||li@>'
            }
          - define result '<def[groups].parse[replace[regex:^].with[g:]]>'
          }
          else {
          - define result '<server.match_player[%member%].name||null>'
          - if <def[result].is[==].to[null]||true> {
            - define result '<server.list_online_players.parse[name].alphanumeric>'
            }
          }
        }
        else {
        - define result 'li@'
        }
      }
      else {
      - define result 'li@'
      }

  tab_removemember:
  # /drg removemember [ID] g:group player -w world
    - if <player.permission[dregions.removemember]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
      - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
      - if !<player.permission[dregions.admin]||<player.is_op||false>> {
        - foreach %regions% {
          - if <proc[dRegions_IsOwner].context[%value%|%world%|<player>].not> {
            - define regions '<def[regions].exclude[%value%]||%regions%>'
            }
          }
        }
      - if <def[spaces].is[==].to[0]> {
        - define result '<def[regions].parse[replace[regex:^].with[removemember ]]>'
        }
        else if <def[spaces].is[==].to[1]> {
        - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||li@>'
        - if <def[result].is_empty||true> {
          - define result '%regions%'
          }
        }
        else if <def[spaces].is[OR_MORE].than[2]> {
        - define members '<c.args.remove[1|2]||li@>'
        - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
          - define members '<def[members].remove[<def[members].find[-w]>|<def[members].find[-w].add[1].as_int>]||li@>'
          }
        - define member '<def[members].last||li@>'
        - if <def[member].starts_with[g:]||false> {
          - define group '<def[member].replace[g:]>'
          - define groups '<server.list_permission_groups.filter[starts_with[%group%]]||li@>'
          - if <def[groups].is_empty> {
            - define groups '<server.list_permission_groups.alphanumeric||li@>'
            }
          - define result '<def[groups].parse[replace[regex:^].with[g:]]>'
          }
          else {
          - define result '<server.match_player[%member%].name||null>'
          - if <def[result].is[==].to[null]||true> {
            - define result '<server.list_online_players.parse[name].alphanumeric>'
            }
          }
        }
        else {
        - define result 'li@'
        }
      }
      else {
      - define result 'li@'
      }

  tab_list:
    - define result 'li@'

  tab_flag:
  # TODO
  # /drg flag [ID] [flag] [value] -g group -w world
    - if <player.permission[dregions.flag]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - if <def[spaces].is[==].to[0]> {
        - define result 'flag [ID]'
        }
        else if <def[spaces].is[==].to[1]> {
        - if <c.args.get[2].is[==].to[null]||true> {
          - define result '[ID]'
          }
          else if <c.args.get[2].is[==].to[-w]||false> {
          - define result '<server.list_worlds.parse[name.to_lowercase].parse[replace[regex:^].with[-w ]]>'
          }
          else if <context.server.not> {
          - define regions '<yaml[dRegions_<player.world.name.to_lowercase>_regions].list_keys[regions].alphanumeric||li@>'
          - if !<player.permission[dregions.admin]||<player.is_op||false>> {
            - foreach %regions% {
              - if <proc[dRegions_IsOwner].context[%value%|<player.world.name.to_lowercase>|<player>].not> {
                - define regions '<def[regions].exclude[%value%]||%regions%>'
                }
              }
            }
          - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||li@>'
          - if <def[result].is_empty||true> {
            - define result '%regions%'
            }
          }
          else {
          - define result 'li@'
          }
        }
        else if <def[spaces].is[==].to[2]> {
        - if <c.args.get[2].is[==].to[-w]||false> {
          - if <c.args.get[3].is[!=].to[null]||false> {
            - define result '<server.list_worlds.parse[name.to_lowercase].filter[starts_with[<c.args.get[3].escaped>]]||li@>'
            }
          - if <def[result].is_empty||true> {
            - define result '<server.list_worlds.parse[name.to_lowercase]||li@>'
            }
          }
          else if <c.args.get[2].is[!=].to[null]||false> {
          - define allFlags '<server.flag[dRegions_Flags].parse[name.split[_].get[3].to_lowercase].alphanumeric||li@>'
          - if <c.args.get[3].is[==].to[-w]||false> {
            - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
            - if <c.args.get[3].is[!=].to[null]||false> {
              - define result '<server.list_worlds.parse[name.to_lowercase].filter[starts_with[<c.args.get[3].escaped>]]||li@>'
              }
            - if <def[result].is_empty||true> {
              - define result '<server.list_worlds.parse[name.to_lowercase].parse[replace[regex:^].with[-w ]]||li@>'
              }
            }
            else if <c.args.get[3].is[!=].to[null]||false> {
            - define result '<def[allFlags].filter[starts_with[<c.args.get[3].escaped>]]||li@>'
            - if <def[result].is_empty||true> {
              - define result '<def[allFlags]||li@>'
              }
            }
            else {
            - if <def[result].is_empty||true> {
              - define result '<def[allFlags]||li@>'
              }
            }
          }
        }
        else if <def[spaces].is[==].to[3]> {
        - if <c.args.get[2].is[==].to[-w]||false> {
          - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
          - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].alphanumeric||li@>'
          - if <c.args.get[4].is[!=].to[null]||false> {
            - define result '<def[regions].filter[starts_with[<c.args.get[4].escaped>]]||li@>'
            }
          - if <def[result].is_empty||true> {
            - define result '<def[regions]||li@>'
            }
          }
          else if <c.args.get[3].is[==].to[-w]||false> {
          - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
          - if <c.args.get[4].is[!=].to[null]||false> {
            - define result '<server.list_worlds.parse[name.to_lowercase].filter[starts_with[<c.args.get[3].escaped>]].parse[replace[regex:^].with[-w ]]||li@>'
            }
          - if <def[result].is_empty||true> {
            - define result '<server.list_worlds.parse[name.to_lowercase]||li@>'
            }
          }
          else if <c.args.get[4].is[==].to[-w]||false> {
          - define result '<server.list_worlds.parse[name.to_lowercase].parse[replace[regex:^].with[-w ]]||li@>'
          }
        }
        else if <def[spaces].is[==].to[4]> {
        - if <c.args.get[4].is[==].to[-w]||false> {
          - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
          - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].alphanumeric||li@>'
          - if <c.args.get[5].is[!=].to[null]||false> {
            - define result '<server.list_worlds.parse[name.to_lowercase].filter[starts_with[<c.args.get[5].escaped>]]||li@>'
            }
          - if <def[result].is_empty||true> {
            - define result '<server.list_worlds.parse[name.to_lowercase]||li@>'
            }
          }
          else {
          - define allFlags '<server.flag[dRegions_Flags].parse[name.split[_].get[3].to_lowercase].alphanumeric||li@>'
          - if <c.args.get[5].is[!=].to[null]||false> {
            - define result '<def[allFlags].filter[starts_with[<c.args.get[5].escaped>]]||li@>'
            }
          - if <def[result].is_empty||true> {
            - define result '<def[allFlags]||li@>'
            }
          }
        }
      }
      else {
      - define result 'li@'
      }

  tab_setpriority:
  # /drg remove [ID] -w world
    - if <player.permission[dregions.setpriority]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - if <def[spaces].is[==].to[0]> {
        - define result 'setpriority [ID]'
        }
        else if <def[spaces].is[==].to[1]> {
        - if <c.args.get[2].is[==].to[null]||true> {
          - define result '[ID]'
          }
          else if <c.args.get[2].is[==].to[-w]||false> {
          - define result '<server.list_worlds.parse[name.to_lowercase].parse[replace[regex:^].with[-w ]]>'
          }
          else if <context.server.not> {
          - define regions '<yaml[dRegions_<player.world.name.to_lowercase>_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
          - if !<player.permission[dregions.admin]||<player.is_op||false>> {
            - foreach %regions% {
              - if <proc[dRegions_IsOwner].context[%value%|<player.world.name.to_lowercase>|<player>].not> {
                - define regions '<def[regions].exclude[%value%]||%regions%>'
                }
              }
            - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||li@>'
            }
            else {
            - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||%regions%>'
            - if <def[result].is_empty> {
              - define result '%regions%'
              }
            }
          }
          else {
          - define result 'li@'
          }
        }
        else if <def[spaces].is[==].to[2]> {
        - if <c.args.get[2].is[==].to[-w]||false> {
          - if <c.args.get[3].is[!=].to[null]||false> {
            - define result '<server.list_worlds.parse[name.to_lowercase].filter[starts_with[<c.args.get[3].escaped>]]||li@>'
            }
          - if <def[result].is_empty||true> {
            - define result '<server.list_worlds.parse[name.to_lowercase]||li@>'
            }
          }
          else {
          - if <c.args.get[3].is[MATCHES].to[number]> {
            - define result '<c.args.get[3]>'
            }
            else if <c.args.get[3].is[==].to[-w]||false> {
            - define result '<server.list_worlds.parse[name.to_lowercase].parse[replace[regex:^].with[-w ]]||li@>'
            }
            else {
            - define result '<&ns>'
            }
          }
        }
        else if <def[spaces].is[==].to[3]> {
        - if <c.args.get[2].is[==].to[-w]||false> {
          - if <c.args.get[4].is[!=].to[null]||false> {
            - define regions '<yaml[dRegions_<c.args.get[3].escaped>_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
            - define result '<def[regions].filter[starts_with[<c.args.get[4].escaped>]]||li@>'
            - if <def[result].is_empty||true> {
              - define result '%regions%'
              }
            }
            else {
            - define result '<yaml[dRegions_<c.args.get[3].escaped>_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
            }
          }
          else if <c.args.get[3].is[==].to[-w]||false> {
          - define result '<server.list_worlds.parse[name.to_lowercase]||li@>'
          }
          else {
          - if <c.args.get[4].is[!=].to[null]||false> {
            - define result '<server.list_worlds.parse[name.to_lowercase].filter[starts_with[<c.args.get[4].escaped>]]||li@>'
            }
            else {
            - define result '<server.list_worlds.parse[name].parse[replace[regex:^].with[-w ]]||li@>'
            }
          - if <def[result].is_empty||true> {
            - define result '<server.list_worlds.parse[name.to_lowercase].parse[replace[regex:^].with[-w ]]||li@>'
            }
          }
        }
        else if <def[spaces].is[==].to[4]> {
        - if <c.args.get[2].is[==].to[-w]||false>
          || <c.args.get[3].is[==].to[-w]||false> {
          - if <c.args.get[5].is[MATCHES].to[number]> {
            - define result '<c.args.get[5]>'
            }
            else {
            - define result '<&ns>'
            }
          }
          else if <c.args.get[4].is[==].to[-w]> {
          - define result '<server.list_worlds.parse[name.to_lowercase]||li@>'
          }
        }
        else {
        - define result 'li@'
        }
      }
      else {
      - define result 'li@'
      }

  tab_setparent:
  # TODO
    - define result 'li@'

  tab_teleport:
  # TODO
  # /drg teleport [ID] -w world
    - define result 'li@'

  tab_remove:
  # /drg remove [ID] -w world
    - if <player.permission[dregions.remove]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - if <def[spaces].is[==].to[0]> {
        - define result 'remove [ID] -w world'
        }
        else if <def[spaces].is[==].to[1]> {
        - if <c.args.get[2].is[==].to[null]||true> {
          - define result '[ID]'
          }
          else if <c.args.get[2].is[==].to[-w]||false> {
          - define result '<server.list_worlds.parse[name.to_lowercase].parse[replace[regex:^].with[-w ]]>'
          }
          else if <context.server.not> {
          - define regions '<yaml[dRegions_<player.world.name.to_lowercase>_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
          - if !<player.permission[dregions.admin]||<player.is_op||false>> {
            - foreach %regions% {
              - if <proc[dRegions_IsOwner].context[%value%|<player.world.name.to_lowercase>|<player>].not> {
                - define regions '<def[regions].exclude[%value%]||%regions%>'
                }
              }
            }
          - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||li@>'
          - if <def[result].is_empty||true> {
            - define result '%regions%'
            }
          }
          else {
          - define result 'li@'
          }
        }
        else if <def[spaces].is[==].to[2]> {
        - if <c.args.get[2].is[==].to[-w]||false> {
          - if <c.args.get[3].is[!=].to[null]||false> {
            - define result '<server.list_worlds.parse[name.to_lowercase].filter[starts_with[<c.args.get[3].escaped>]]||li@>'
            }
          - if <def[result].is_empty||true> {
            - define result '<server.list_worlds.parse[name.to_lowercase]||li@>'
            }
          }
          else {
          - define result '<server.list_worlds.parse[name.to_lowercase].parse[replace[regex:^].with[-w ]]>'
          }
        }
        else if <def[spaces].is[==].to[3]> {
        - if <c.args.get[2].is[==].to[-w]||false> {
          - if <c.args.get[4].is[!=].to[null]||false> {
            - define regions '<yaml[dRegions_<c.args.get[3].escaped>_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
            - define result '<def[regions].filter[starts_with[<c.args.get[4].escaped>]]||li@>'
            - if <def[result].is_empty||true> {
              - define result '%regions%'
              }
            }
            else {
            - define result '<yaml[dRegions_<c.args.get[3].escaped>_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
            }
          }
          else {
          - if <c.args.get[4].is[!=].to[null]||false> {
            - define result '<server.list_worlds.parse[name.to_lowercase].filter[starts_with[<c.args.get[4].escaped>]]||li@>'
            }
            else {
            - define result '<server.list_worlds.parse[name.to_lowercase]||li@>'
            }
          - if <def[result].is_empty||true> {
            - define result '<server.list_worlds.parse[name.to_lowercase]||li@>'
            }
          }
        }
        else {
        - define result 'li@'
        }
      }
      else {
      - define result 'li@'
      }


#
#  END dRegions Command TAB Completion
#--------------------------------------
#
#  dRegions Command Arguments
#
# Each of these subscripts is an argument for the root command.
#
  help:
    - define arg '<c.args.get[2].escaped||null>'
    - if <def[args].contains[%arg%]||false> {
      - run s@dRegions_Msg 'def:<script.yaml_key[commandArgs.%arg%.usage]||No help for you!>'
      - queue clear
      }
    - if <player.permission[dRegions.admin]||<player.is_op||<context.server||false>>> {
      - inject locally msgsHelpAdmin
      }
      else {
      - inject locally msgsHelpUser
      }
    - inject locally msgsFooter
    - queue clear

  about:
    - inject locally msgsHelpUser
    - inject locally msgsFooter
    - queue clear

  reload:
    - if !<player.permission[dRegions.reload]||<player.is_op||<context.server||false>>> {
      - inject locally help
      - queue clear
      }
    - inject s@dRegions p:reloadYaml instantly
#    - run s@dRegions_Msg 'def:<&7><&o>System files loaded!'

  restart:
    - if !<player.permission[dRegions.restart]||<player.is_op||<context.server||false>>> {
      - inject locally help
      - queue clear
      }
    - run s@dRegions p:start instantly


  define:
  # /drg define [ID] (g:group) (player)
    - inject locally prerun instantly
    # Check for existing region
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]||true>'
    - if <def[exists].is[==].to[orphan]> {
      - run s@dRegions_Msg 'def:<&c>There is an orphaned region by this name!'
      - run s@dRegions_Msg 'def:<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists]> {
      - run s@dRegions_Msg 'def:<&c>There is already a region by this name!'
      - queue clear
      }
    # Check for overlapping regions
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_RegionOverlaps].context[<def[selectedCuboid].separated_by[/]>|%world%|<player>]> {
        - run s@dRegions_Msg 'def:<&c>Region selection contains unowned regions!'
        - queue clear
        }
      }
    # Parse any declared owners
    - define owners '<c.args.remove[1|2].replace[:].with[;]||li@>'
    - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
      - define owners '<def[owners].remove[<def[owners].find[-w]>|<def[owners].find[-w].add[1].as_int>]||li@>'
      }
    - define ownerGroups li@
    - define ownerPlayers li@
    - foreach %owners% {
      - if <def[value].starts_with[g;]||false> {
        - define ownerGroups '<def[ownerGroups].include[<def[value].replace[g;]>]||%ownerGroups%>'
        }
        else {
        - if !<def[value].as_player.is[!=].to[null]||false> {
          - foreach next
          }
        - define ownerPlayers '<def[ownerPlayers].include[<def[value].as_player.uuid>]||%ownerPlayers%>'
        }
      }
    # Automatically add the player that defined the region as the owner
    - if <yaml[dregions_global_config].read[config.regions.ownerOnDefine].is[==].to[true]||false> {
      - if <def[ownerPlayers].contains[<player.uuid>].not||false> {
        - define ownerPlayers '<def[ownerPlayers].include[<player.uuid>]||%ownerPlayers%>'
        }
      }
    # Create the region
    - inject s@dRegions p:createRegionEntry instantly
    - run s@dRegions_Msg 'def:<&7><&o>Created %name% in %world%'

  redefine:
  # /drg redefine [ID]
    - inject locally prerun instantly
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run s@dRegions_Msg 'def:<&c>There is an orphaned region by this name!'
      - run s@dRegions_Msg 'def:<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists].not> {
      - run s@dRegions_Msg 'def:<&c>There is no region by this name!'
      - queue clear
      }
    # Don't redefine global type regions
    - if <yaml[dRegions_%world%_regions].read[regions.%name%.type].is[==].to[global]||false> {
      - run s@dRegions_Msg 'def:<&c>You can not redefine global regions!'
      - queue clear
      }
    # Check if is owner
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run s@dRegions_Msg 'def:<&c>You are not an owner of this region!'
        - queue clear
        }
      }
    # Check for overlapping regions
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_RegionOverlaps].context[<def[selectedCuboid].separated_by[/]>|%world%|<player>]> {
        - run s@dRegions_Msg 'def:<&c>Region selection contains unowned regions!'
        - queue clear
        }
      }
    # Update the region
    - yaml set 'regions.%name%.min:<def[selectedCuboid].min.simple>' 'id:dRegions_%world%_regions'
    - yaml set 'regions.%name%.max:<def[selectedCuboid].max.simple>' 'id:dRegions_%world%_regions'
    - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
    - note cu@<def[selectedCuboid].min.simple>|<def[selectedCuboid].max.simple> 'as:dregions_%world%_%name%'
    - run s@dRegions_Msg 'def:<&f><&o>%name%<&7><&o> updated to selection'

  claim:
  # /drg claim [ID]
    - inject locally prerun instantly
    # Check Global region limits
    - define globalRegionLimit '<yaml[dregions_global_config].read[config.regions.claim.max-region-count-per-player.default]||0>'
    - if <def[globalRegionLimit].is[MORE].than[0]> {
      - define playerGlobalRegions 'li@'
      - foreach <server.list_worlds.parse[name.to_lowercase]> {
        - define thisWorld '%value%'
        - foreach '<yaml[dRegions_%thisWorld%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>' {
          - define region '%value%'
          - if <proc[dRegions_IsOwner].context[<def[region]>|<def[thisWorld]>|<player>]||false> {
            - define playerGlobalRegions '<def[playerGlobalRegions].include[<def[region]>]||<def[playerGlobalRegions]>>'
            }
          }
        }
      - if <def[playerGlobalRegions].size.is[OR_MORE].than[%globalRegionLimit%]> {
        - run s@dRegions_Msg 'def:<&c>You already have <def[playerGlobalRegions].size> total regions!'
        - if !<player.permission[dRegions.admin]||<player.is_op||false>> {
          - queue clear
          }
        - run s@dRegions_Msg 'def:<&c>But you are an admin so it is ok!'
        }
      }
    # Check World region limits
    - define worldRegionLimit '<yaml[dregions_%world%_config].read[config.regions.claim.max-region-count-per-player.default]||0>'
    - if <def[worldRegionLimit].is[MORE].than[0]> {
      - define playerWorldRegions 'li@'
      - foreach '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>' {
        - define region '%value%'
        - if <proc[dRegions_IsOwner].context[<def[region]>|<def[world]>|<player>]||false> {
          - define playerWorldRegions '<def[playerWorldRegions].include[<def[region]>]||<def[playerWorldRegions]>>'
          }
        }
      - if <def[playerWorldRegions].size.is[OR_MORE].than[%worldRegionLimit%]> {
        - run s@dRegions_Msg 'def:<&c>You already have <def[playerWorldRegions].size> regions in this world!'
        - if !<player.permission[dRegions.admin]||<player.is_op||false>> {
          - queue clear
          }
        - run s@dRegions_Msg 'def:<&c>But you are an admin so it is ok!'
        }
      }
    # Check selection volume
    - define globalClaimVol '<yaml[dregions_global_config].read[config.regions.claim.max-volume]||0>'
    - inject s@dWE_Commands p:selection_Size instantly
    - if <def[globalClaimVol].is[MORE].than[0]> {
      - if <def[size].is[MORE].than[%globalClaimVol%]> {
        - run s@dRegions_Msg 'def:<&c>Your selection exceeds the global limit!'
        - run s@dRegions_Msg 'def:<&7><&o>Selected <&8>(<&7><&o>%size%<&8>) <&7><&o>Limit <&8>(<&7><&o>%globalClaimVol%<&8>) <&7><&o>Over <&8>(<&7><&o><def[size].sub[%globalClaimVol%].as_int><&8>)'
        - if !<player.permission[dRegions.admin]||<player.is_op||false>> {
          - queue clear
          }
        - run s@dRegions_Msg 'def:<&c>But you are an admin so it is ok!'
        }
      }
    - define worldClaimVol '<yaml[dregions_%world%_config].read[config.regions.claim.max-volume]||0>'
    - if <def[worldClaimVol].is[MORE].than[0]> {
      - if <def[size].is[MORE].than[%worldClaimVol%]> {
        - run s@dRegions_Msg 'def:<&c>Your selection exceeds the world limit!'
        - run s@dRegions_Msg 'def:<&7><&o>Selected <&8>(<&7><&o>%size%<&8>) <&7><&o>Limit <&8>(<&7><&o>%worldClaimVol%<&8>) <&7><&o>Over <&8>(<&7><&o><def[size].sub[%worldClaimVol%].as_int><&8>)'
        - if !<player.permission[dRegions.admin]||<player.is_op||false>> {
          - queue clear
          }
        - run s@dRegions_Msg 'def:<&c>But you are an admin so it is ok!'
        }
      }
    # Check inside existing/owned region
    - if '<yaml[dregions_global_config].read[config.regions.claim.only-inside-existing-regions]||false>' {
      - if <def[playerWorldRegions].exists.not> {
        - define playerWorldRegions 'li@'
        - foreach '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>' {
          - define region '%value%'
          - if <proc[dRegions_IsOwner].context[<def[region]>|<def[world]>|<player>]||false> {
            - define playerWorldRegions '<def[playerWorldRegions].include[<def[region]>]||<def[playerWorldRegions]>>'
            }
          }
        }
      - define cuboids '<def[playerWorldRegions].parse[replace[regex:^].with[cu@dregions_%world%_]].filter[as_cuboid.is[!=].to[null]||false]||li@>'
      - foreach %cuboids% {
        - if <def[pos1].as_location.is_within[%value%]> && <def[pos2].as_location.is_within[%value%]> {
          - define isWithin ''
          - foreach stop
          }
        }
      - if <def[isWithin].exists.not> {
        - run s@dRegions_Msg 'def:<&c>You may only claim regions within land you own'
        - if !<player.permission[dRegions.admin]||<player.is_op||false>> {
          - queue clear
          }
        - run s@dRegions_Msg 'def:<&c>But you are an admin so it is ok!'
        }
      }
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run s@dRegions_Msg 'def:<&c>There is an orphaned region by this name!'
      - run s@dRegions_Msg 'def:<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists]> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run s@dRegions_Msg 'def:<&c>You are not an owner of this region!'
        - queue clear
        }
      - if <yaml[dRegions_%world%_regions].read[regions.%name%.type].is[==].to[global]||false> {
        - run s@dRegions_Msg 'def:<&c>You can not redefine global regions!'
        - queue clear
        }
      - run s@dRegions_Msg 'def:<&c>Region already exists!'
      - run s@dRegions_Msg 'def:<&7>You must want to update the region'
      - define update ''
      }
    # Check for overlapping regions
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_RegionOverlaps].context[<def[selectedCuboid].separated_by[/]>|%world%|<player>]> {
        - run s@dRegions_Msg 'def:<&c>Region selection contains unowned regions!'
        - if !<player.permission[dRegions.admin]||<player.is_op||false>> {
          - queue clear
          }
        - run s@dRegions_Msg 'def:<&c>But you are an admin so it is ok!'
        }
      }
    # Update the region
    - if <def[update].exists||false> {
      - yaml set 'regions.%name%.min:<def[selectedCuboid].min.simple>' 'id:dRegions_%world%_regions'
      - yaml set 'regions.%name%.max:<def[selectedCuboid].max.simple>' 'id:dRegions_%world%_regions'
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - note cu@<def[selectedCuboid].min.simple>|<def[selectedCuboid].max.simple> 'as:dregions_%world%_%name%'
      - run s@dRegions_Msg 'def:<&f><&o>%name%<&7><&o> updated to selection'
      }
      else {
      - define ownerPlayers 'li@<player.uuid>'
      - inject s@dRegions p:createRegionEntry instantly
      - run s@dRegions_Msg 'def:<&7><&o>Created %name% in %world%'
      }

  select:
  # /drg select [ID]
    - inject locally prerun instantly
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run s@dRegions_Msg 'def:<&c>There is an orphaned region by this name!'
      - run s@dRegions_Msg 'def:<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists].not> {
      - run s@dRegions_Msg 'def:<&c>There is no region by this name!'
      - queue clear
      }
    # Don't select global type regions
    - if <yaml[dRegions_%world%_regions].read[regions.%name%.type].is[==].to[global]||false> {
      - run s@dRegions_Msg 'def:<&c>You can not select global regions!'
      - queue clear
      }
    # Check if is owner
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run s@dRegions_Msg 'def:<&c>You are not an owner of this region!'
        - queue clear
        }
      }
    - define min '<yaml[dRegions_%world%_regions].read[regions.%name%.min].as_location.simple||null>'
    - define max '<yaml[dRegions_%world%_regions].read[regions.%name%.max].as_location.simple||null>'
    - flag <player> 'dWEWand_Type:cuboid'
    - flag <player> dWEWand:!
    - flag <player> dWEWand:|:%min%|%max%
    - run s@dRegions_Msg 'def:<&7><&o>Selected <&f><&o>%name%'

  info:
  # /drg info [ID] -w world
    - inject locally prerun instantly
    - narrate "2"
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run s@dRegions_Msg 'def:<&c>There is an orphaned region named %name%!'
      - run s@dRegions_Msg 'def:<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists].not> {
      - run s@dRegions_Msg 'def:<&c>There is no region by this name!'
      - queue clear
      }
    # Check if is owner
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run s@dRegions_Msg 'def:<&c>You are not an owner of this region!'
        - queue clear
        }
      }
    - inject locally regionInfo instantly
    - define msgsHeaderTitle '<&7>Region Info<&co> <&e>%name% <&8><&lb><&7>%world%<&8><&rb>'
    - inject locally msgsHeader instantly
    - narrate "<&5><el@val[|].pad_right[3]><&7>Type<&co> <&f>%type% <&8><&lb><&7><&o><def[pos1].split[,].remove[4].comma_separated.replace[ ]> <&8><&pipe> <&7><&o><def[pos2].split[,].remove[4].comma_separated.replace[ ]><&8><&rb> <&lb><&7><&o>%size%<&8><&rb>"
    - narrate "<&5><el@val[|].pad_right[3]><&7>Priority<&co> <&f><el@val[%priority%].pad_right[3]><&7>  Parent<&co> <&f>%parent%"
    - if <def[ownerPlayers].is_empty||true>
      && <def[ownerGroups].is_empty||true> {
      - narrate "<&5><el@val[|].pad_right[3]><&7>Owners<&co> <&c>none"
      }
      else {
      - define ownerList '<def[ownerPlayers].parse[as_player.name].include[<def[ownerGroups].parse[replace[regex:^].with[<&b>]]||>].comma_separated>'
      - define lines '<proc[dRegions_LineWrap].context[Owners, <def[ownerList]>|45]>'
      - narrate "<&5><el@val[|].pad_right[3]><&7><def[lines].get[1].split[, ].get[1]><&co>  <&f><def[lines].get[1].split[, ].remove[1].comma_separated>"
      - foreach <def[lines].remove[1]> {
        - narrate "<&5><el@val[|].pad_right[7]><&f><def[value]>"
        }
      }
    - if <def[memberPlayers].is_empty||true>
      && <def[memberGroups].is_empty||true> {
      - narrate "<&5><el@val[|].pad_right[3]><&7>Members<&co> <&c>none"
      }
      else {
      - define memberList '<def[memberPlayers].parse[as_player.name].include[<def[memberGroups].parse[replace[regex:^].with[<&b>]]||>].comma_separated>'
      - define lines '<proc[dRegions_LineWrap].context[Members, <def[memberList]>|45]>'
      - narrate "<&5><el@val[|].pad_right[3]><&7><def[lines].get[1].split[, ].get[1]><&co>  <&f><def[lines].get[1].split[, ].remove[1].comma_separated>"
      - foreach <def[lines].remove[1]> {
        - narrate "<&5><el@val[|].pad_right[7]><&f><def[value]>"
        }
      }
    - if <def[flags].is_empty> {
      - narrate "<&5><el@val[|].pad_right[3]><&7>Flags<&co> <&c>none"
      }
      else {
      - narrate "<&5><el@val[|].pad_right[3]><&7>Flags<&co>"
      - foreach '<def[flags].alphanumeric>' {
        - define flag '<def[value].split[/].get[1]>'
        - define flagVal '<def[value].after[/]>'
        - define flagValLength '<def[flagVal].length>'
        - define lines '<proc[dRegions_LineWrap].context[%flag%, <def[flagVal]>|45]>'
        - narrate "<&5><el@val[|].pad_right[5]><&e><def[lines].get[1].split[, ].get[1]><&co> <&f><def[lines].get[1].split[, ].remove[1].comma_separated>"
        - foreach <def[lines].remove[1]> {
          - narrate "<&5><el@val[|].pad_right[7]><&f><def[value]>"
          }
        }
      }
    - narrate "<&5>|"
    - inject locally msgsFooter instantly

  addowner:
  # /drg addowner [ID] g:group player
    - inject locally prerun instantly
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run s@dRegions_Msg 'def:<&c>There is an orphaned region by this name!'
      - run s@dRegions_Msg 'def:<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists].not> {
      - run s@dRegions_Msg 'def:<&c>There is no region by this name!'
      - queue clear
      }
    # Check if is owner
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run s@dRegions_Msg 'def:<&c>You are not an owner of this region!'
        - queue clear
        }
      }
    # Parse specified owners
    - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
      - define args '<c.args.remove[<c.args.find[-w].add[1].as_int>].exclude[-w]>'
      - define owners '<def[args].get[3].to[<def[args].size>].replace[:].with[;]||null>'
      }
      else {
      - define owners '<c.args.get[3].to[<c.args.size>].replace[:].with[;]||null>'
      }
    - if <def[owners].is_empty||true> {
      - run s@dRegions_Msg 'def:<&c>Must specify at least one owner'
      - queue clear
      }
    - foreach %owners% {
      - if <def[value].starts_with[g;]||false> {
        - define group '<def[value].replace[g;]>'
        - if <server.list_permission_groups> !contains %group% {
          - run s@dRegions_Msg 'def:<&c>%group% is not a valid group'
          - foreach next
          }
        - define groups '<yaml[dRegions_%world%_regions].read[regions.%name%.owners.groups]||li@>'
        - if <def[groups].contains[%group%]||false> {
          - run s@dRegions_Msg 'def:<&c>Group %group% is already an owner'
          - foreach next
          }
        - define pass true
        - yaml set 'regions.%name%.owners.groups:->:%group%' 'id:dRegions_%world%_regions'
        }
        else {
        - if !<def[value].as_player.is[!=].to[null]||false> {
          - foreach next
          }
        - define players '<yaml[dRegions_%world%_regions].read[regions.%name%.owners.players]||li@>'
        - if <def[players].contains[<def[value].as_player.uuid>]||false> {
          - run s@dRegions_Msg 'def:<&c>Player %value% is already an owner'
          - foreach next
          }
        - define pass true
        - yaml set 'regions.%name%.owners.players:->:<def[value].as_player.uuid>' 'id:dRegions_%world%_regions'
        - flag <def[value].as_player> 'dRegions.cache.%world%.%name%:!'
        }
      }
    - if <def[pass].exists||false> {
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - run s@dRegions_Msg 'def:<&f><&o>%name%<&7><&o> owners updated'
      }

  removeowner:
  # /drg removeowner [ID] g:group player
    - inject locally prerun instantly
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run s@dRegions_Msg 'def:<&c>There is an orphaned region by this name!'
      - run s@dRegions_Msg 'def:<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists].not> {
      - run s@dRegions_Msg 'def:<&c>There is no region by this name!'
      - queue clear
      }
    # Check if is owner
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run s@dRegions_Msg 'def:<&c>You are not an owner of this region!'
        - queue clear
        }
      }
    # Parse specified owners
    - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
      - define args '<c.args.remove[<c.args.find[-w].add[1].as_int>].exclude[-w]>'
      - define owners '<def[args].get[3].to[<def[args].size>].replace[:].with[;]||null>'
      }
      else {
      - define owners '<c.args.get[3].to[<c.args.size>].replace[:].with[;]||null>'
      }
    - if <def[owners].is_empty||true> {
      - run s@dRegions_Msg 'def:<&c>Must specify at least one owner'
      - queue clear
      }
    - foreach %owners% {
      - if <def[value].starts_with[g;]||false> {
        - define group '<def[value].replace[g;]>'
        - if <server.list_permission_groups> !contains %group% {
          - run s@dRegions_Msg 'def:<&c>%group% is not a valid group'
          - foreach next
          }
        - define groups '<yaml[dRegions_%world%_regions].read[regions.%name%.owners.groups]||li@>'
        - if <def[groups].contains[%group%].not||true> {
          - run s@dRegions_Msg 'def:<&c>Group %group% is not an owner'
          - foreach next
          }
        - define pass true
        - yaml set 'regions.%name%.owners.groups:<-:%group%' 'id:dRegions_%world%_regions'
        }
        else {
        - if !<def[value].as_player.is[!=].to[null]||false> {
          - foreach next
          }
        - define players '<yaml[dRegions_%world%_regions].read[regions.%name%.owners.players]||li@>'
        - if <def[players].contains[<def[value].as_player.uuid>].not||true> {
          - run s@dRegions_Msg 'def:<&c>Player %value% is not an owner'
          - foreach next
          }
        - define pass true
        - yaml set 'regions.%name%.owners.players:<-:<def[value].as_player.uuid>' 'id:dRegions_%world%_regions'
        - flag <def[value].as_player> 'dRegions.cache.%world%.%name%:!'
        }
      }
    - if <def[pass].exists||false> {
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - run s@dRegions_Msg 'def:<&f><&o>%name%<&7><&o> owners updated'
      }
      else {
      - run s@dRegions_Msg 'def:<&6><&o>%name%<&c><&o> owners not updated!'
      }

  addmember:
  # /drg addmember [ID] g:group player
    - inject locally prerun instantly
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run s@dRegions_Msg 'def:<&c>There is an orphaned region by this name!'
      - run s@dRegions_Msg 'def:<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists].not> {
      - run s@dRegions_Msg 'def:<&c>There is no region by this name!'
      - queue clear
      }
    # Check if is owner
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run s@dRegions_Msg 'def:<&c>You are not an owner of this region!'
        - queue clear
        }
      }
    # Parse specified members
    - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
      - define args '<c.args.remove[<c.args.find[-w].add[1].as_int>].exclude[-w]>'
      - define members '<def[args].get[3].to[<def[args].size>].replace[:].with[;]||null>'
      }
      else {
      - define members '<c.args.get[3].to[<c.args.size>].replace[:].with[;]||null>'
      }
    - if <def[members].is_empty||true> {
      - run s@dRegions_Msg 'def:<&c>Must specify at least one member'
      - queue clear
      }
    - foreach %members% {
      - if <def[value].starts_with[g;]||false> {
        - define group '<def[value].replace[g;]>'
        - if <server.list_permission_groups> !contains %group% {
          - run s@dRegions_Msg 'def:<&c>%group% is not a valid group'
          - foreach next
          }
        - define groups '<yaml[dRegions_%world%_regions].read[regions.%name%.members.groups]||li@>'
        - if <def[groups].contains[%group%]||false> {
          - run s@dRegions_Msg 'def:<&c>Group %group% is already a member'
          - foreach next
          }
        - define pass true
        - yaml set 'regions.%name%.members.groups:->:%group%' 'id:dRegions_%world%_regions'
        }
        else {
        - if !<def[value].as_player.is[!=].to[null]||false> {
          - foreach next
          }
        - define players '<yaml[dRegions_%world%_regions].read[regions.%name%.members.players]||li@>'
        - if <def[players].contains[<def[value].as_player.uuid>]||false> {
          - run s@dRegions_Msg 'def:<&c>Player %value% is already a member'
          - foreach next
          }
        - define pass true
        - yaml set 'regions.%name%.members.players:->:<def[value].as_player.uuid>' 'id:dRegions_%world%_regions'
        - flag <def[value].as_player> 'dRegions.cache.%world%.%name%:!'
        }
      }
    - if <def[pass].exists||false> {
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - run s@dRegions_Msg 'def:<&f><&o>%name%<&7><&o> members updated'
      }
      else {
      - run s@dRegions_Msg 'def:<&6><&o>%name%<&c><&o> members not updated!'
      }

  removemember:
  # /drg reomvemember [ID] g:group player
    - inject locally prerun instantly
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run s@dRegions_Msg 'def:<&c>There is an orphaned region by this name!'
      - run s@dRegions_Msg 'def:<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists].not> {
      - run s@dRegions_Msg 'def:<&c>There is no region by this name!'
      - queue clear
      }
    # Check if is owner
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run s@dRegions_Msg 'def:<&c>You are not an owner of this region!'
        - queue clear
        }
      }
    # Parse specified members
    - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
      - define args '<c.args.remove[<c.args.find[-w].add[1].as_int>].exclude[-w]>'
      - define members '<def[args].get[3].to[<def[args].size>].replace[:].with[;]||null>'
      }
      else {
      - define members '<c.args.get[3].to[<c.args.size>].replace[:].with[;]||null>'
      }
    - if <def[members].is_empty||true> {
      - run s@dRegions_Msg 'def:<&c>Must specify at least one member'
      - queue clear
      }
    - foreach %members% {
      - if <def[value].starts_with[g;]||false> {
        - define group '<def[value].replace[g;]>'
        - if <server.list_permission_groups> !contains %group% {
          - run s@dRegions_Msg 'def:<&c>%group% is not a valid group'
          - foreach next
          }
        - define groups '<yaml[dRegions_%world%_regions].read[regions.%name%.members.groups]||li@>'
        - if <def[groups].contains[%group%].not||true> {
          - run s@dRegions_Msg 'def:<&c>Group %group% is not a member'
          - foreach next
          }
        - define pass true
        - yaml set 'regions.%name%.members.groups:<-:%group%' 'id:dRegions_%world%_regions'
        }
        else {
        - if !<def[value].as_player.is[!=].to[null]||false> {
          - foreach next
          }
        - define players '<yaml[dRegions_%world%_regions].read[regions.%name%.members.players]||li@>'
        - if <def[players].contains[<def[value].as_player.uuid>].not||true> {
          - run s@dRegions_Msg 'def:<&c>Player %value% is not a member'
          - foreach next
          }
        - define pass true
        - yaml set 'regions.%name%.members.players:<-:<def[value].as_player.uuid>' 'id:dRegions_%world%_regions'
        - flag <def[value].as_player> 'dRegions.cache.%world%.%name%:!'
        }
      }
    - if <def[pass].exists||false> {
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - run s@dRegions_Msg 'def:<&f><&o>%name%<&7><&o> members updated'
      }
      else {
      - run s@dRegions_Msg 'def:<&6><&o>%name%<&c><&o> members not updated!'
      }

  list:
  # /drg list (page#) -r region -w world -p player

    - define args '<c.args.remove[1]>'
    # Check the specified player
    - if <def[args].find[-p].is[OR_MORE].than[0]||false> {
      - if !<player.permission[dregions.admin]||<player.is_op||false>> {
        - run s@dRegions_Msg 'def:<&c>You may not list other players regions!'
        - queue clear
        }
      - define player '<def[args].get[<def[args].find[-p].add[1].as_int>].escaped||null>'
      - if !<def[player].as_player.is[!=].to[null]||false> {
        - run s@dRegions_Msg 'def:<&c>Invalid player specfied!'
        - queue clear
        }
      - define filterPlayer ''
      - define args '<def[args].remove[<def[args].find[-p].add[1].as_int>].exclude[-p]||li@>'
      }
      else {
      - if <context.server.not> {
        - define player '<player.name>'
        }
        else {
        - define player 'null'
        }
      }

    # Check the specified world
    - if <def[args].find[-w].is[OR_MORE].than[0]||false> {
      - define world '<def[args].get[<def[args].find[-w].add[1].as_int>].as_world.name.to_lowercase.escaped||null>'
      - if <def[world].is[==].to[null]||true> {
        - run s@dRegions_Msg 'def:<&c>Invalid world specfied!'
        - queue clear
        }
      - define filterWorld ''
      - define args '<def[args].remove[<def[args].find[-w].add[1].as_int>].exclude[-w]||li@>'
      }
      else {
      - if <context.server.not> {
        - define world '<player.world.name.to_lowercase>'
        }
        else {
        - define world 'null'
        }
      }

    # Does the player want to list the regions where he stands?
    - if <def[args].find[-h].is[OR_MORE].than[0]||false> {
      - define filterHere ''
      - define args '<def[args].remove[<def[args].find[-h]>]||li@>'
      }

    # Do we want to show results for ALL worlds?
    - if <def[args].find[-a].is[OR_MORE].than[0]||false> {
      - define worlds '<server.list_worlds.parse[name.to_lowercase]>'
      - define getAll ''
      - define args '<def[args].remove[<def[args].find[-a]>]||li@>'
      }

    # Check the specified region name
    - if <def[args].find[-r].is[OR_MORE].than[0]||false> {
      - define region '<def[args].get[<def[args].find[-r].add[1].as_int>].escaped||null>'
      - if <def[region].is[!=].to[null]||true> {
        - define exists '<proc[dRegions_RegionExists].context[<def[region]>|<def[world]>]>'
        - if <def[exists].is[==].to[orphan]> {
          - run s@dRegions_Msg 'def:<&c>There is an orphaned region by this name!'
          - run s@dRegions_Msg 'def:<&c>Please notify an admin!'
          - queue clear
          }
          else if <def[exists].not> {
          - run s@dRegions_Msg 'def:<&c>There is no region by this name!'
          - queue clear
          }
        - if !<player.permission[dregions.admin]||<player.is_op||false>> {
          - if <proc[dRegions_IsOwner].context[<def[region]>|<def[world]>|<player>].not> {
            - run s@dRegions_Msg 'def:<&c>You are not an owner of this region!'
            - queue clear
            }
          }
        }
        else {
        - run s@dRegions_Msg 'def:<&c>You must specify a valid region ID!'
        - queue clear
        }
      - define filterRegion ''
      - define args '<def[args].remove[<def[args].find[-r].add[1].as_int>].exclude[-r]||li@>'
      }

    # OK, we've validated all the user input, let's get the regions and apply filters
    - define regions li@
    - if <def[filterHere].exists> {
      - define standingIn '<player.location.cuboids.parse[notable_name].filter[split[_].get[1].is[==].to[dRegions]].parse[after[dregions_%world%_]].separated_by[,]>'
      - define worldRegions '<proc[dRegions_HighestPriority].context[%world%|%standingIn%]||li@>'
      - if <def[worldRegions].is_empty||true> {
        - define worldRegions 'li@__global__'
        }
      - inject locally filterRegionList
      }
      else if <def[getAll].exists> {
      - foreach %worlds% {
        - define world %value%
        - define worldRegions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
        - inject locally filterRegionList
        }
      }
      else {
      - define worldRegions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
      - inject locally filterRegionList
      }

    # Display the list
    - define page '<def[args].get[1].replace[-].escaped||1>'
    - if <def[page].is[MATCHES].to[number].not> {
      - define page '1'
      }
    - define pages '<def[regions].size.div[14].round_up||1>'
    - if <def[page].is[MORE].than[%pages%]> {
      - define page '%pages%'
      }
    - define highNumber '<def[page].mul[14].as_int>'
    - define lowNumber '<def[highNumber].sub[13].as_int>'
    - define msgsHeaderTitle '<&e>Region List   <el@val[<&7><&o>Page <&f><&o>%page% <&7><&o>of %pages%].pad_left[30]>'
    - inject locally msgsHeader instantly
    - foreach <def[regions].get[%lowNumber%].to[%highNumber%]||li@> {
      - define color '<t[<def[value].split[/].get[3].is[==].to[owner]>]:&6||<t[<def[value].split[/].get[3].is[==].to[member]>]:&e||&f>>'
      - narrate "<&5>|<&sp><&7><el@val[<el@val[<def[lowNumber].add[<def[loop_index].sub[1]>].as_int>.].pad_left[4].with[<&sp>]>].pad_right[5].with[<&sp>]> <%color%><def[value].split[/].get[2]>"
      }
    - narrate "<&5>|"
    - inject locally msgsFooter instantly

  flag:
  # /drg flag [ID] [flag] [value] -g group -w world

    - define args '<c.args.remove[1]>'

    # Check the specified world
    - if <def[args].find[-w].is[OR_MORE].than[0]||false> {
      - define world '<def[args].get[<def[args].find[-w].add[1].as_int>].as_world.name.escaped.to_lowercase||null>'
      - if <def[world].is[==].to[null]||true> {
        - run s@dRegions_Msg 'def:<&c>Invalid world specfied!'
        - queue clear
        }
      - define args '<def[args].remove[<def[args].find_all[-w].parse[add[1].as_int]>].exclude[-w]||li@>'
      }
      else {
      - if <context.server.not> {
        - define world '<player.world.name.to_lowercase>'
        }
        else {
        - define world 'null'
        }
      }

    # Check the specified group
    - if <def[args].find[-g].is[OR_MORE].than[0]||false> {
      - define group '<def[args].get[<def[args].find[-g].add[1].as_int>].escaped.to_lowercase||null>'
      - if !<el@val[members|nonmembers|owners|nonowners|all].as_list.contains[%group%]||false> {
        - run s@dRegions_Msg 'def:<&c><def[group].unescaped> is an invalid group!'
        - queue clear
        }
      - define args '<def[args].remove[<def[args].find_all[-g].parse[add[1].as_int]>].exclude[-g]||li@>'
      }

    # Check the specified region name
    - define region '<def[args].get[1].escaped.to_lowercase||null>'
    - if <def[region].is[!=].to[null]||true> {
      - define exists '<proc[dRegions_RegionExists].context[<def[region]>|<def[world]>]>'
      - if <def[exists].is[==].to[orphan]> {
        - run s@dRegions_Msg 'def:<&c>There is an orphaned region by this name!'
        - run s@dRegions_Msg 'def:<&c>Please notify an admin!'
        - queue clear
        }
        else if <def[exists].not> {
        - run s@dRegions_Msg 'def:<&c>There is no region by this name!'
        - queue clear
        }
      - if !<player.permission[dregions.admin]||<player.is_op||false>> {
        - if <proc[dRegions_IsOwner].context[<def[region]>|<def[world]>|<player>].not> {
          - run s@dRegions_Msg 'def:<&c>You are not an owner of this region!'
          - queue clear
          }
        }
      }
      else {
      - run s@dRegions_Msg 'def:<&c>You must specify a valid region ID!'
      - queue clear
      }

    # Check the specified flag name
    - define flag '<def[args].get[2].escaped.to_lowercase||null>'
    - if <def[flag].is[!=].to[null]||true> {
      - define flags '<server.list_scripts.filter[starts_with[s@dRegions_Flag_]].parse[name.split[_].get[3]]||li@>'
      - if !<def[flags].contains[%flag%]||false> {
        - run s@dRegions_Msg 'def:<&c>You must specify a valid region flag!'
        - queue clear
        }
      }
      else {
      - run s@dRegions_Msg 'def:<&c>You must specify a valid region flag!'
      - queue clear
      }

    # By this point, we know the flag is being set or cleared, so let's clear the flag
    # cache for this region, any child regions, and any overlapping regions including __global__
    - run s@dRegions p:clearCache delay:1t 'def:%region%|%world%|%flag%'

    # Check the specified flag value and set or clear it.
    - define flagValue '<def[args].get[3].to[<def[args].size>].space_separated.escaped||null>'
    - if <def[flagValue].is[!=].to[null]||true> {
      - define type '<s@dRegions_Flag_%flag%.yaml_key[flag_type]>'
      - if <def[type].is[==].to[location]> {
        - if <def[flagValue].is[==].to[here]||true> {
          - define flagValue '<player.location.simple>'
          }
        }
      - define typeMatch '<proc[dRegion_FlagTypeMatch].context[%flagValue%|%flag%]>'
      - if !<def[TypeMatch]> {
        - define lines '<proc[dRegions_LineWrap].context[<s@dRegions_Flag_%Flag%.yaml_key[flag_help]||<&c>%flag% flag requires a %type% value!>|45]>'
        - foreach <def[lines]> {
          - run s@dRegions_Msg 'def:<&c><def[value]>'
          }
        - queue clear
        }
      - if <def[type].starts_with[state]||false>
        && <def[flagValue].is[==].to[none]||false> {
        - inject s@dRegions_Flag_%flag% p:command_handler
        - yaml set 'regions.%region%.flags.%flag%:!' 'id:dRegions_%world%_regions'
        - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
        - yaml 'savefile:dRegions/worlds/%world%/cache.yml' 'id:dRegions_%world%_cache'
        - run s@dRegions_Msg 'def:<&c>Cleared %flag% flag for region %region%'
        - queue clear
        }
      - inject s@dRegions_Flag_%flag% p:command_handler
      - if <s@dRegions_Flag_%flag%.yaml_key[flag_takeGroup]||false> {
        - if <def[group].exists> {
          - yaml set 'regions.%region%.flags.%flag%:<def[flagValue].unescaped>/%group%' 'id:dRegions_%world%_regions'
          }
          else {
          - yaml set 'regions.%region%.flags.%flag%:<def[flagValue].unescaped>' 'id:dRegions_%world%_regions'
          }
        }
        else {
        - yaml set 'regions.%region%.flags.%flag%:<def[flagValue].unescaped>' 'id:dRegions_%world%_regions'
        }
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - define string "<&f><&o>%region%<&7><&o> set %flag% flag to <&f><&o>%flagValue%"
      - define lines '<proc[dRegions_LineWrap].context[<def[string]>|45]>'
      - foreach <def[lines]> {
        - run s@dRegions_Msg 'def:<&f><&o><def[value].unescaped>'
        }
      }
      else {
      - inject s@dRegions_Flag_%flag% p:command_handler
      - yaml set 'regions.%region%.flags.%flag%:!' 'id:dRegions_%world%_regions'
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - run s@dRegions_Msg 'def:<&c>Cleared %flag% flag for region %region%'
      - queue clear
      }

  setpriority:
  # /drg setpriority [ID] [#]
    - inject locally prerun instantly
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run s@dRegions_Msg 'def:<&c>There is an orphaned region by this name!'
      - run s@dRegions_Msg 'def:<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists].not> {
      - run s@dRegions_Msg 'def:<&c>There is no region by this name!'
      - queue clear
      }
    # Check if is owner
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run s@dRegions_Msg 'def:<&c>You are not an owner of this region!'
        - queue clear
        }
      }
    # Verify specified priority
    - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
      - define args '<c.args.remove[<c.args.find[-w].add[1].as_int>].exclude[-w]>'
      - define priority '<def[args].get[3].escaped||null>'
      }
      else {
      - define priority '<c.args.get[3].escaped||null>'
      }
    - if <def[priority].is[matches].to[number].not||true> {
      - run s@dRegions_Msg 'def:<&c>Must specify a numeric value for priority'
      - queue clear
      }
    # Update region
    - yaml set 'regions.%name%.priority:%priority%' 'id:dRegions_%world%_regions'
    - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
    - run s@dRegions_Msg 'def:<&f><&o>%name%<&7><&o> set priority to <&f><&o>%priority%'

  setparent:
  # /drg setparent [ID] [parent]
    - inject locally prerun instantly
    # Check if child region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run s@dRegions_Msg 'def:<&c>There is an orphaned region by this name!'
      - run s@dRegions_Msg 'def:<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists].not> {
      - run s@dRegions_Msg 'def:<&c>There is no region by this name!'
      - queue clear
      }
    # Check if is owner
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run s@dRegions_Msg 'def:<&c>You are not an owner of this region!'
        - queue clear
        }
      }
    # Check if parent region exists
    - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
      - define args '<c.args.remove[<c.args.find[-w].add[1].as_int>].exclude[-w]>'
      - define parent '<def[args].get[3].escaped||null>'
      }
      else {
      - define parent '<c.args.get[3].escaped||null>'
      }
    - if %parent% == null {
      - define parent <yaml[dRegions_%world%_regions].read[regions.%name%.parent]||null>
      - if %parent% != null {
        - yaml set 'regions.%parent%.children:<-:%name%' 'id:dRegions_%world%_regions'
        }
      - yaml set 'regions.%name%.parent:!' 'id:dRegions_%world%_regions'
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - run s@dRegions_Msg 'def:<&7><&o>Unset parent for <&f><&o>%name%'
      - queue clear
      }
    # Check if parent region exists
    - define exists '<proc[dRegions_RegionExists].context[%parent%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run s@dRegions_Msg 'def:<&c>There is an orphaned region by this name!'
      - run s@dRegions_Msg 'def:<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists].not> {
      - run s@dRegions_Msg 'def:<&c>There is no region by this name!'
      - queue clear
      }
    # Check if player owns parent
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%parent%|%world%|<player>].not> {
        - run s@dRegions_Msg 'def:<&c>You are not an owner of this region!'
        - queue clear
        }
      }
    # Update the region
    - yaml set 'regions.%name%.parent:%parent%' 'id:dRegions_%world%_regions'
    - if <yaml[dRegions_%world%_regions].read[regions.%parent%.children]||li@> contains %name% {
      - yaml set 'regions.%parent%.children:<-:%name%' 'id:dRegions_%world%_regions'
      }
      else {
      - yaml set 'regions.%parent%.children:->:%name%' 'id:dRegions_%world%_regions'
      }
    - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
    - run s@dRegions_Msg 'def:<&f><&o>%name%<&7><&o> set parent to <&f><&o>%parent%'

  teleport:
  # /drg teleport [ID] -w world
    - narrate "Stub"
    - inject locally prerun instantly
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists]> == orphan {
      - run s@dRegions_Msg 'def:<&c>There is an orphaned region by this name!'
      - run s@dRegions_Msg 'def:<&c>Please notify an admin!'
      - queue clear
      }
      else if !%exists% {
      - run s@dRegions_Msg 'def:<&c>There is no region by this name!'
      - queue clear
      }
    # Check if is owner
    - if !<player.permission[dregions.admin]||false> && !<player.is_op> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run s@dRegions_Msg 'def:<&c>You are not an owner of this region!'
        - queue clear
        }
      }
    # Check for teleport perms
    - if !<player.permission[dregions.teleport]||false> && !<player.permission[dregions.teleport.own]||false> && !<player.permission[dregions.teleport.own.%name%]||false> {
      - run s@dRegions_Msg 'def:<&c>You do not have permission!'
      - queue clear
      }

  remove:
  # /drg remove [ID] -w world
    - inject locally prerun instantly
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run s@dRegions_Msg 'def:<&c>There is an orphaned region by this name!'
      - run s@dRegions_Msg 'def:<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists].not> {
      - run s@dRegions_Msg 'def:<&c>There is no region by this name!'
      - queue clear
      }
    # Don't remove the __global__ region
    - if <def[name].is[==].to[__global__]> {
      - run s@dRegions_Msg 'def:<&c>You can not remove the __global__ region!'
      - queue clear
      }
    # Check if is owner
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run s@dRegions_Msg 'def:<&c>You are not an owner of this region!'
        - queue clear
        }
      }
    # Remove region from ancestry
    # This should be done smarterer now since regions know both children and parents.
    - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__]||li@>'
    - foreach %regions% {
      - if <yaml[dRegions_%world%_regions].read[regions.%value%.parent]||null> == %name% {
        - yaml set 'regions.%value%.parent:<-:%name%' 'id:dRegions_%world%_regions'
        }
      - if <yaml[dRegions_%world%_regions].read[regions.%value%.children]||li@> contains %name% {
        - yaml set 'regions.%value%.children:<-:%name%' 'id:dRegions_%world%_regions'
        }
      }
    # Remove the region
    - yaml set 'regions.%name%:!' 'id:dRegions_%world%_regions'
    - note remove 'as:dregions_%world%_%name%'
    - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
    - run s@dRegions_Msg 'def:<&f><&o>%name%<&7><&o> has been removed from <&f><&o>%world%'

#
#  END dRegions Command Arguments
#--------------------------------------
#
#  dRegions Command Utilities
#
# Just some commonly used code blocks
#
  prerun:
  # Block of checks run before /most/ commands
    - if !<player.permission[dRegions.%command%]||false> && !<player.is_op> {
      - inject locally help
      - queue clear
      }
    - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
      - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||null>'
      - if <def[world].is[==].to[null]||true> {
        - run s@dRegions_Msg 'def:<&c>Invalid world specfied!'
        - run s@dRegions_Msg 'def:<script.yaml_key[commandArgs.%command%.usage]>'
        - queue clear
        }
      - define args '<c.args.remove[<c.args.find[-w].add[1].as_int>].exclude[-w]>'
      - define name '<def[args].get[2].escaped.to_lowercase||null>'
      }
      else {
      - define world '<player.world.name.to_lowercase>'
      }
    - if <li@define|redefine|claim.contains[%command%]> {
      - define wandType '<player.flag[dWEWand_Type]||cuboid>'
      - if <li@cuboid|extender.contains[%wandType%].not||true> {
        - run s@dRegions_Msg 'def:<&c>You must select a cuboid type region!'
        - run s@dRegions_Msg 'def:<script.yaml_key[commandArgs.%command%.usage]>'
        - queue clear
        }
      - define pos1 '<player.flag[dWEWand].get[1].as_location||null>'
      - define pos2 '<player.flag[dWEWand].get[2].as_location||null>'
      - if <def[pos1].is[==].to[null]>
        || <def[pos2].is[==].to[null]> {
        - run s@dRegions_Msg 'def:<&c>No region selected!'
        - run s@dRegions_Msg 'def:<script.yaml_key[commandArgs.%command%.usage]>'
        - queue clear
        }
      - if <def[pos1].world.name.is[!=].to[%world%]>
        || <def[pos2].world.name.is[!=].to[%world%]> {
        - run s@dRegions_Msg 'def:<&c>Selected region not within specified world!'
        - run s@dRegions_Msg 'def:<script.yaml_key[commandArgs.%command%.usage]>'
        - queue clear
        }
      - define selectedCuboid '<cu@%pos1%|%pos2%>'
      }
    - define name '<def[name]||<c.args.get[2].escaped.to_lowercase||null>>'
    - if '<def[name].is[==].to[null]||true>' {
      - if <li@info|select.contains[%command%]> {
        - define dRegions '<player.location.cuboids.parse[notable_name].filter[split[_].get[1].is[==].to[dRegions]].parse[after[dregions_%world%_]].separated_by[,]>'
        - narrate "%dRegions%"
        - define orderedRegions '<proc[dRegions_HighestPriority].context[%world%|%dRegions%]>'
        - narrate "%orderedRegions%"
        - if <def[orderedRegions].is_empty||true> {
          - define name '__global__'
          }
          else {
          - define name '<def[orderedRegions].get[1]>'
          - if <def[orderedRegions].size.is[MORE].than[1]> {
            - run s@dRegions_Msg 'def:<&c><&o>There are multiple regions at this location!'
            - run s@dRegions_Msg 'def:<&7><&o>Getting highest priority region info.'
            }
          }
        }
        else {
        - run s@dRegions_Msg 'def:<&c>You must specify a region ID!'
        - run s@dRegions_Msg 'def:<script.yaml_key[commandArgs.%command%.usage]>'
        - queue stop
        }
      }
    - narrate "%name%"
    - if '<def[name].matches[^[a-z0-9-_]+$].not>' {
      - run s@dRegions_Msg 'def:<&c>Region ID may only contain letters, numbers,'
      - run s@dRegions_Msg 'def:<&c>hyphen, and underscore!'
      - run s@dRegions_Msg 'def:<script.yaml_key[commandArgs.%command%.usage]>'
      - queue stop
      }
#    - inject s@dRegions_Commands p:selection_Size instantly
#    - define oldSize '%size%'


  filterRegionList:
  # Used in /drg list to apply various filters
    - if <def[filterRegion].exists||false> {
      - define filteredRegions 'li@'
      - foreach %worldRegions% {
        - define worldRegion '%value%'
        - if <yaml[dRegions_%world%_regions].read[regions.%worldRegion%.parent].is[==].to[<def[region]>]||false> {
          - define filteredRegions '<def[filteredRegions].include[%worldRegion%]||<def[filteredRegions]>>'
          }
        }
      }
    - if <def[filteredRegions].exists> {
      - define worldRegions '<def[filteredRegions]>'
      }
    - foreach %worldRegions% {
      - define worldRegion '%value%'
      - if <proc[dRegions_IsOwner].context[<def[worldRegion]>|<def[world]>|<def[player].as_player>]||false> {
        - define regions '<def[regions].include[<def[world]>/<def[worldRegion]>/owner]||<def[regions]>>'
        }
        else if <proc[dRegions_IsMember].context[<def[worldRegion]>|<def[world]>|<def[player].as_player>]||false> {
        - define regions '<def[regions].include[<def[world]>/<def[worldRegion]>/member]||<def[regions]>>'
        }
        else if <def[filterPlayer].exists.not||true> {
        - define regions '<def[regions].include[<def[world]>/<def[worldRegion]>/nonmember]||<def[regions]>>'
        }
      }

  regionInfo:
  # Build the data set for region info
    - define type '<yaml[dRegions_%world%_regions].read[regions.%name%.type]||null>'
    - if <def[type].is[==].to[cuboid]||false> {
      - define POS1 '<yaml[dRegions_%world%_regions].read[regions.%name%.min]||null>'
      - define POS2 '<yaml[dRegions_%world%_regions].read[regions.%name%.max]||null>'
      - inject s@dWE_Commands p:selection_Size instantly
      }
      else if <def[type].is[==].to[global]||false> {
      - define POS1 '0,0,0,%world%'
      - define POS2 '0,0,0,%world%'
      - define size 'infinite'
      }
      else {
      - run s@dRegions_Msg 'def:<&c>This region is misconfigured!'
      - run s@dRegions_Msg 'def:<&c>Notify an Admin!'
      - queue clear
      }
    - define priority '<yaml[dRegions_%world%_regions].read[regions.%name%.priority]||0>'
    - define parent '<yaml[dRegions_%world%_regions].read[regions.%name%.parent]||<&c>none>'
    - define ownerGroups '<yaml[dRegions_%world%_regions].read[regions.%name%.owners.groups]||li@>'
    - define ownerPlayers '<yaml[dRegions_%world%_regions].read[regions.%name%.owners.players]||li@>'
    - define memberGroups '<yaml[dRegions_%world%_regions].read[regions.%name%.members.groups]||li@>'
    - define memberPlayers '<yaml[dRegions_%world%_regions].read[regions.%name%.members.players]||li@>'
    - define flagList '<yaml[dRegions_%world%_regions].list_keys[regions.%name%.flags]||li@>'
    - define flags 'li@'
    - foreach %flagList% {
      - define flags '<def[flags].include[%value%/<yaml[dRegions_%world%_regions].read[regions.%name%.flags.%value%].as_list.comma_separated||null>]||%flags%>'
      }

#
#  END dRegions dRegions Command Utilities
#--------------------------------------
#
#  dRegions Command Messages
#
# Some messages used by commands. Should probably move to s@dRegions_Msg
#
  msgsHeader:
    - narrate "<&5>|----------------------------------------|"
    - narrate "<&5>|<&sp><&sp><&sp><&6>dRegions   <&7><def[msgsHeaderTitle]||>"
    - narrate "<&5>|<&f>"

  msgsFooter:
    - define anthony "text<&co>'<&7>|Anthony|',clickEvent<&co><&chr[007B]>action<&co>open_url,value<&co>'http<&co>//mineconomy.org'<&chr[007D]>,hoverEvent<&co><&chr[007B]>action<&co>show_item,value<&co>'<&chr[007B]><i@dRegions_Author_Anthony.json><&chr[007D]>'<&chr[007D]>"
    - define spacer "text<&co>'  '"
    - define prefix "text<&co>'<&5>|  <&f>Authors<&co>  '"
    - if <player.is_player||false> {
# JSON is broken in denizen. Just narrate for now.
      - narrate "<&5>|  <&f>Authors<&co>  <&7>|Anthony|"
      - execute as_server "tellraw <player.name> <&chr[007B]>text<&co>'',extra<&co>[<&chr[007B]>%prefix%<&chr[007D]>,<&chr[007B]>%anthony%<&chr[007D]>]<&chr[007D]>"
      }
      else {
      - announce to_console "<&5>|  <&f>Authors<&co>    <&7>|Anthony|"
      }
    - narrate "<&5>|-----------<&d>S<&5>-<&d>c<&5>-<&d>r<&5>-<&d>o<&5>-<&d>l<&5>-<&d>l<&5>---<&d>U<&5>-<&d>p<&5>-------------|"

  msgsHelpAdmin:
    # Filter the list of commands this player can use
    - define commands '<script.list_keys[commandArgs].alphanumeric.to_lowercase||li@>'
    - foreach %commands% {
      - if !<player.permission[dregions.%value%]||<player.is_op||<c.server||false>>> {
        - define commands '<def[commands].exclude[%value%]>'
        }
        else {
        - foreach next
        }
      }

    # Display the list
    - define page '<def[arg].replace[-].escaped||1>'
    - if <def[page].is[MATCHES].to[number].not> {
      - define page '1'
      }
    - define pages '<def[commands].size.div[5].round_up||1>'
    - if <def[page].is[MORE].than[%pages%]> {
      - define page '%pages%'
      }
    - define highNumber '<def[page].mul[5].as_int>'
    - define lowNumber '<def[highNumber].sub[4].as_int>'
    - define msgsHeaderTitle '<&e>Admin Help   <el@val[<&7><&o>Page <&f><&o>%page% <&7><&o>of %pages%].pad_left[30]>'
    - inject locally msgsHeader instantly
    - foreach <def[commands].get[%lowNumber%].to[%highNumber%]||li@> {
      - narrate "<&5>|<&sp><&sp><&f><def[value].to_titlecase><&co>"
      - narrate "<&5>|<&sp><&sp><&sp><&sp><&7><script.yaml_key[commandArgs.%value%.usage]||No usage info available!>"
      }
    - narrate "<&5>|"

  msgsHelpUser:
    - define msgsHeaderTitle 'User Help'
    - inject locally msgsHeader instantly
    - define par1 "dRegions is an advanced region management and world protection system written with the Denizen Scripting Engine."
    - define par2 "Heavily inspired by WorldGuard, the goal is to have an extremely efficient events system supporting an exhaustive set of region flags and configuration options."
    - define par3 "dRegions offers an intuitive command interface and provides thorough TAB completion."
    - define strings "<el@val[%par1%|%par2%|%par3%].as_list>"
    - foreach <def[strings]> {
      - define string "<&f><&sp><def[value]>"
      - define lines '<proc[dRegions_LineWrap].context[<def[string]>|44]>'
      - foreach <def[lines]> {
        - narrate "<&5>|<&f><&sp><&sp><def[value].unescaped>"
        }
      - narrate "<&5>|"
      }

#
#  END dRegions Command Messages
#
#--------------------------------------
#
#  I want to test moving all command arguments to their own command script so I
# can have the dregions command and the alias of these scripts run the same
# code. I'd like to add the flexibility for folks to type the full command
#    /dregions select
# or the shorter alias
#    /.sel
# and use the same code base, tab completion and all
#
# -----
#  dRegions Select Command
#
# Select a region by ID and optionally world
#
#dRegions_Command_Sel:
#  type: command
#  debug: false
#  name: select
#  description: Select a region by ID and optionally world
#  usage: /.sel
#  aliases:
#  - .sel
#  allowed help:
#  - determine true
#  tab complete:
#    - define args 'li@help|reload|define|redefine|claim|select|info|addowner|removeowner|addmember|removemember|list|flag|setpriority|setparent|teleport|remove'
#    - define arg '<c.args.get[1]||null>'
#    - if <def[arg].is[==].to[null]>
#      || !<def[args].contains[%arg%]> {
#      - inject locally tab_arg_1
#      }
#      else inject locally tab_%arg%
#    - determine '<def[result]||li@>'
#
#  script:
#  # We only want to run it if the user issues the alias /.sel command
#    - if <c.alias.is[!=].to[.sel]||true> queue clear
#
#    - define command 'select'
#    - define args 'li@help|reload|select|define|redefine|remove|addowner|addmember|setparent|setpriority'
#    - if !<def[args].contains[%command%]> inject locally help instantly
#      else inject locally %command% instantly
#
#  sel:
#  # /drg select [ID]
#    - inject locally prerun instantly
#    # Check if region exists
#    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
#    - if <def[exists].is[==].to[orphan]> {
#      - run s@dRegions_Msg 'def:<&c>There is an orphaned region by this name!'
#      - run s@dRegions_Msg 'def:<&c>Please notify an admin!'
#      - queue clear
#      }
#      else if <def[exists].not> {
#      - run s@dRegions_Msg 'def:<&c>There is no region by this name!'
#      - queue clear
#      }
#    # Check if is owner
#    - if !<player.permission[dregions.admin]||false> {
#      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
#        - run s@dRegions_Msg 'def:<&c>You are not an owner of this region!'
#        - queue clear
#        }
#      }
#    - define min '<yaml[dRegions_%world%_regions].read[regions.%name%.min].as_location.simple||null>'
#    - define max '<yaml[dRegions_%world%_regions].read[regions.%name%.max].as_location.simple||null>'
#    - flag <player> 'dWEWand_Type:cuboid'
#    - flag <player> dWEWand:!
#    - flag <player> dWEWand:|:%min%|%max%
#    - run s@dRegions_Msg 'def:<&7><&o>Selected <&f><&o>%name%'
#
#  prerun:
#  # Block of checks run before /most/ commands
#    - if !<player.permission[dRegions.%command%]||<player.is_op||false>> {
#      - inject locally help
#      - queue clear
#      }
#    - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
#      - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name||null>'
#      - if <def[world].is[==].to[null]||true> {
#        - run s@dRegions_Msg 'def:<&c>Invalid world specfied!'
#        - queue clear
#        }
#      - define args '<c.args.remove[<c.args.find[-w].add[1].as_int>].exclude[-w]>'
#      - define name '<def[args].get[2].escaped||null>'
#      }
#      else define world '<player.world.name>'
#    - if <li@define|redefine|claim.contains[%command%]> {
#      - define wandType '<player.flag[dWEWand_Type]||cuboid>'
#      - if <li@cuboid|extender.contains[%wandType%].not||true> {
#        - run s@dRegions_Msg 'def:<&c>You must select a cuboid type region!'
#        - queue clear
#        }
#      - define pos1 '<player.flag[dWEWand].get[1].as_location||null>'
#      - define pos2 '<player.flag[dWEWand].get[2].as_location||null>'
#      - if <def[pos1].is[==].to[null]>
#        || <def[pos2].is[==].to[null]> {
#        - run s@dRegions_Msg 'def:<&c>No region selected!'
#        - queue clear
#        }
#      - if <def[pos1].world.name.is[!=].to[%world%]>
#        || <def[pos2].world.name.is[!=].to[%world%]> {
#        - run s@dRegions_Msg 'def:<&c>Selected region not within specified world!'
#        - queue clear
#        }
#      - define selectedCuboid '<cu@%pos1%|%pos2%>'
#      }
#    - define name '<def[name]||<c.args.get[2].escaped||null>>'
#    - if <def[name].is[==].to[null]||true> {
#      - run s@dRegions_Msg 'def:<&c>You must specify a name!'
#      - queue stop
#      }
#
#  END dRegions Command Script Basics
#--------------------------------------
#
################################################################################
#
#  dRegions Other Utilities
#
# Other Utility functions used throughout dRegions
#
#--------------------------------------
#
#  Command Permission Check Procedure script
#
#   Used to check if a player has permission to use a command.
#
#  I have to think about this more...
#  # A procedure script to check if a player has any of the required permissions for a command
#  # <proc[dRegions_HasPerm_Command].context[command|player|region|option]>
#
dRegions_HasPerm_Command:
  type: procedure
  speed: 0
  debug: false
  definitions: command|player|region|option

  script:
    - if <player.permission[a]||null> == null {
      - if <player.is_op> {
        - determine true
        }
        else {
        - determine false
        }
      }
    - if %option% == null {
      - inject locally permCheck
      }
      else {
      - inject locally permCheck-%command%
      }

  permCheck:
    - narrate "permCheck <s@dRegions_Commands.yaml_key[commandArgs.%command%.permissions]||li@>"
    - if <player.is_op> || <player.permission[dregions.admin]> {
      - determine true
      }
    - define perms "<s@dRegions_Commands.yaml_key[commandArgs.%command%.permissions]||li@>"
    - foreach %perms% {
      - define perm '<parse:%value%>'
      - if <player.permission[%perm%]> {
        - determine true
        }
      }
    - determine false

  permCheck-flag:
    - define flag '%option%'
    - narrate "permCheck-flag <parse:<s@dRegions_Commands.yaml_key[commandArgs.%command%.permissions]||li@>>"
    - if <player.is_op> || <player.permission[dregions.admin]> {
      - determine true
      }
    - define perms "<s@dRegions_Commands.yaml_key[commandArgs.%command%.permissions]||li@>"
    - foreach %perms% {
      - define perm '<parse:%value%>'
      - narrate "<player.permission[%perm%]> %perm%"
      - if <player.permission[%perm%]> {
        - determine true
        }
      }
    - determine false


dRegions_RegionSort:
# An attempt to sort regions by priority. The existing method is faster.
# Keeping for reference and lulz.
  type: procedure
  definitions: region1|region2
  speed: 0
  debug: false

  script:
    - define region1pri '<def[region1].split[/].get[1]>'
    - define region2pri '<def[region2].split[/].get[1]>'
    - if %region1pri% > %region2pri% {
      - determine -1
      }
    - if %region1pri% < %region2pri% {
      - determine 1
      }
    - if %region1pri% == %region2pri% {
      - determine 0
      }

dRegions_IsOwner:
  # A procedure script to check if a player is a region owner
  # <proc[dRegions_IsOwner].context[region|world|player]>
  type: procedure
  definitions: region|world|player
  speed: 0
  debug: false

  script:
    - define playerUUID '<def[player].uuid>'
    - if <yaml[dRegions_%world%_regions].read[regions.%region%.owners.players].contains[%playerUUID%]||false> {
      - determine 'true'
      }
    - define playerGroups '<def[player].groups||li@>'
    - if <yaml[dRegions_%world%_regions].read[regions.%region%.owners.groups].contains_any[%playerGroups%]||false> {
      - determine 'true'
      }
    # Regions inherit members and owners.
    - while <el@a.is[==].to[a]> {
      - define region '<yaml[dRegions_%world%_regions].read[regions.%region%.parent]||null>'
      - if %region% == null {
        - while stop
        }
      - if <yaml[dRegions_%world%_regions].read[regions.%region%.owners.players].contains[%playerUUID%]||false> {
        - determine 'true'
        }
      - if <yaml[dRegions_%world%_regions].read[regions.%region%.owners.groups].contains_any[%playerGroups%]||false> {
        - determine 'true'
        }
      }
    - determine 'false'


dRegions_IsMember:
  # A procedure script to check if a player is a region member
  # <proc[dRegions_IsMember].context[region|world|player]>
  type: procedure
  definitions: region|world|player
  speed: 0
  debug: false

  script:
    - define playerUUID '<def[player].uuid>'
    - if <yaml[dRegions_%world%_regions].read[regions.%region%.members.players].contains[%playerUUID%]||false> {
      - determine 'true'
      }
    - define playerGroups '<def[player].groups||li@>'
    - if <yaml[dRegions_%world%_regions].read[regions.%region%.members.groups].contains_any[%playerGroups%]||false> {
      - determine 'true'
      }
    # Regions inherit members and owners.
    - while <el@a.is[==].to[a]> {
      - define region '<yaml[dRegions_%world%_regions].read[regions.%region%.parent]||null>'
      - if %region% == null {
        - while stop
        }
      - if <yaml[dRegions_%world%_regions].read[regions.%region%.members.players].contains[%playerUUID%]||false> {
        - determine 'true'
        }
      - if <yaml[dRegions_%world%_regions].read[regions.%region%.members.groups].contains_any[%playerGroups%]||false> {
        - determine 'true'
        }
      }
    - determine 'false'


dRegions_RegionExists:
  # A procedure script to check if a region exists
  # <proc[dRegions_RegionExists].context[region|world]>
  type: procedure
  definitions: region|world
  speed: 0
  debug: false

  script:
    - if %region% == '__global__' {
      - determine true
      }
#    - define notables '<cu@dregions_%world%_%region%.is[!=].to[null].not||true>'
    - define notables '<server.list_notables[cuboids].contains[cu@dregions_%world%_%region%].not||true>'
    - define regions '<yaml[dRegions_%world%_regions].contains[regions.%region%].not||true>'
    - if %notables% && %regions% {
      - determine false
      }
      else if %notables% || %regions% {
      - determine orphan
      }
      else {
      - determine true
      }


dRegions_HighestPriority:
# Used sparingly in some commands. Events implement this method directly.
  # Filter a list of regions by priority in descending order
  # <proc[dRegions_HighestPriority].context[world|region1,...]>
  type: procedure
  definitions: world|regions
  speed: 0
  debug: false

  script:
    - define regions '<def[regions].split[,]||li@>'
    - define regionPri 'li@'
    - foreach %regions% {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - determine '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'


dRegions_RegionOverlaps:
  # A procedure script to check if a region overlaps other (un)owned regions
  # <proc[dRegions_RegionOverlaps].context[<def[selectedCuboid].separated_by[/]>|%name%|%world%|<player>]>
  # NOTE: If for some reason the selected cuboid overlaps an unowned region that is a lower priority than
  # a region that the player does own and is completely within, it will not be considered as an overlap!
  #  - But why would there be a lower priority region inside a higher priority region... that's not
  #    how priorities should be used!
  type: procedure
  definitions: selectedCuboid|world|player
  speed: 0
  debug: false

  script:
    - define selectedCuboid '<def[selectedCuboid].split[/].as_cuboid>'
    - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__]||li@>'
    - define notables '<def[regions].parse[replace[regex:^].with[cu@dregions_%world%_]].filter[as_cuboid.is[!=].to[null]]||li@>'
    - define overlaps '<def[notables].filter[intersects[<def[selectedCuboid]>]].parse[replace[cu@dregions_%world%_]]||li@>'
    - define orderedRegions '<proc[dRegions_HighestPriority].context[%world%|<def[overlaps].separated_by[,]>]||li@>'
    - foreach <def[orderedRegions]> {
      - if <proc[dRegions_IsOwner].context[%value%|%world%|<player>].not> {
        - determine true
        }
#      - if <proc[dRegions_CuboidIsWithinCuboid].context[<def[selectedCuboid].separated_by[/]>|<def[value].replace[regex:^].with[cu@dregions_%world%_].as_cuboid.full.separated_by[/]>]> {
      - if <def[selectedCuboid].is_within[<def[value].replace[regex:^].with[cu@dregions_%world%_].as_cuboid>]> {
        - determine false
        }
      }
    # By this point, we've determined that the player either owns all the regions at this cuboid location
    # or that the new cuboid is completely within a region that he does own.
    - determine false


dRegions_PlayerMatchRegionGroup:
  # Check if a player matches a region flag group setting.
  # <proc[dRegions_PlayerMatchRegionGroup].context[group|region|world|player]>
  type: procedure
  definitions: group|region|world|player
  speed: 0
  debug: false

  script:
    - inject locally %group%

  all:
    - determine 'true'

  members:
    - determine '<proc[dRegions_isMember].context[%region%|%world%|%player%]>'

  nonmembers:
    - if <proc[dRegions_isOwner].context[%region%|%world%|%player%]> {
      - determine 'false'
      }
    - if <proc[dRegions_isMember].context[%region%|%world%|%player%]> {
      - determine 'false'
      }
    - determine 'true'

  owners:
    - determine '<proc[dRegions_isOwner].context[%region%|%world%|%player%]>'

  nonowners:
    - determine '<proc[dRegions_isOwner].context[%region%|%world%|%player%].not>'



dRegions_CuboidIsWithinCuboid:
# Not used anywhere since Denizen implemented its own which is faster.
# Keeping for reference.
  # Checks if one cuboid is completely within another cuboid
  # <proc[dRegions_CuboidIsWithinCuboid].context[inner|outer]>
  type: procedure
  definitions: inner|outer
  speed: 0
  debug: false

  script:
    - define innerCuboid '<def[inner].split[/].as_cuboid>'
    - define outerCuboid '<def[outer].split[/].as_cuboid>'

    - if <def[innerCuboid].min.x.is[OR_MORE].than[<def[outerCuboid].min.x>]>
      && <def[innerCuboid].min.y.is[OR_MORE].than[<def[outerCuboid].min.y>]>
      && <def[innerCuboid].min.z.is[OR_MORE].than[<def[outerCuboid].min.z>]>
      && <def[innerCuboid].max.x.is[OR_LESS].than[<def[outerCuboid].max.x>]>
      && <def[innerCuboid].max.y.is[OR_LESS].than[<def[outerCuboid].max.y>]>
      && <def[innerCuboid].max.z.is[OR_LESS].than[<def[outerCuboid].max.z>]> {
      - determine true
      }
      else {
      - determine false
      }


dRegions_GetInheritedFlag:
  # Get a region flag value. Start at current child and ascend through parents
  # until a value is set or you reach the origin ancestor
  # <proc[dRegions_GetInheritedFlag].context[world|region|flag]>
  type: procedure
  definitions: world|region|flag
  speed: 0
  debug: false

  script:
    - define return '<yaml[dRegions_%world%_regions].read[regions.%region%.flags.%flag%]||null>'
    - while <def[return].is[==].to[null]> {
      - define region '<yaml[dRegions_%world%_regions].read[regions.%region%.parent]||null>'
      - if %region% == null {
        - while stop
        }
      - define return '<yaml[dRegions_%world%_regions].read[regions.%region%.flags.%flag%]||null>'
      }
    - determine '%return%'


dRegions_CanUse_Block:
# Not used internally. It's intended as part of an API for external scripts.
# Procedure script to determine if a player can use a block at a location.
# Will work for any block that can be interacted with (chests, doors, levers, etc.)
# <proc[dRegions_CanUse_Block].context[player|location]>
  type: procedure
  speed: 0
  debug: false
  definitions: player|location

  script:
    - define world '<def[location].world.name>'
    - define target '<def[location].material.bukkit_enum>'
    - define FlagScript '<s@dRegions_Map_Interactions.yaml_key[block.%target%]||s@dRegions_Map_Interactions>'
    - define flag '<def[FlagScript].yaml_key[flag_name]||null>'
    - if %flag% == null determine false
    - if <def[player].permission[dregions.admin]||<def[player].is_op>> determine true
    - define flag-targetList '<def[FlagScript].yaml_key[flag_targetList]||null>'
    - if <def[location].cuboids.is_empty||true> {
      - inject locally check-global
      - determine 'true'
      - queue clear
      }
    - define regionPri 'li@'
    - foreach <def[location].cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
      - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
      }
    - define orderedRegions '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'
    - inject locally check-region
    - determine 'true'

  check-global:
    - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|%flag%]>'
    - if %flagObj% == null {
      - define flagObj '<def[FlagScript].yaml_key[flag_globalDefault]||none>'
      }
    - if %flagObj% != none {
      - if <def[flagObj].split[/].get[1]> == allow {
        - if !<proc[dRegions_PlayerMatchRegionGroup].context[<def[flagObj].split[/].get[2]||all>|__global__|%world%|%player%]> {
#          - inject %FlagScript% p:event-cleanup
          - determine false
          }
        - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|%flag-targetList%].replace[, ].with[|].as_list>'
        - if ( %targetList% != li@null ) && ( %targetList% != li@all ) && ( %targetList% !contains %target% ) {
#          - inject %FlagScript% p:event-cleanup
          - determine false
          }
        }
        else {
        - if <proc[dRegions_PlayerMatchRegionGroup].context[<def[flagObj].split[/].get[2]||all>|__global__|%world%|%player%]> {
          - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|%flag-targetList%].replace[, ].with[|].as_list>'
          - if ( %targetList% == li@null ) || ( %targetList% == li@all ) || ( %targetList% contains %target% ) {
#            - inject %FlagScript% p:event-cleanup
            - determine false
            }
          }
        }
      }

  check-region:
    - if <def[FlagScript].yaml_key[region_highestOnly]||false> {
      - define region '<def[orderedRegions].get[1]>'
      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|%flag%]>'
      }
      else {
      - foreach %orderedRegions% {
        - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|%flag%]>'
        - define region '%value%'
        - if %flagObj% != null {
          - foreach stop
          }
        }
      }
    - if %flagObj% == null {
      - define flagObj '<def[FlagScript].yaml_key[flag_defaultValue]||none>'
      }
    - if %flagObj% != none {
      - if <def[flagObj].split[/].get[1]> == allow {
        - if !<proc[dRegions_PlayerMatchRegionGroup].context[<def[flagObj].split[/].get[2]||all>|<def[orderedRegions].get[1]>|%world%|%player%]> {
#          - inject %FlagScript% p:event-cleanup
          - determine false
          }
        - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|%flag-targetList%].replace[, ].with[|].as_list>'
        - if ( %targetList% != li@null ) && ( %targetList% != li@all ) && ( %targetList% !contains %target% ) {
#          - inject %FlagScript% p:event-cleanup
          - determine false
          }
        }
        else {
        - if <proc[dRegions_PlayerMatchRegionGroup].context[<def[flagObj].split[/].get[2]||all>|<def[orderedRegions].get[1]>|%world%|%player%]> {
          - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|%flag-targetList%].replace[, ].with[|].as_list>'
          - if ( %targetList% == li@null ) || ( %targetList% == li@all ) || ( %targetList% contains %target% ) {
#            - inject %FlagScript% p:event-cleanup
            - determine false
            }
          }
        }
      }


dRegions_getRelativeLocation:
# Not used anywhere, but still fun to look at.
  # A procedure script to get a location relative to another location.
  # Specify the direction as   n s e w u d
  # <proc[dRegions_getRelativeLocation].context[location|direction|distance]>
  type: procedure
  definitions: l|d|n
  speed: 0
  debug: false

  n_math: sub
  n_coord: '0,0,<def[n]>'
  s_math: add
  s_coord: '0,0,<def[n]>'
  w_math: sub
  w_coord: '<def[n]>,0,0'
  e_math: add
  e_coord: '<def[n]>,0,0'
  d_math: sub
  d_coord: '0,<def[n]>,0'
  u_math: add
  u_coord: '0,<def[n]>,0'

  script:
    - define math '<script.yaml_key[%d%_math]>'
    - define coord '<script.yaml_key[%d%_coord]>'
    - determine "<def[l].as_location.%math%[%coord%]>"


dRegions_LineWrap:
  # Turn a long string into a list of smaller strings
  type: procedure
  definitions: string|targetLen
  speed: 0
  debug: false

  script:
    - define stringLen '<def[string].length>'
    - if <def[stringLen].is[MORE].than[%targetLen%]> {
      - define lines 'li@'
      - while <def[stringLen].is[MORE].than[0]> {
        - define low '<def[increment].add[1].as_int||1>'
        - define hi '<def[increment].add[<def[targetLen].add[1]>].as_int||%targetLen%>'
        - define pass '<def[string].substring[%low%,%hi%]>'
        - if <def[pass].length.is[==].to[%stringLen%]> {
          - define lines '<def[lines].include[%pass%]||<def[lines]>>'
          - while stop
          }
          else {
          - define brake '<def[pass].last_index_of[ ]>'
          - define increment '<def[increment].add[%brake%]||%brake%>'
          - define passtrim '<def[pass].substring[1,<t[<def[brake].is[MORE].than[0]>]:%brake%||<def[pass].length>>]>'
          - define lines '<def[lines].include[%passtrim%]||<def[lines]>>'
          - define stringLen '<def[stringLen].sub[%brake%]>'
          }
        - if <def[loop_index].is[MORE].than[10]> {
          - while stop
          }
        }
      - determine '<def[lines].as_list>'
      }
      else {
      - determine '<def[string].as_list>'
      }


dRegions_WG_Importer:
# Import WorldGuard regions to dRegions in one fell swoop.
# Also covers popular WG extensions like WorldGuard Custom Flags and WorldRegions
  type: task
  debug: false
  speed: 0

  script:
    - ^announce "<&b>dRegions<&co><&3> Starting WorldGuard region import..." to_console
    - ^inject locally loadYaml
    - ^foreach %WG_Import_Worlds% {
      - define world '%value%'
      - announce "<&b>dRegions<&co><&3> Importing %world% region files..." to_console
      - foreach <yaml[dRegions_WGImport_%world%].list_keys[regions]||li@> {
        - define region '%value%'
        - announce "<&b>dRegions<&co><&3> Importing %region%..." to_console
        - inject locally importRegion instantly
        }
      - yaml 'savefile:dRegions/worlds/<def[world].to_lowercase>/import.yml' 'id:dRegions_%world%_import'
      }
    - ^inject locally unloadYaml
    - ^announce "<&b>dRegions<&co><&3> WorldGuard region import complete!" to_console

  unloadYaml:
    - yaml unload 'id:dRegions_WGImport_File'
    - foreach %WG_Import_Worlds% {
      - yaml unload 'id:dRegions_WGImport_%value%'
      - yaml unload 'id:dRegions_%value%_import'
      }

  loadYaml:
    - yaml fix_formatting 'load:<script.relative_filename>' 'id:dRegions_WGImport_File'
    - announce "<&b>dRegions<&co><&3> Loading WorldGuard region files..." to_console
    - define WG_Import_Worlds 'li@'
    - foreach <server.list_worlds.parse[name]> {
      - define world '%value%'
      - if <server.has_file[../WorldGuard/worlds/%world%/regions.yml]||false> {
        - define pass ''
        - define WG_Import_Worlds '<def[WG_Import_Worlds].include[%world%]>'
        - yaml fix_formatting 'load:../WorldGuard/worlds/%world%/regions.yml' 'id:dRegions_WGImport_%world%'
        - if !<server.has_file[dRegions/worlds/%world%/import.yml]||false> {
          - yaml create 'id:dRegions_%world%_import'
          }
        - if !<yaml.list.contains[dRegions_%world%_import]> {
          - yaml 'load:dRegions/worlds/%world%/import.yml' 'id:dRegions_%world%_import'
          }
        }
        else {
        - announce "<&b>dRegions<&co><&c> /WorldGuard/worlds/%world%/regions.yml does not exist!" to_console
        }
      }
    - if <def[pass].exists> {
      - announce "<&b>dRegions<&co><&3> WorldGuard region files loaded!" to_console
      }

  importRegion:
  # Set the region type and coordinates
    - define type '<yaml[dRegions_WGImport_%world%].read[regions.%region%.type]>'
    - yaml set 'regions.%region%.type:%type%' 'id:dRegions_%world%_import'
    - if %type% == cuboid {
      - define min '<yaml[dRegions_WGImport_%world%].read[regions.%region%.min.x]>,<yaml[dRegions_WGImport_%world%].read[regions.%region%.min.y]>,<yaml[dRegions_WGImport_%world%].read[regions.%region%.min.z]>,%world%'
      - define max '<yaml[dRegions_WGImport_%world%].read[regions.%region%.max.x]>,<yaml[dRegions_WGImport_%world%].read[regions.%region%.max.y]>,<yaml[dRegions_WGImport_%world%].read[regions.%region%.max.z]>,%world%'
      - yaml set 'regions.%region%.min:<el@val[<def[min].as_location>|<def[max].as_location>].as_cuboid.min.simple>' 'id:dRegions_%world%_import'
      - yaml set 'regions.%region%.max:<el@val[<def[min].as_location>|<def[max].as_location>].as_cuboid.max.simple>' 'id:dRegions_%world%_import'
      }

  # Set priority
    - yaml set 'regions.%region%.priority:<yaml[dRegions_WGImport_%world%].read[regions.%region%.priority]>' 'id:dRegions_%world%_import'

  # Set parent/child associations
    - define parent '<yaml[dRegions_WGImport_%world%].read[regions.%region%.parent]||null>'
    - if %parent% != null {
      - yaml set 'regions.%region%.parent:%parent%' 'id:dRegions_%world%_import'
      - if <yaml[dRegions_%world%_import].read[regions.%parent%.children].as_list||li@> !contains %region% {
        - yaml set 'regions.%parent%.children:->:%region%' 'id:dRegions_%world%_import'
        }
      }

  # Import members and owners
    - define members-players '<yaml[dRegions_WGImport_%world%].read[regions.%region%.members.unique-ids].as_list.exclude[<yaml[dRegions_%world%_import].read[regions.%region%.members.players]||li@>]||li@>'
    - foreach %members-players% {
      - yaml set 'regions.%region%.members.players:->:%value%' 'id:dRegions_%world%_import'
      }
    - define members-groups '<yaml[dRegions_WGImport_%world%].read[regions.%region%.members.groups].as_list.exclude[<yaml[dRegions_%world%_import].read[regions.%region%.members.groups]||li@>]||li@>'
    - foreach %members-groups% {
      - yaml set 'regions.%region%.members.groups:->:%value%' 'id:dRegions_%world%_import'
      }
    - define owners-players '<yaml[dRegions_WGImport_%world%].read[regions.%region%.owners.unique-ids].as_list.exclude[<yaml[dRegions_%world%_import].read[regions.%region%.owners.players]||li@>]||li@>'
    - foreach %owners-players% {
      - yaml set 'regions.%region%.owners.players:->:%value%' 'id:dRegions_%world%_import'
      }
    - define owners-players '<yaml[dRegions_WGImport_%world%].read[regions.%region%.owners.groups].as_list.exclude[<yaml[dRegions_%world%_import].read[regions.%region%.owners.groups]||li@>]||li@>'
    - foreach %owners-players% {
      - yaml set 'regions.%region%.owners.groups:->:%value%' 'id:dRegions_%world%_import'
      }

  # Import flags
    - define flags '<yaml[dRegions_WGImport_%world%].list_keys[regions.%region%.flags]||li@>'
    - foreach %flags% {
      - define flag '%value%'
      - define mapping '<script.yaml_key[mapping.%flag%]||null>'
      - if %mapping% == null {
        - announce "<&b>dRegions<&co><&c> %flag% flag does not exist in dRegions!" to_console
        - foreach next
        }
      - inject s@dRegions_WG_Importer 'p:<def[mapping].split[/].get[1]>'
      }

  flag_allowed-cmds:
    - define commands '<yaml[dRegions_WGImport_%world%].read[regions.%region%.flags.allowed-cmds].as_list.parse[replace[/]]||li@>'
    - yaml set 'regions.%region%.flags.commands:allow' 'id:dRegions_%world%_import'
    - yaml set 'regions.%region%.flags.commands-list:<def[commands].separated_by[ ; ]>' 'id:dRegions_%world%_import'

  flag_blocked-cmds:
    - define commands '<yaml[dRegions_WGImport_%world%].read[regions.%region%.flags.allowed-cmds].as_list.parse[replace[/]]||li@>'
    - yaml set 'regions.%region%.flags.commands:deny' 'id:dRegions_%world%_import'
    - yaml set 'regions.%region%.flags.commands-list:<def[commands].separated_by[ ; ]>' 'id:dRegions_%world%_import'

  flag_entity-explode:
    - define currentState '<yaml[dRegions_%world%_import].read[regions.%region%.flags.entity-explode]||null>'
    - define currentList '<yaml[dRegions_%world%_import].read[regions.%region%.flags.entity-explodelist].replace[, ].with[|].as_list||li@>'
    - define flagVal '<yaml[dRegions_WGImport_%world%].read[regions.%region%.flags.%flag%]>'
    - define entity '<def[flag].before[-]>'
    - if %entity% == enderdragon {
      - define entity 'ender_dragon'
      }
      else if %entity% == tnt {
      - define entity 'primed_tnt|minecart_tnt'
      }
      else if %entity% == ghast {
      - define entity 'fireball|small_fireball'
      }
      else if %entity% == other {
      - define entity 'ender_crystal|fireball|small_fireball|wither|wither_skull'
      }
    - if %currentState% == null {
      - yaml set 'regions.%region%.flags.entity-explode:%flagVal%' 'id:dRegions_%world%_import'
      - yaml set 'regions.%region%.flags.entity-explodelist:<def[entity].as_list.comma_separated>' 'id:dRegions_%world%_import'
      }
      else if ( %currentState% == allow && %flagVal% == allow ) || ( %currentState% == deny && %flagVal% == deny ) {
      - define newList '<def[currentList].include[%entity%].deduplicate>'
      - if <def[newList].contains[creeper|ender_crystal|ender_dragon|primed_tnt|minecart_tnt|fireball|small_fireball|wither|wither_skull]> {
        - define newList 'all'
        }
        else {
        - define newList '<def[newList].comma_separated>'
        }
      - yaml set 'regions.%region%.flags.entity-explodelist:%newList%' 'id:dRegions_%world%_import'
      }
    - inject locally flag_entity-grief

  flag_deny-spawn:
    - define currentState '<yaml[dRegions_%world%_import].read[regions.%region%.flags.mob-spawn]||null>'
    - define currentList '<yaml[dRegions_%world%_import].read[regions.%region%.flags.mob-spawnlist].replace[, ].with[|].as_list||li@>'
    - define mobSpawn '<yaml[dRegions_WGImport_%world%].read[regions.%region%.flags.mob-spawning]||null>'
    - define denySpawn '<yaml[dRegions_WGImport_%world%].read[regions.%region%.flags.deny-spawn]||null>'

    - if %denySpawn% != null {
      - yaml set 'regions.%region%.flags.mob-spawn:deny' 'id:dRegions_%world%_import'
      - yaml set 'regions.%region%.flags.mob-spawnlist:<def[denySpawn].as_list.comma_separated>' 'id:dRegions_%world%_import'
      }
      else {
      - yaml set 'regions.%region%.flags.mob-spawn:%mobSpawn%' 'id:dRegions_%world%_import'
      }

  flag_entity-grief:
    - define currentState '<yaml[dRegions_%world%_import].read[regions.%region%.flags.entity-grief]||null>'
    - define currentList '<yaml[dRegions_%world%_import].read[regions.%region%.flags.entity-grieflist].replace[, ].with[|].as_list||li@>'
    - define flagVal '<yaml[dRegions_WGImport_%world%].read[regions.%region%.flags.%flag%]||null>'
    - define entity '<def[flag].before[-]>'

    - if %entity% == enderdragon {
      - define entity 'ender_dragon'
      }
      else if %entity% == tnt {
      - define entity 'primed_tnt|minecart_tnt'
      }
      else if %entity% == wither {
      - define entity 'wither|wither_skull'
      }
      else if %entity% == ghast {
      - define entity 'ghast|fireball|small_fireball'
      }
      else if %entity% == other {
      - define entity 'ender_crystal|fireball|small_fireball|wither|wither_skull'
      }

    - if %currentState% == null {
      - yaml set 'regions.%region%.flags.entity-grief:%flagVal%' 'id:dRegions_%world%_import'
      - yaml set 'regions.%region%.flags.entity-grieflist:<def[entity].as_list.comma_separated>' 'id:dRegions_%world%_import'
      }
      else if ( %currentState% == allow && %flagVal% == allow ) || ( %currentState% == deny && %flagVal% == deny ) {
      - define newList '<def[currentList].include[%entity%].deduplicate>'
      - if <def[newList].contains[creeper|enderman|ender_dragon|ghast|fireball|small_fireball|primed_tnt|minecart_tnt|zombie|wither|wither_skull|sheep]> {
        - define newList 'all'
        }
        else {
        - define newList '<def[newList].comma_separated>'
        }
      - yaml set 'regions.%region%.flags.entity-grieflist:%newList%' 'id:dRegions_%world%_import'
      }

  flag_boolean:
    - yaml set 'regions.%region%.flags.<def[mapping].split[/].get[2]>:<tern[<yaml[dRegions_WGImport_%world%].read[regions.%region%.flags.%flag%].is[==].to[deny]>]:false||true>' 'id:dRegions_%world%_import'

  flag_generic:
    - yaml set 'regions.%region%.flags.<def[mapping].split[/].get[2]>:<yaml[dRegions_WGImport_%world%].read[regions.%region%.flags.%flag%]>' 'id:dRegions_%world%_import'

  flag_generic-list:
    - yaml set 'regions.%region%.flags.<def[mapping].split[/].get[2]>:<yaml[dRegions_WGImport_%world%].read[regions.%region%.flags.%flag%]>' 'id:dRegions_%world%_import'
    - yaml set 'regions.%region%.flags.<def[mapping].split[/].get[3]>:all' 'id:dRegions_%world%_import'

  flag_generic-group:
    - define group '<yaml[dRegions_WGImport_%world%].read[regions.%region%.flags.%flag%-group].replace[_].to_lowercase||null>'
    - if %group% == null {
      - yaml set 'regions.%region%.flags.<def[mapping].split[/].get[2]>:<yaml[dRegions_WGImport_%world%].read[regions.%region%.flags.%flag%]>' 'id:dRegions_%world%_import'
      }
      else {
      - yaml set 'regions.%region%.flags.<def[mapping].split[/].get[2]>:<yaml[dRegions_WGImport_%world%].read[regions.%region%.flags.%flag%]>/%group%' 'id:dRegions_%world%_import'
      }

  flag_generic-list-group:
    - define group '<yaml[dRegions_WGImport_%world%].read[regions.%region%.flags.%flag%-group].replace[_].to_lowercase||null>'
    - if %group% == null {
      - yaml set 'regions.%region%.flags.<def[mapping].split[/].get[2]>:<yaml[dRegions_WGImport_%world%].read[regions.%region%.flags.%flag%]>' 'id:dRegions_%world%_import'
      }
      else {
      - yaml set 'regions.%region%.flags.<def[mapping].split[/].get[2]>:<yaml[dRegions_WGImport_%world%].read[regions.%region%.flags.%flag%]>/%group%' 'id:dRegions_%world%_import'
      }
    - yaml set 'regions.%region%.flags.<def[mapping].split[/].get[3]>:all' 'id:dRegions_%world%_import'

  mapping:
  # WorldGuard Flags
    allowed-cmds: flag_allowed-cmds
    blocked-cmds: flag_blocked-cmds
    build: flag_generic-group/build
    block-break: flag_generic-group/block-break
    block-place: flag_generic-group/block-place
    chest-access: flag_generic-list-group/chest-access/chest-access-blocks
    deny-spawn: flag_deny-spawn
    creeper-explosion: flag_entity-explode
    ghast-fireball: flag_entity-explode
    enderdragon-block-damage: flag_entity-explode
    other-explosion: flag_entity-explode
    tnt: flag_entity-explode
    enderman-grief: flag_entity-grief
    enderpearl: flag_generic-group/enderpearl
    entity-item-frame-destroy: flag_generic/entity-break-itemframe
    entity-painting-destroy: flag_generic/entity-break-painting
    entry: flag_generic-group/entry
#    entry-deny-message:
    exit: flag_generic-group/exit
#    exit-deny-message:
#    exit-override:
#    exit-via-teleport:
#    exp-drops:
#    fall-damage:
#    farewell: flag_farewell
    feed-amount: flag_generic-group/feed-amount
    feed-delay: flag_generic/feed-delay
    feed-max-hunger: flag_generic/feed-max
    feed-min-hunger: flag_generic/feed-min
#    fire-sread:
    game-mode: flag_generic-group/gamemode
    grass-growth: flag_generic/grass-spread
#    greeting:
    heal-amount: flag_generic-group/heal-amount
    heal-delay: flag_generic/heal-delay
    heal-max-health: flag_generic/heal-max
    heal-min-health: flag_generic/heal-min
    ice-form: flag_boolean/ice-form
    ice-melt: flag_boolean/ice-melt
#    interact:
    invincible: flag_generic-list-group/player-damage/player-damage-types
    item-drop: flag_generic-group/player-drops
    item-pickup: flag_generic-group/player-pickup
#    lava-fire:
    lava-flow: flag_generic-list/lava-spread/lava-spreadblocks
    leaf-decay: flag_boolean/leaf-decay
    lighter: flag_generic-group/lighter
    lightning: flag_generic-list/lightning-strike/lightning-strikeblocks
    mob-damage: flag_generic-list-group/mob-damage/mob-damagelist
    mob-spawning: flag_deny-spawn
    mushroom-growth: flag_boolean/mushroom-spread
    mycelium-spread: flag_boolean/mycel-spread
    notify-enter: flag_boolean/notify-enter
    notify-leave: flag_boolean/notify-exit
    pistons: flag_boolean/pistons
    potion-splash: flag_boolean/potion-throw
    pvp: flag_boolean/pvp
#    recieve-chat:
#    ride:
    send-chat: flag_generic-group/send-chat
    sleep: flag_generic-group/sleep
    snow-fall: flag_generic-list/snow-fall/snow-fallblocks
    snow-melt: flag_boolean/snow-melt
    soil-dry: flag_boolean/soil-dry
#    spawn:
#    teleport:
#    time-lock:
#    use:
    vehicle-destroy: flag_generic-group/vehicle-destroy
    vehicle-place: flag_generic-group/vehicle-place
    vine-growth: flag_boolean/vine-spread
    water-flow: flag_generic-list/water-spread/water-spreadblocks
#    weather-lock:

  # WorldRegions flags http://dev.bukkit.org/bukkit-plugins/worldregions/
#    allow-blocks:
#    deny-blocks:
#    chat-prefix:
#    chat-suffix:
#    chunk-unload:
#    cmds-block:
#    cmds-allow:
#    allow-pickup:
#    death-drop-despawn-time:
#    death-exp-despawn-time:
#    drop-despawn-time:
#    exp-despawn-time:
#    enderpearls:
#    allow-explosions:
#    deny-explosions:
#    fly:
#    instabreak:
#    keep-inventory:
#    keep-level:
#    mob-damage-allow:
#    mob-damage-deny:
#    allow-damage:
#    deny-damage:
#    player-enter-command:
#    player-leave-command:
#    server-enter-command:
#    server-leave-command:
#    effects:
#    signs-allow:
#    signs-block:
#    respawn-location:
#    texturepack:
#    delta-time:
#    fix-time:
#    max-time:
#    min-time:
#    treefarm:

  # WorldGuard Custom Flags http://dev.bukkit.org/bukkit-plugins/worldguard-custom-flags/pages/flags/
#    allowed-break: flag_generic-list-group/block-break/block-breaklist
#    allowed-damage:
#    allowed-place: flag_generic-list-group/block-place/block-placelist
#    apply-potion:
#    blocked-break: flag_generic-list-group/block-break/block-breaklist
#    blocked-damage:
#    blocked-place: flag_generic-list-group/block-place/block-placelist
#    healing:
#    hunger:
#    instabreak:
#    item-pickup:
#    item-spawn:
#    mob-targeting:
#    pve:
#    regen:
    sheep-eat: flag_entity-grief
#    time:
    wither-block-damage: flag_entity-grief
    zombie-door-break: flag_entity-grief





################################################################################
#
#  FlagTypeMatch Procedure script
#
#    Used to check that the player specified value matches the type required
#   by the flag.
#
#    Use this to compare 2 values. Check if they are one of NUMBER, DECIMAL,
#   LOCATION, BOOLEAN, STATE, GROUP, LIST or any other STRING.
#
#   usage:
#     - define YourValue "Some string"
#     - define Type "<s@dRegions_Flag_%flag%.yaml_key[flag_type]||null>"
#     - define TypeMatch '<proc[dRegion_FlagTypeMatch].context[%YourValue%|%flag%]>'
#     - if <def[TypeMatch]> {
#       - narrate "%YourValue% matches %type%."
#       }
#       else {
#       - narrate "%YourValue% is a %YourValueType% not a %type%"
#       }
#
dRegion_FlagTypeMatch:
# Used to check if the value supplied when setting a flag is valid for the flag type.
  type: procedure
  speed: 0
  debug: false
  definitions: YourValue|Flag

  script:

    - define Type "<s@dRegions_Flag_%Flag%.yaml_key[flag_type]||null>"
    - if <def[Type].is[==].to[number]> {
      - if <def[YourValue].is[MATCHES].to[number]> {
        - determine 'true'
        }
        else {
        - determine 'false'
        }
      }
    - if <def[Type].is[==].to[decimal]> {
      - if <def[YourValue].is[MATCHES].to[decimal]> {
        - determine 'true'
        }
        else {
        - determine 'false'
        }
      }
    - if <def[Type].is[==].to[boolean]> {
      - if <def[YourValue].is[MATCHES].to[boolean]> {
        - determine 'true'
        }
        else {
        - determine 'false'
        }
      }
    - if <def[Type].is[==].to[location]> {
      - if <def[YourValue].as_location.world.is[!=].to[null]||false> {
        - determine 'true'
        }
        else {
        - determine 'false'
        }
      }
    - if <def[Type].starts_with[state]> {
      - if <el@val[allow|deny|none].as_list.contains[%YourValue%]||false> {
        - determine 'true'
        }
        else {
        - determine 'false'
        }
      }
    - if <def[Type].is[==].to[group]> {
      - if <el@val[members|nonmembers|owners|nonowners|all].as_list.contains[%YourValue%]||false> {
        - determine 'true'
        }
        else {
        - determine 'false'
        }
      }
    - if <def[Type].is[==].to[list]> {
      - if '<def[YourValue].split[ ].get[1].contains_any_text[-a|-r]||false>' {
        - determine 'true'
        }
        else {
        - determine 'false'
        }
      }
    - if <def[Type].is[==].to[custom]> {
      - if <s@dRegions_Flag_%flag%.yaml_key[flag_type_customVal].as_list.contains[%YourValue%]||false> {
        - determine 'true'
        }
        else {
        - determine 'false'
        }
      }
    - if <def[Type].is[==].to[string]> {
      - if <def[YourValue].is[!=].to[null]||false> {
        - determine 'true'
        }
        else {
        - determine 'false'
        }
      }
    - determine 'false'

#
#  END other utilities
#--------------------------------------
#
#  dRegions author banner items
#
# Banner items representing the authors
#
dRegions_Author_Anthony:
  type: item
  speed: 0
  debug: false
  material: i@human_skull
  display name: "<&f>             |Anthony|"
  lore:
  - <&7>  Owner<&co> <&e>M<&6>ine<&e>C<&6>onomy <&e>N<&6>etwork
  - <&5>-------------------------
  - <&7>
  - <&7>  I\<&sq>ve been playing minecraft
  - <&7> and running a server since
  - <&7> 2010. I have fun and share
  - <&7> what I do.
  - <&7>
  - <&9>           Click To Visit
#
#  END dRegions author banner items
#--------------------------------------
#
#  dRegions Interaction Mapping
#
# Mapping what to do when interacting with blocks and items
#
dRegions_Map_Interactions:
  type: yaml data
  debug: false

  # Used as a fallback for non-existent interaction mappings
  event:
    - queue clear
  event-global:
    - queue clear

  block:
# Containers
    chest: s@dRegions_Flag_Chest-Access
    ender_chest: s@dRegions_Flag_Chest-Access
    locked_chest: s@dRegions_Flag_Chest-Access
    trapped_chest: s@dRegions_Flag_Chest-Access
    dispenser: s@dRegions_Flag_Chest-Access
    hopper: s@dRegions_Flag_Chest-Access
    dropper: s@dRegions_Flag_Chest-Access
# Doors
    trap_door: s@dRegions_Flag_Door-Access
    iron_trapdoor: s@dRegions_Flag_Door-Access
    wooden_door: s@dRegions_Flag_Door-Access
    iron_door_block: s@dRegions_Flag_Door-Access
    spruce_door: s@dRegions_Flag_Door-Access
    birch_door: s@dRegions_Flag_Door-Access
    jungle_door: s@dRegions_Flag_Door-Access
    dark_oak_door: s@dRegions_Flag_Door-Access
    acacia_door: s@dRegions_Flag_Door-Access
    fence_gate: s@dRegions_Flag_Door-Access
    spruce_fence_gate: s@dRegions_Flag_Door-Access
    birch_fence_gate: s@dRegions_Flag_Door-Access
    jungle_fence_gate: s@dRegions_Flag_Door-Access
    dark_oak_fence_gate: s@dRegions_Flag_Door-Access
    acacia_fence_gate: s@dRegions_Flag_Door-Access
# Switches
    lever: s@dRegions_Flag_Use-Switches
    wood_button: s@dRegions_Flag_Use-Switches
    stone_button: s@dRegions_Flag_Use-Switches
    wood_plate: s@dRegions_Flag_Use-Switches
    stone_plate: s@dRegions_Flag_Use-Switches
    iron_plate: s@dRegions_Flag_Use-Switches
    gold_plate: s@dRegions_Flag_Use-Switches
# Utility Blocks
    workbench: s@dRegions_Flag_Use-Utilities
    furnace: s@dRegions_Flag_Use-Utilities
    burning_furnace: s@dRegions_Flag_Use-Utilities
    brewing_stand: s@dRegions_Flag_Use-Utilities
    enchantment_table: s@dRegions_Flag_Use-Utilities
    anvil: s@dRegions_Flag_Use-Utilities
    beacon: s@dRegions_Flag_Use-Utilities
    jukebox: s@dRegions_Flag_Use-Utilities
    note_block: s@dRegions_Flag_Use-Utilities
#    cauldron: useUtility
#    tnt: useUtility
# Other blocks that change when clicked regardless of item in hand
    flower_pot: s@dRegions_Flag_Build
    cake_block: s@dRegions_Flag_Build
    diode_block_on: s@dRegions_Flag_Build
    diode_block_off: s@dRegions_Flag_Build
    redstone_comparator_off: s@dRegions_Flag_Build
    redstone_comparator_on: s@dRegions_Flag_Build

  block_withItem:
#    jukebox: s@dRegions_Flag_Use-Utilities/air/gold_record|green_record|record_3|record_4|record_5|record_6|record_7|record_8|record_9|record_10|record_11|record_12
    cauldron: s@dRegions_Flag_Use-Utilities/bucket|water_bucket|glass_bottle
    tnt: s@dRegions_Flag_Use-Utilities/flint_and_steel
    activator_rail: s@dRegions_Flag_Vehicle-Place/minecart|storage_minecart|powered_minecart|explosive_minecart|hopper_minecart|command_minecart
    detector_rail: s@dRegions_Flag_Vehicle-Place/minecart|storage_minecart|powered_minecart|explosive_minecart|hopper_minecart|command_minecart
    powered_rail: s@dRegions_Flag_Vehicle-Place/minecart|storage_minecart|powered_minecart|explosive_minecart|hopper_minecart|command_minecart
    rails: s@dRegions_Flag_Vehicle-Place/minecart|storage_minecart|powered_minecart|explosive_minecart|hopper_minecart|command_minecart
    stationary_water: s@dRegions_Flag_Vehicle-Place/boat
    water: s@dRegions_Flag_Vehicle-Place/boat
    mob_spawner: s@dRegions_Flag_Build/monster_egg

  item:
    ink_sac:
    gold_record: jukebox
    glass_bottle: cauldron
    flint_and_steel: tnt

  dye_colors:
    black: 0
    red: 1
    green: 2
    brown: 3
    blue: 4
    purple: 5
    cyan: 6
    silver: 7
    gray: 8
    pink: 9
    lime: 10
    yellow: 11
    light_blue: 12
    magenta: 13
    orange: 14
    white: 15

#
#  END dRegions Interaction Mapping
#--------------------------------------




################################################################################
#                                                                              #
# Configuration Files                                                          #
#                                                                              #
#   These are the default config files. They will be used to build the default #
# configuration and data storage files.                                        #
#                                                                              #
#______________________________________________________________________________#
#                                                                              #
#______________________________DO_NOT_EDIT_THIS_DATA___________________________#
#______________________________________________________________________________#


dRegions_Configurations:
  type: yaml data

  config:
    version: 0.27
    regions:
      enable: true
      invincibility-removes-mobs: false
      wand: dWE_Wand
      ownerOnDefine: false
      claim:
        max-volume: 0
        only-inside-existing-regions: true
        max-region-count-per-player:
          default: 7
    spread:
      water: true
      water-list: []
      lava: true
      lava-list: []
      mycel: true
      grass: true
      mushroom: true
      vines: true
    physics:
      gravel: true
      sand: true
    portal:
      create: true
      entity-enter: true
      player-enter: true
    fire:
      ender_crystal: true
      explosion: true
      fireball: true
      flint_and_steel: true
      lava: true
      spread: true
      spread-list: []
      destroyBlocks: true
      destroyBlocks-list: []
    entity:
      changeBlocks: true
      changeBlocks-list: []
      explode: true
      explode-list: []
    entity-break-item_frame: true
    entity-break-painting: true
    blockform:
      ice: true
      snow: true
      snow-list: []
    blockfade:
      ice: true
      snow: true
    lightning-strike: true
    lightning-strike-list: []
    trample-crops:
      player: true
      entity: true
    leaf-decay: true
    player-damage: true
    player-damage-list: []
#    auto-invincible: false
#    protection:
#      item-durability: true
#      remove-infinite-stacks: false
#      disable-xp-orb-drops: false
#      disable-obsidian-generators: true
#    weather:
#      prevent-lightning-strike-blocks: []
#      disable-lightning-strike-fire: false
#      disable-thunderstorm: false
#      disable-weather: false
#      disable-pig-zombification: false
#      disable-powered-creepers: false
#      always-raining: false
#      always-thundering: false

  regions:
    __global__:
      type: global
      priority: 0
      flags: []
      owners: []
      members: []

  inventories:
    info:
      - This is the inventory save file.
      - DO NOT EDIT!
    example:
      region:
        entry:
          kit:
            equip: []
            inv: []
          players:
            player:
              equip: []
              inv: []
        exit:
          players:
            player:
              equip: []
              inv: []

  cache:
    boolean: []
    state-withTarget: []
    info:
      - This is the cache file. We use this file to cache individual specific events so that we can reduce the number of flag lookups later on.
      - Expect it to grow to a considerable size!


#
