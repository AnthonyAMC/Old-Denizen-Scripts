################################################################################
#
#                                d R e g i o n s
#
#
#   Authors: |Anthony|
#   Version: 0.2
#   dScript Version: 0.9.6-DEV_b65
#
#
#   Dependencies:
#
#    - dWorldEditor
#      - Integrates with region selection wand
#      - https://github.com/AnthonyAMC/Public-Denizen-Scripts/blob/master/dWE/dWorldEditor.yml
#
#    - ConfigFileGenerator
#      - Used to build default config files and data storage.
#      - https://github.com/AnthonyAMC/Public-Denizen-Scripts/blob/master/ConfigFileGenerator.yml
#
#    - Flags
#      - All the flags for dRegions. It will be bundled in eventually.
#      - https://github.com/AnthonyAMC/Public-Denizen-Scripts/blob/master/dRegions/flags.dscript
#
#_______________________________________________________________________________
#
#--- About dRegions
#
#  dRegions is an advanced region management and world protection system written
# with the Denizen Scripting Engine. Heavily inspired by WorldGuard, the goal is
# to have an extremely efficient events system supporting an exhaustive set of
# region flags and configuration options. dRegions offers an intuitive command
# interface and provides thorough TAB completion.
#
#
#--- Installation & Setup
#
#  Install Flags, ConfigFileGenerator, dWorldEditor, and dRegions to your scripts
# folder and reload scripts. /denizen reload scripts
#
#  All config and data storage files will be automatically generated in your
# Denizen plugin folder. /plugins/Denizen/dRegions
#
#
#--- Permissions & Commands
#
#  Here's a list of all the permissions and commands with a brief description
# of each. More verbose usage info can be found in game. /drg help
#
#  dRegions provides thorough TAB completion! Use this to your benefit!
#
#  The permissions system isn't fully realized yet. Meanwhile, we have a list of
# generic permissions to get you by.
#
#  /drg help [arg/#]      dregions.help          Specify a page number or command arg
#  /drg define            dregions.define        Define a region
#  /drg redefine          dregions.redefine      Update region to new selection
#  /drg claim             dregions.claim         Claim the selected region
#  /drg select            dregions.select        Select a region by id
#  /drg remove            dregions.remove        Remove a region
#  /drg list              dregions.list          List regions
#  /drg info              dregions.info          See info on a region
#  /drg addowner          dregions.addowner      Add a player or perm group as a region owner
#  /drg removeowner       dregions.removeowner   Remove a player or perm group from region owner
#  /drg addmember         dregions.addmember     Add a player or perm group as a region member
#  /drg removemember      dregions.removemember  Remove a player or perm group from region member
#  /drg flag              dregions.flag          Set region flags
#  /drg setpriority       dregions.setpriority   Set region priority
#  /drg setparent         dregions.setparent     Set region parent
#  /drg teleport          dregions.teleport      Teleport to region
#  /drg reload            dregions.reload        Reload all config files
#  /drg restart           dregions.restart       Restart dRegions for whatever reason
#                         dregions.admin         Override permission for all things dRegions
#
#
#--- Basic Usage Tutorial
#
#  After you've gotten installed, setup, and permissions assigned (op-only mode
# is fine too), you will need to give yourself a region wand. /dwe wand
#
#  Mark your region selection using the wand as directed.
#
#  Define your region noting any owners (player or -g group) you want
#   - /drg define myRegion notch herobrine -g members -g vip
#
#  Your region is now protected! *Still indev! Not all protections implemented!*
#
#  Set region priority
#   - /drg setpriority myRegion 10
#
#  Set any region flags you need
#   - /drg flag myRegion greeting Hello <player.name>!
#
#
################################################################################
#
#  dRegions World Events Script
#
#  This should cover all dRegions related world events.
#
#
dRegions:
  type: world
  debug: false
  events:
##################################################
#
#  World Events
#
#
    on server start:
    - run locally start delay:2t

    on world initializes:
    - run locally loadYaml instantly

    on script reload:
    - if !<yaml.list.contains[dRegions_global_config]||false> {
      - run locally start instantly
      }

#    on structure grows:
#    - announce "Grew <context.structure>"
#    - announce "<player.name||unknown>"

    on block ignites:
    - define world '<c.location.world.name.to_lowercase>'
    - define target '<c.location.material.bukkit_enum.to_lowercase>'
    - define readPath 'fire.<c.cause||spread>'
    - inject instantly s@dRegions p:event_PreProc_Config
    - define cuboids '<c.location.cuboids>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
#    - define eventHooks '<t[<c.entity.is_player||false>]:fireFrom-Lighter||fireSpread>'
    - define eventHooks '<t[<c.cause.is[==].to[flint_and_steel]>]:fireFrom-Lighter||fireFrom-Spread>'
    - inject instantly s@dRegions p:event_PreProc_RunEvent

    on block burns:
    - define world '<c.location.world.name.to_lowercase>'
    - define target '<c.location.material.bukkit_enum.to_lowercase>'
    - define readPath 'fire.destroyBlocks'
    - inject instantly s@dRegions p:event_PreProc_Config
    - define cuboids '<c.location.cuboids>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
    - define eventHooks 'fire-destroyBlocks'
    - inject instantly s@dRegions p:event_PreProc_RunEvent

    on block forms:
    - define world '<c.location.world.name.to_lowercase>'
    - define mat '<c.material.bukkit_enum.to_lowercase>'
    - define target '<c.location.sub[0,1,0].material.bukkit_enum.to_lowercase>'
    - define readPath 'blockform.<def[mat]>'
    - inject instantly s@dRegions p:event_PreProc_Config
    - define cuboids '<c.location.cuboids>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
    - define eventHooks 'blockForm-<def[mat]>'
    - inject instantly s@dRegions p:event_PreProc_RunEvent

    on block fades:
    - define world '<c.location.world.name.to_lowercase>'
    - define mat '<c.material.bukkit_enum.to_lowercase>'
    - define target '<c.location.sub[0,1,0].material.bukkit_enum.to_lowercase>'
    - define readPath 'blockfade.<def[mat]>'
    - inject instantly s@dRegions p:event_PreProc_Config
    - define cuboids '<c.location.cuboids>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
    - define eventHooks 'blockFade-<def[mat]>'
    - inject instantly s@dRegions p:event_PreProc_RunEvent

    on block spreads:
#    - announce "spread <c.material.bukkit_enum> <c.location.material.bukkit_enum>"
    - define world '<c.location.world.name.to_lowercase>'
    - define target '<c.location.material.bukkit_enum.to_lowercase>'
    - define readPath 'spread.<c.material.bukkit_enum.split[_].last.to_lowercase||null>'
    - inject instantly s@dRegions p:event_PreProc_Config
    - define cuboids '<c.location.cuboids>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
    - define eventHooks '<c.material.bukkit_enum.split[_].last>Spread'
    - inject instantly s@dRegions p:event_PreProc_RunEvent

    on liquid spreads:
    - define world '<c.location.world.name.to_lowercase>'
    - define target '<c.destination.material.bukkit_enum.to_lowercase>'
    - define readPath 'spread.<c.location.material.bukkit_enum.split[_].last.to_lowercase||null>'
    - inject instantly s@dRegions p:event_PreProc_Config
    - define cuboids '<c.location.cuboids.include[<c.destination.cuboids>].deduplicate>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
    - define eventHooks '<c.location.material.bukkit_enum.split[_].last>Spread'
    - inject instantly s@dRegions p:event_PreProc_RunEvent

    on lightning strikes:
    - define world '<c.world.name.to_lowercase>'
    - define target '<c.location.below.material.bukkit_enum.to_lowercase>'
    - define readPath 'lightning-strike'
    - inject instantly s@dRegions p:event_PreProc_Config
    - define cuboids '<c.location.cuboids>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
    - define eventHooks 'lightning-strikes'
    - inject instantly s@dRegions p:event_PreProc_RunEvent

    on leaves decay:
    - define world '<c.location.world.name.to_lowercase>'
    - define readPath 'leaf-decay'
    - inject instantly s@dRegions p:event_PreProc_Config
    - define cuboids '<c.location.cuboids>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
    - define eventHooks 'leaf-decay'
    - inject instantly s@dRegions p:event_PreProc_RunEvent

    on portal created:
    - define world '<c.world.name.to_lowercase>'
    - define readPath 'portal.create'
    - inject instantly s@dRegions p:event_PreProc_Config

    on potion splash:
    # This will cancel the splash if any entity is in a protected region!
    - define world '<c.location.world.name.to_lowercase>'
    - foreach <c.entities||li@> {
      - define cuboids '<def[value].location.cuboids>'
      - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
      - define eventHooks 'throwPotion'
      - inject instantly s@dRegions p:event_PreProc_RunEvent
      }

#
#  END World Events
##################################################
#
#  Player Events
#
#
#    on player clicks block:
#    - narrate "item <c.item||i@air>"
#    - narrate "mat <c.location.material.bukkit_enum||air>"
#    - narrate "type <c.click_type||unknown>"
#    - define world '<player.world.name.to_lowercase>'
#    - define cuboids '<c.cuboids>'
#    - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
#    - define allFlagScripts '<server.list_scripts.filter[starts_with[s@dRegions_Flag_]]||li@>'

#    - inject instantly s@dRegions p:use_<c.item||null>
#    - inject instantly s@dRegions p:playerClick_<c.type||null>

    on player chats:
    - define world '<player.world.name.to_lowercase>'
    - define cuboids '<player.location.cuboids>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
    - define eventHooks 'sendChat'
    - inject instantly s@dRegions p:event_PreProc_RunEvent

    on player destroys vehicle:
    - define world '<player.world.name.to_lowercase>'
    - define cuboids '<c.vehicle.location.cuboids>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
    - define eventHooks 'destroyVehicle'
    - inject instantly s@dRegions p:event_PreProc_RunEvent

    on player stands on:
    - define world '<player.world.name.to_lowercase>'
    - define cuboids '<c.cuboids>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
    - define eventHooks '<s@dRegions_Map_Interactions.yaml_key[block.<c.location.material.bukkit_enum||air>]||null>'
    - inject instantly s@dRegions p:event_PreProc_RunEvent

    on player right clicks block with boat:
    - define world '<player.world.name.to_lowercase>'
    - define cuboids '<c.cuboids>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
    - define eventHooks 'placeVehicle'
    - inject instantly s@dRegions p:event_PreProc_RunEvent

    on player right clicks with potion:
    - if !<c.item.potion_effect.is_splash||false> queue clear
    - define world '<player.world.name.to_lowercase>'
    - define cuboids '<player.location.cuboids>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
    - define eventHooks 'throwPotion'
    - inject instantly s@dRegions p:event_PreProc_RunEvent

    on player consumes potion:
    - define world '<player.world.name.to_lowercase>'
    - define cuboids '<player.location.cuboids>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
    - define eventHooks 'drinkPotion'
    - inject instantly s@dRegions p:event_PreProc_RunEvent

    on player right clicks block with armor_stand:
    - define world '<player.world.name.to_lowercase>'
    - define cuboids '<c.cuboids>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
    - define eventHooks 'Build'
    - inject instantly s@dRegions p:event_PreProc_RunEvent

    on player right clicks:
    - define blockEvent '<s@dRegions_Map_Interactions.yaml_key[block.<c.location.material.bukkit_enum||air>]||null>'
    - define world '<player.world.name.to_lowercase>'
    - define cuboids '<c.cuboids||<player.location.cursor_on[5].cuboids>>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
    - if <c.item.material.name.is[==].to[air]||true> {
      - define eventHooks '<def[blockEvent]>'
      }
      else {
      - define eventObj '<s@dRegions_Map_Interactions.yaml_key[block_withItem.<c.location.material.bukkit_enum||<player.location.cursor_on[5].material.bukkit_enum>>]||li@>'
      - if <def[eventObj].split[/].get[2].as_list.contains[<c.item.material.bukkit_enum>]||false> {
        - define eventHooks '<def[blockEvent]>|<def[eventObj].split[/].get[1]||null>'
        }
        else {
        - define eventHooks '<def[blockEvent]>'
        }
      }
    - inject instantly s@dRegions p:event_PreProc_RunEvent

    on player enters bed:
    - define world '<player.world.name.to_lowercase>'
    - define cuboids '<c.location.cuboids>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
    - define eventHooks 'sleep'
    - inject instantly s@dRegions p:event_PreProc_RunEvent

    on player enters notable cuboid:
    - define world '<player.world.name.to_lowercase>'
    - define cuboids '<c.cuboids>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegions
    - define isEnter ''
    - define eventHooks 'regionEnter|regionToggle'
    - inject instantly s@dRegions p:event_PreProc_RunEvent

    on player exits notable cuboid:
    - define world '<player.world.name.to_lowercase>'
    - define cuboids '<c.cuboids>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegions
    - define isExit ''
    - define eventHooks 'regionExit|regionToggle'
    - inject instantly s@dRegions p:event_PreProc_RunEvent

    on player breaks block:
    - define world '<player.world.name.to_lowercase>'
    - define target '<c.material.bukkit_enum.to_lowercase>'
    - define cuboids '<c.cuboids>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
    - define eventHooks 'blockBreak|build'
    - inject instantly s@dRegions p:event_PreProc_RunEvent

    on player places block:
    - define world '<player.world.name.to_lowercase>'
    - define target '<c.material.bukkit_enum.to_lowercase>'
    - define cuboids '<c.cuboids>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
    - define eventHooks 'blockPlace|build'
    - inject instantly s@dRegions p:event_PreProc_RunEvent

    on player empties bucket:
    - define world '<player.world.name.to_lowercase>'
    - define cuboids '<c.location.cuboids>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
    - define eventHooks 'emptyBucket|build'
    - inject instantly s@dRegions p:event_PreProc_RunEvent

    on player fills bucket:
    - define world '<player.world.name.to_lowercase>'
    - define cuboids '<c.location.cuboids>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
    - define eventHooks 'fillBucket|build'
    - inject instantly s@dRegions p:event_PreProc_RunEvent

    on player drops item:
    - define world '<player.world.name.to_lowercase>'
    - define cuboids '<player.location.cuboids.include[<c.location.cuboids>].deduplicate>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
    - define eventHooks 'player-drop'
    - inject instantly s@dRegions p:event_PreProc_RunEvent

    on player picks up item:
    - define world '<player.world.name.to_lowercase>'
    - define cuboids '<player.location.cuboids.include[<c.location.cuboids>].deduplicate>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
    - define eventHooks 'player-pickup'
    - inject instantly s@dRegions p:event_PreProc_RunEvent

    on player places hanging:
    - define world '<player.world.name.to_lowercase>'
    - define cuboids '<c.location.cuboids>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
    - define eventHooks 'hangingPlace|build'
    - inject instantly s@dRegions p:event_PreProc_RunEvent

    on player right clicks at armor_stand:
    - define world '<player.world.name.to_lowercase>'
    - define cuboids '<c.entity.location.cuboids>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
    - define eventHooks 'build'
    - inject instantly s@dRegions p:event_PreProc_RunEvent

    on player right clicks item_frame:
    - define world '<player.world.name.to_lowercase>'
    - define cuboids '<c.entity.location.cuboids>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
    - define eventHooks 'useFrame|build'
    - inject instantly s@dRegions p:event_PreProc_RunEvent

    on player damages item_frame:
    - define world '<player.world.name.to_lowercase>'
    - define cuboids '<c.entity.location.cuboids>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
    - define eventHooks 'useFrame|build'
    - inject instantly s@dRegions p:event_PreProc_RunEvent

    on player clicks block with bone_meal:
    - define world '<player.world.name.to_lowercase>'
    - define cuboids '<c.cuboids>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
    - define eventHooks 'bonemeal|build'
    - inject instantly s@dRegions p:event_PreProc_RunEvent

    on player damaged:
    - if <player.has_flag[dRegions_cancelDamage_<c.cause>]||false> {
      - adjust <player> 'fire_time:0'
      - determine cancelled
      }
    - define world '<c.entity.world.name.to_lowercase>'
    - define cuboids '<c.entity.location.cuboids>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
    - define eventHooks 'playerDamaged'
    - inject instantly s@dRegions p:event_PreProc_RunEvent


#
#  END Player Events
##################################################
#
#  Mob Events
#
#
    on entity targets:
    - define world '<c.entity.world.name.to_lowercase>'
    - define cuboids '<c.target.location.cuboids||li@>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
    - define attacker '<c.entity>'
    - define defender '<c.target||null>'
    - define eventHooks '<c.entity.prefix>_Target_<c.target.prefix||null>'
    - inject instantly s@dRegions p:event_PreProc_RunEvent

    on entity damaged by block_explosion:
    - define world '<c.entity.world.name.to_lowercase>'
    - define cuboids '<c.entity.location.cuboids>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
    - define eventHooks 'entity-explode'
    - inject instantly s@dRegions p:event_PreProc_RunEvent

    on entity damages entity:
    - define world '<c.entity.world.name.to_lowercase>'
    - define cuboids '<c.entity.location.cuboids>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
    - define attacker '<c.damager>'
    - define defender '<c.entity>'
    - if <c.cause.is[==].to[entity_explosion]> {
      - define target '<def[attacker].entity_type||other>'
      - define eventHooks 'entity-explode|Entity_Target_Entity|Entity_Damage_Entity'
      }
      else {
      - define eventHooks '<tern[<c.entity.entity_type.is[==].to[armor_stand]>]:<tern[<c.damager.prefix.is[==].to[player]>]:Build||Entity_Target_Entity|Entity_Damage_Entity>||<c.damager.prefix>_Target_<c.entity.prefix>|<c.damager.prefix>_Damage_<c.entity.prefix>>'
      }
    - inject instantly s@dRegions p:event_PreProc_RunEvent

    on entity dies:
    - define world '<c.entity.world.name.to_lowercase>'
    - define cuboids '<c.entity.location.cuboids>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
    - define target '<c.entity.entity_type>'
    - define eventHooks '<c.entity.prefix>Dies'
    - inject instantly s@dRegions p:event_PreProc_RunEvent

    on entity spawns:
    - define world '<c.entity.world.name.to_lowercase>'
    - define cuboids '<c.cuboids>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
    - define target '<c.entity.entity_type>'
    - define eventHooks '<c.entity.prefix>_Spawn'
# This could be handy later, but right now the entity spawns event is powered
# by CretureSpawnEvent which only cares about living entities.
#    - define eventHooks '<t[<c.entity.is_living>]:Mob_Spawn||Entity_Spawn>'
    - inject instantly s@dRegions p:event_PreProc_RunEvent

    on entity enters portal:
    - define world '<c.world.name.to_lowercase>'
    - define readPath 'portal.<c.entity.as_player.prefix||<c.entity.prefix>>-enter'
    - inject instantly s@dRegions p:event_PreProc_Config

    on entity changes block:
    - define world '<c.location.world.name.to_lowercase>'
    - if <c.entity.entity_type.is[==].to[falling_block]> {
      - define readPath 'physics.<c.entity.fallingblock_material.bukkit_enum.to_lowercase>'
      - define eventHooks 'physics-<c.entity.fallingblock_material.bukkit_enum.to_lowercase>'
      }
      else if <c.old_material.bukkit_enum.is[==].to[soil]||false> {
      - define readPath 'trample-crops.<c.entity.prefix||entity>'
      - define eventHooks 'trample-crops-<c.entity.prefix||entity>'
      }
      else {
      - define readPath 'entity.changeBlock'
      - define target '<c.entity.entity_type||other>'
      - define eventHooks 'entity-changeBlock'
      }
    - inject instantly s@dRegions p:event_PreProc_Config
    - define cuboids '<c.location.cuboids>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
    - inject instantly s@dRegions p:event_PreProc_RunEvent

    on entity explodes:
    - define world '<c.location.world.name.to_lowercase>'
    - define readPath 'entity.explode'
    - define attacker '<c.entity>'
    - define target '<c.entity.entity_type||other>'
    - inject instantly s@dRegions p:event_PreProc_Config
    - define cuboids '<c.location.cuboids>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
    - define eventHooks 'entity-explode'
    - inject instantly s@dRegions p:event_PreProc_RunEvent

    on entity breaks hanging:
    - define world '<c.entity.world.name.to_lowercase>'
    - define readPath '<c.entity.prefix.to_lowercase||null>-break-<c.hanging.entity_type.to_lowercase>'
    - inject instantly s@dRegions p:event_PreProc_Config
    - define cuboids '<c.hanging.location.cuboids>'
    - inject instantly s@dRegions p:event_PreProc_OrderRegionsGlobal
    - define eventHooks '<t[<c.entity.is_player||false>]:hangingBreak|build||<c.entity.prefix.to_lowercase||null>-break-<c.hanging.entity_type.replace[_].to_lowercase>>'
    - inject instantly s@dRegions p:event_PreProc_RunEvent



#
#  END Mob Events
##################################################
#
#  Utility Subscripts
#

  start:
    - inject locally loadYaml instantly


  event_PreProc_Config:
  # Reusable code block injected from events.
  # This pre-processor handles events in the global and world config files before
  # any regions even get a chance. World configs are processed before global.
  # This way worlds can deny events that global allows, but global has ultimate
  # control for denying events. Denying an event takes precedence over allowing.
  # Default is 'true' on most events for this reason.
  #
  # Events that take a block list are handled here as well. Blocklists can
  # operate in whitelist or blacklist modes.
  #
  # Blacklist mode.
  # When an event is set to 'false' and no blocks are specified in the
  # blocklist, it will always cancel the event. If there are blocks specified,
  # it will only cancel events involving those blocks listed.
  #
  # Whitelist mode.
  # When an event is set to 'true' and no blocks are specified in the blocklist,
  # it will always allow the event. If there are blocks specifed, it will only
  # allow events involving those blocks listed.
  #
    - foreach '<el@val[%world%|global].as_list>' {
      - define settingValue '<yaml[dRegions_%value%_config].read[config.%readPath%]||true>'
      - define targetList '<yaml[dRegions_%value%_config].read[config.%readPath%-list]||li@>'
      - if <def[settingValue]||true> {
        - if !<def[targetList].is_empty||true> {
          - if !<def[targetList].contains[<def[target]>]||true> {
            - determine CANCELLED
            }
          }
        }
        else {
        - if <def[targetList].is_empty||true> {
          - determine CANCELLED
          }
          else {
          - if <def[targetList].contains[<def[target]>]||false> {
            - determine CANCELLED
            }
          }
        }
      }


  event_PreProc_OrderRegionsGlobal:
  # Reusable code block injected from events.
  # This pre-processor returns %orderedRegions% including the __global__ region.
    - define dRegions '<def[cuboids].parse[notable_name].filter[split[_].get[1].is[==].to[dRegions]].parse[after[dregions_%world%_]].include[__global__].replace[li@].replace[|].with[,]||null>'
    - define orderedRegions '<proc[dRegions_HighestPriority].context[%world%|%dRegions%]||li@>'


  event_PreProc_OrderRegions:
  # Reusable code block injected from events.
  # This pre-processor returns %orderedRegions% excluding the __global__ region.
  # It stops processing if there are no regions present.
#    - narrate "PreProcLoad"
    - define dRegions '<def[cuboids].parse[notable_name].filter[split[_].get[1].is[==].to[dRegions]].parse[after[dregions_%world%_]].replace[li@].replace[|].with[,]||null>'
    - if <def[dRegions].is[==].to[null]||true> {
      - queue clear
      }
    - define orderedRegions '<proc[dRegions_HighestPriority].context[%world%|%dRegions%]||li@>'


  event_preProc_RunEvent:
  # Reusable code block injected from events. It's the final pre-processor
  # before the flags take over.
  # From all the flag scripts that exist, it filters out only those that have an
  # event hook registered for this event.
  # It then gets the event priority for each and builds a split list for each
  # event: priority/flagscript. This makes it easy to run the flag scripts in
  # order from lowest priority to highest. We just sort the list alphanumerically
  # and drop the priority value from the list.
  # Now that we have the orderedEvents we can inject each FlagScript in order.
  #
    - define eventHooks '<def[eventHooks].as_list.exclude[null]||li@>'
    - if <def[eventHooks].is_empty||true> {
      - queue clear
      }
    - define allFlagScripts '<server.list_scripts.filter[starts_with[s@dRegions_Flag_]]||li@>'
    - define Flags '<def[allFlagScripts].filter[yaml_key[event_hook].contains_any[%eventHooks%]]||li@>'
    - define eventPri '<def[Flags].parse[yaml_key[event_priority]]||li@>'
    - define eventList 'li@'
    - foreach <def[Flags]> {
      - define eventList '<def[eventList].include[<def[eventPri].get[%loop_index%]>/%value%]>'
      }
    - define orderedEvents '<def[eventList].alphanumeric.parse[split[/].get[2]]||li@>'
    - foreach <def[orderedEvents]> {
      - define FlagScript '%value%'
      - inject %value% p:event
      }


  loadYaml:
  # Reloads the yaml files and generates default files if they don't exist.
  # Rewrites config files that do not match internal version number!
    - announce "<&b>dRegions<&co><&3> Loading system config files..." to_console
    - define world 'global'
    - define file 'config'
    - if !<server.has_file[dRegions/config.yml]> {
      - if <player.is[!=].to[null]||false> {
        - flag <player> ConfigFileGeneratorNotify:true
        - inject locally createConfigFile instantly
        - flag <player> ConfigFileGeneratorNotify:!
        - run instantly s@dRegions_Msg 'def:<&7><&o>Created <&f><&o>%world%<&7><&o> config file!'
        }
        else {
        - inject locally createConfigFile instantly
        }
      - announce "<&b>dRegions<&co> <&7><&o>Created <&f><&o>%world%<&7><&o> config file!" to_console
      }
    - if <yaml.list.contains[dRegions_global_config]> yaml unload 'id:dRegions_global_config'
    - yaml 'load:dRegions/config.yml' 'id:dRegions_global_config'

    - if <yaml[dRegions_<def[world]>_config].read[config.version].is[!=].to[<s@dRegions_Configurations.yaml_key[config.version]>]||false> {
      - define isUpdate ''
      - if <player.is[!=].to[null]||false> {
        - flag <player> ConfigFileGeneratorNotify:true
        - inject locally createConfigFile instantly
        - flag <player> ConfigFileGeneratorNotify:!
        - run instantly s@dRegions_Msg 'def:<&7><&o>Updated <&f><&o>%world%<&7><&o> config file!'
        }
        else {
        - inject locally createConfigFile instantly
        }
      - define isUpdate:!
      - announce "<&b>dRegions<&co> <&7><&o>Updated <&f><&o>%world%<&7><&o> config file!" to_console
      }

    - foreach <server.list_worlds.parse[name.to_lowercase]> {
      - define world '<def[value]>'
      - define file 'worlds/%world%/config'

      - if !<server.has_file[dRegions/%file%.yml]> {
        - if <player.is[!=].to[null]||false> {
          - flag <player> ConfigFileGeneratorNotify:true
          - inject locally createConfigFile instantly
          - flag <player> ConfigFileGeneratorNotify:!
          - run instantly s@dRegions_Msg 'def:<&7><&o>Created <&f><&o>%world%<&7><&o> config file!'
          }
          else inject locally createConfigFile instantly
        - announce "<&b>dRegions<&co> <&7><&o>Created <&f><&o>%world%<&7><&o> config file!" to_console
        }
      - if <yaml.list.contains[dRegions_%world%_config]> yaml unload 'id:dRegions_%world%_config'
      - yaml 'load:dRegions/%file%.yml' 'id:dRegions_%world%_config'

      - if <yaml[dRegions_<def[world]>_config].read[config.version].is[!=].to[<s@dRegions_Configurations.yaml_key[config.version]>]||false> {
        - define isUpdate ''
        - if <player.is[!=].to[null]||false> {
          - flag <player> ConfigFileGeneratorNotify:true
          - inject locally createConfigFile instantly
          - flag <player> ConfigFileGeneratorNotify:!
          - run instantly s@dRegions_Msg 'def:<&7><&o>Updated <&f><&o>%world%<&7><&o> config file!'
          }
          else {
          - inject locally createConfigFile instantly
          }
        - define isUpdate:!
        - announce "<&b>dRegions<&co> <&7><&o>Updated <&f><&o>%world%<&7><&o> config file!" to_console
        }

      - define file 'worlds/%world%/regions'
      - if !<server.has_file[dRegions/%file%.yml]> {
        - define region '__global__'
        - if <player.is[!=].to[null]||false> {
          - flag <player> ConfigFileGeneratorNotify:true
          - inject locally createRegionFile instantly
          - flag <player> ConfigFileGeneratorNotify:!
          - run instantly s@dRegions_Msg 'def:<&7><&o>Created <&f><&o>%world%<&7><&o> regions file!'
          }
          else inject locally createRegionFile instantly
        - announce "<&b>dRegions<&co> <&7><&o>Created <&f><&o>%world%<&7><&o> regions file!" to_console
        }
      - if <yaml.list.contains[dRegions_%world%_regions]> yaml unload 'id:dRegions_%world%_regions'
      - yaml 'load:dRegions/%file%.yml' 'id:dRegions_%world%_regions'

      - define file 'worlds/%world%/inventories'
      - if !<server.has_file[dRegions/%file%.yml]> {
        - define region '__global__'
        - if <player.is[!=].to[null]||false> {
          - flag <player> ConfigFileGeneratorNotify:true
          - inject locally createRegionFile instantly
          - flag <player> ConfigFileGeneratorNotify:!
          - run instantly s@dRegions_Msg 'def:<&7><&o>Created <&f><&o>%world%<&7><&o> regions file!'
          }
          else inject locally createInventoryFile instantly
        - announce "<&b>dRegions<&co> <&7><&o>Created <&f><&o>%world%<&7><&o> inventory file!" to_console
        }
      - if <yaml.list.contains[dRegions_%world%_inventories]> yaml unload 'id:dRegions_%world%_inventories'
      - yaml 'load:dRegions/%file%.yml' 'id:dRegions_%world%_inventories'
      }
    - announce "<&b>dRegions<&co><&a> System config files Loaded!" to_console


  reloadYaml:
  # A simpler reload
    - announce "<&b>dRegions<&co><&3> Reloading system config files..." to_console
    - run instantly s@dRegions_Msg 'def:<&7><&o>Reloading system config files...'
    - if <yaml.list.contains[dRegions_global_config]> yaml unload 'id:dRegions_global_config'
    - yaml 'load:dRegions/config.yml' 'id:dRegions_global_config'
    - foreach <server.list_worlds.parse[name.to_lowercase]> {
      - define world '<def[value]>'
      - if <yaml.list.contains[dRegions_%world%_config]> yaml unload 'id:dRegions_%world%_config'
      - yaml 'load:dRegions/worlds/%world%/config.yml' 'id:dRegions_%world%_config'
      - if <yaml.list.contains[dRegions_%world%_regions]> yaml unload 'id:dRegions_%world%_regions'
      - yaml 'load:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - if <yaml.list.contains[dRegions_%world%_inventories]> yaml unload 'id:dRegions_%world%_inventories'
      - yaml 'load:dRegions/worlds/%world%/inventories.yml' 'id:dRegions_%world%_inventories'
      }
    - announce "<&b>dRegions<&co><&a> System config files Loaded!" to_console
    - run instantly s@dRegions_Msg 'def:<&7><&o>System config files Loaded!'


  createConfigFile:
    - define readID 'dRegions_Configurations'
    - define writeID 'dRegions_%world%_config'
    - if !<yaml.list.contains[%readID%]> yaml fix_formatting 'load:<script.relative_filename>' 'id:%readID%'
    - if !<yaml.list.contains[%readID%]> announce to_console "Loaded <script.relative_filename>"
    - yaml create 'id:%writeID%'
    - define readPath '%readID%.config'
    - define writePath 'config'
    - if <def[isUpdate].exists||false> {
      - run s@ConfigFileGenerator def:%readID%|%writeID%|%readPath%|%writePath%|false|false|true instantly
      }
      else {
      - run s@ConfigFileGenerator def:%readID%|%writeID%|%readPath%|%writePath%|false|false|false instantly
      }
    - yaml unload 'id:%readID%'
    - yaml 'savefile:dRegions/%file%.yml' 'id:%writeID%'


  createRegionFile:
    - define readID 'dRegions_Configurations'
    - define writeID 'dRegions_%world%_regions'
    - if !<yaml.list.contains[%readID%]> yaml fix_formatting 'load:<script.relative_filename>' 'id:%readID%'
    - yaml create 'id:%writeID%'
    - define readPath '%readID%.regions.__global__'
    - define writePath 'regions.%region%'
    - run s@ConfigFileGenerator def:%readID%|%writeID%|%readPath%|%writePath%|false|false|false instantly
    - yaml unload 'id:%readID%'
    - yaml 'savefile:dRegions/%file%.yml' 'id:%writeID%'


  createInventoryFile:
    - define readID 'dRegions_Configurations'
    - define writeID 'dRegions_%world%_inventories'
    - if !<yaml.list.contains[%readID%]> yaml fix_formatting 'load:<script.relative_filename>' 'id:%readID%'
    - yaml create 'id:%writeID%'
    - define readPath '%readID%.inventories'
    - define writePath 'inventories'
    - run s@ConfigFileGenerator def:%readID%|%writeID%|%readPath%|%writePath%|false|false|false instantly
    - yaml unload 'id:%readID%'
    - yaml 'savefile:dRegions/%file%.yml' 'id:%writeID%'


  createRegionEntry:
    - if !<yaml.list.contains[dRegions_%world%_regions]> yaml 'load:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
    - yaml set 'regions.%name%.type:cuboid' 'id:dRegions_%world%_regions'
    - yaml set 'regions.%name%.min:<def[selectedCuboid].min.simple>' 'id:dRegions_%world%_regions'
    - yaml set 'regions.%name%.max:<def[selectedCuboid].max.simple>' 'id:dRegions_%world%_regions'
    - yaml set 'regions.%name%.priority:0' 'id:dRegions_%world%_regions'
    - yaml set 'regions.%name%.flags:|:' 'id:dRegions_%world%_regions'
    - yaml set 'regions.%name%.owners:|:' 'id:dRegions_%world%_regions'
    - foreach <def[ownerGroups]||li@> {
      - yaml set 'regions.%name%.owners.groups:->:%value%' 'id:dRegions_%world%_regions'
      }
    - foreach <def[ownerPlayers]||li@> {
      - yaml set 'regions.%name%.owners.players:->:%value%' 'id:dRegions_%world%_regions'
      }
    - yaml set 'regions.%name%.members:|:' 'id:dRegions_%world%_regions'
    - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
    - note cu@<def[selectedCuboid].min.simple>|<def[selectedCuboid].max.simple> 'as:dregions_%world%_%name%'


#
#  END Utility Subscripts
##################################################
#
#  Message format
#


dRegions_Msg:
  type: item
  debug: false
  material: i@human_skull
  display name: "<&4>  [<&6>dRegions<&4>]"
  lore:
  - <&5>Click for Help
  script:
    - ^define text '<&4>[<&6>dRegions<&4>]'
    - ^define hover '<&chr[007B]><i@dRegions_Msg.json><&chr[007D]>'
    - ^define click '/dregions help'
    - ^define button "text:'%text%',clickEvent:<&chr[007B]>action:run_command,value:'%click%'<&chr[007D]>,hoverEvent:<&chr[007B]>action:show_item,value:'%hover%'<&chr[007d]>"
    - ^define spacer "text:'  '"
    - ^define msg "text:'%1%'"
    - ^if <player.is_player||false> {
      - execute as_server "tellraw <player.name> <&chr[007B]>text:'',extra:[<&chr[007B]>%button%<&chr[007D]>,<&chr[007B]>%spacer%<&chr[007D]>,<&chr[007B]>%msg%<&chr[007D]>]<&chr[007D]>"
      }
      else {
      - announce to_console "%1%"
      }


################################################################################
#
#  dRegions Command Script Container
#
# This script covers all dRegions commands
#
#
#
#--------------------------------------
#
#  dRegions Command Script Basics
#
# The basic stuff required in a command script container
#
dRegions_Commands:
  type: command
  debug: false
  name: dregions
  description: Denizen Regions Manager
  usage: /dregions
  aliases:
  - drg
  allowed help:
  - determine true

  commandArgs:
    help:
      usage: '/drg help <&lt>arg/<&ns><&gt>'
      permissions: []
    about:
      usage: '/drg about'
      permissions: []
    reload:
      usage: '/drg reload'
      permissions: []
    restart:
      usage: '/drg restart'
      permissions: []
    define:
      usage: '/drg define [ID] (g:group) (player)'
      permissions: []
    redefine:
      usage: '/drg redefine [ID]'
      permissions: []
    claim:
      usage: '/drg claim [ID]'
      permissions: []
    select:
      usage: '/drg select [ID] -w world'
      permissions: []
    info:
      usage: '/drg info [ID] -w world'
      permissions: []
    addowner:
      usage: '/drg addowner [ID] g:group player -w world'
      permissions: []
    removeowner:
      usage: '/drg removeowner [ID] g:group player -w world'
      permissions: []
    addmember:
      usage: '/drg addmember [ID] g:group player -w world'
      permissions: []
    removemember:
      usage: '/drg removemember [ID] g:group player -w world'
      permissions: []
    list:
      usage: '/drg list (page<&ns>) -h -r region -w world -p player'
      permissions: []
    flag:
      usage: '/drg flag [ID] [flag] [value] -g group -w world'
      permissions: []
    setpriority:
      usage: '/drg setpriority [ID] [<&ns>]'
      permissions: []
    setparent:
      usage: '/drg setparent [ID] [parent]'
      permissions: []
    teleport:
      usage: '/drg teleport [ID] -w world'
      permissions: []
    remove:
      usage: '/drg remove [ID] -w world'
      permissions: []

  tab complete:
    - define args '<script.list_keys[commandArgs].alphanumeric.to_lowercase||li@>'
    - define arg '<c.args.get[1]||null>'
    - if <def[arg].is[==].to[null]>
      || !<def[args].contains[%arg%]> {
      - inject locally tab_arg_1
      }
      else inject locally tab_%arg%
    - determine '<def[result]||li@>'

  script:
    - define command '<c.args.get[1].escaped||help>'
    - define args '<script.list_keys[commandArgs].alphanumeric.to_lowercase||li@>'
    - if !<def[args].contains[%command%]> inject locally help instantly
      else inject locally %command% instantly


#
#  END dRegions Command Script Basics
#--------------------------------------
#
#  dRegions Command TAB Completion
#
# Each of these subscripts handles TAB completion for the positional argument.
#
#
  tab_arg_1:
    # This Excludes args from the original args
    - foreach %args% {
      - if !<player.has_permission[dregions.%value%]||<player.is_op||false>> define args '<def[args].exclude[%value%]||%args%>'
      }
    - if <def[args].is_empty||true> define result 'li@'
      else {
      - define result '<def[args].filter[starts_with[%arg%]]||li@> '
      - if <def[result].is_empty||true> define result '%args%'
      }

  tab_help:
    - define spaces '<c.raw_args.to_list.count[ ]||0>'
    - if <def[spaces].is[==].to[0]> define result 'help [command]'
      else if <def[spaces].is[==].to[1]> {
      - define result 'li@'
      - foreach %args% {
        - if <player.has_permission[dregions.%value%]||<player.is_op||false>> {
          - define result '<def[result].include[%value%]||%result%>'
          }
          else foreach next
        }
      - if <c.args.get[2].is[!=].to[null]||false> {
        - define result '<def[args].filter[starts_with[<c.args.get[2]>]]||li@>'
        - if <def[result].is_empty> {
          - foreach %args% {
            - if <player.has_permission[dregions.%value%]||<player.is_op||false>> {
              - define result '<def[result].include[%value%]||%result%>'
              }
              else foreach next
            }
          }
        }
      }

  tab_about:
    - define result 'li@'

  tab_reload:
    - define result 'li@'

  tab_restart:
    - define result 'li@'

  tab_define:
  # /drg define [ID] (g:group) (player)
    - if <player.has_permission[dregions.define]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - if <def[spaces].is[==].to[0]> define result 'define [ID]'
        else if <def[spaces].is[==].to[1]> {
        - if <c.args.get[2].is[==].to[null]||true> define result '[ID] (g:group) (player)'
          else define result '<c.args.get[2]> (g:group) (player)'
          }
        else if <def[spaces].is[OR_MORE].than[2]> {
        - define owners '<c.args.remove[1|2]||li@>'
        - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
          - define owners '<def[owners].remove[<def[owners].find[-w]>|<def[owners].find[-w].add[1].as_int>]||li@>'
          }
        - define owner '<def[owners].last||li@>'
        - if <def[owner].starts_with[g:]||false> {
          - define group '<def[owner].replace[g:]>'
          - define groups '<server.list_permission_groups.filter[starts_with[%group%]]||li@>'
          - if <def[groups].is_empty> define groups '<server.list_permission_groups||li@>'
          - define result '<def[groups].parse[replace[regex:^].with[g:]]>'
          }
          else {
          - define result '<server.match_player[%owner%].name||null>'
          - if <def[result].is[==].to[null]||true> define result '<server.list_online_players.parse[name]>'
          }
        }
        else define result 'li@'
      }
      else define result 'li@'

  tab_redefine:
  # /drg redefine [ID]
    - if <player.has_permission[dregions.redefine]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
      - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
      - if !<player.has_permission[dregions.admin]||<player.is_op||true>> {
        - foreach %regions% {
          - if <proc[dRegions_IsOwner].context[%value%|%world%|<player>].not> define regions '<def[regions].exclude[%value%]||%regions%>'
          }
        }
      - if <def[spaces].is[==].to[0]> define result '<def[regions].parse[replace[regex:^].with[redefine ]]>'
        else if <def[spaces].is[==].to[1]> {
        - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||li@>'
        - if <def[result].is_empty||true> define result '%regions%'
        }
        else define result 'li@'
      }
      else define result 'li@'

  tab_claim:
    - if <player.has_permission[dregions.claim]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
      - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
      - if !<player.has_permission[dregions.admin]||<player.is_op||false>> {
        - foreach %regions% {
          - if <proc[dRegions_IsOwner].context[%value%|%world%|<player>].not> define regions '<def[regions].exclude[%value%]||%regions%>'
          }
        }
      - if <def[spaces].is[==].to[0]> define result '<def[regions].parse[replace[regex:^].with[claim ]]>'
        else if <def[spaces].is[==].to[1]> {
        - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||li@>'
        - if <def[result].is_empty||true> define result '%regions%'
        }
        else define result 'li@'
      }
      else define result 'li@'

  tab_select:
  # /drg select [ID] -w world
    - if <player.has_permission[dregions.select]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
      - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
      - if !<player.has_permission[dregions.admin]||<player.is_op||false>> {
        - foreach %regions% {
          - if <proc[dRegions_IsOwner].context[%value%|%world%|<player>].not> define regions '<def[regions].exclude[%value%]||%regions%>'
          }
        }
      - if <def[spaces].is[==].to[0]> define result '<def[regions].parse[replace[regex:^].with[select ]]>'
        else if <def[spaces].is[==].to[1]> {
        - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||li@>'
        - if <def[result].is_empty||true> define result '%regions%'
        }
        else define result 'li@'
      }
      else define result 'li@'

  tab_info:
  # /drg info [ID] -w world
    - if <player.has_permission[dregions.info]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
      - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
      - if !<player.has_permission[dregions.admin]||<player.is_op||false>> {
        - foreach %regions% {
          - if <proc[dRegions_IsOwner].context[%value%|%world%|<player>].not> define regions '<def[regions].exclude[%value%]||%regions%>'
          }
        }
      - if <def[spaces].is[==].to[0]> define result '<def[regions].parse[replace[regex:^].with[info ]]>'
        else if <def[spaces].is[==].to[1]> {
        - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||li@>'
        - if <def[result].is_empty||true> define result '%regions%'
        }
        else define result 'li@'
      }
      else define result 'li@'

  tab_addowner:
  # /drg addowner [ID] g:group player -w world
    - if <player.has_permission[dregions.addowner]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
      - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
      - if !<player.has_permission[dregions.admin]||<player.is_op||false>> {
        - foreach %regions% {
          - if <proc[dRegions_IsOwner].context[%value%|%world%|<player>].not> define regions '<def[regions].exclude[%value%]||%regions%>'
          }
        }
      - if <def[spaces].is[==].to[0]> define result '<def[regions].parse[replace[regex:^].with[addowner ]]>'
        else if <def[spaces].is[==].to[1]> {
        - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||li@>'
        - if <def[result].is_empty||true> define result '%regions%'
        }
        else if <def[spaces].is[OR_MORE].than[2]> {
        - define owners '<c.args.remove[1|2]||li@>'
        - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
          - define owners '<def[owners].remove[<def[owners].find[-w]>|<def[owners].find[-w].add[1].as_int>]||li@>'
          }
        - define owner '<def[owners].last||li@>'
        - if <def[owner].starts_with[g:]||false> {
          - define group '<def[owner].replace[g:]>'
          - define groups '<server.list_permission_groups.filter[starts_with[%group%]]||li@>'
          - if <def[groups].is_empty> define groups '<server.list_permission_groups.alphanumeric||li@>'
          - define result '<def[groups].parse[replace[regex:^].with[g:]]>'
          }
          else {
          - define result '<server.match_player[%owner%].name||null>'
          - if <def[result].is[==].to[null]||true> define result '<server.list_online_players.parse[name].alphanumeric>'
          }
        }
        else define result 'li@'
      }
      else define result 'li@'

  tab_removeowner:
  # /drg removeowner [ID] g:group player -w world
    - if <player.has_permission[dregions.removeowner]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
      - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
      - if !<player.has_permission[dregions.admin]||<player.is_op||false>> {
        - foreach %regions% {
          - if <proc[dRegions_IsOwner].context[%value%|%world%|<player>].not> define regions '<def[regions].exclude[%value%]||%regions%>'
          }
        }
      - if <def[spaces].is[==].to[0]> define result '<def[regions].parse[replace[regex:^].with[removeowner ]]>'
        else if <def[spaces].is[==].to[1]> {
        - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||li@>'
        - if <def[result].is_empty||true> define result '%regions%'
        }
        else if <def[spaces].is[OR_MORE].than[2]> {
        - define owners '<c.args.remove[1|2]||li@>'
        - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
          - define owners '<def[owners].remove[<def[owners].find[-w]>|<def[owners].find[-w].add[1].as_int>]||li@>'
          }
        - define owner '<def[owners].last||li@>'
        - if <def[owner].starts_with[g:]||false> {
          - define group '<def[owner].replace[g:]>'
          - define groups '<server.list_permission_groups.filter[starts_with[%group%]]||li@>'
          - if <def[groups].is_empty> define groups '<server.list_permission_groups.alphanumeric||li@>'
          - define result '<def[groups].parse[replace[regex:^].with[g:]]>'
          }
          else {
          - define result '<server.match_player[%owner%].name||null>'
          - if <def[result].is[==].to[null]||true> define result '<server.list_online_players.parse[name].alphanumeric>'
          }
        }
        else define result 'li@'
      }
      else define result 'li@'

  tab_addmember:
  # /drg addmember [ID] g:group player -w world
    - if <player.has_permission[dregions.addmember]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
      - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
      - if !<player.has_permission[dregions.admin]||<player.is_op||false>> {
        - foreach %regions% {
          - if <proc[dRegions_IsOwner].context[%value%|%world%|<player>].not> define regions '<def[regions].exclude[%value%]||%regions%>'
          }
        }
      - if <def[spaces].is[==].to[0]> define result '<def[regions].parse[replace[regex:^].with[addmember ]]>'
        else if <def[spaces].is[==].to[1]> {
        - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||li@>'
        - if <def[result].is_empty||true> define result '%regions%'
        }
        else if <def[spaces].is[OR_MORE].than[2]> {
        - define members '<c.args.remove[1|2]||li@>'
        - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
          - define members '<def[members].remove[<def[members].find[-w]>|<def[members].find[-w].add[1].as_int>]||li@>'
          }
        - define member '<def[members].last||li@>'
        - if <def[member].starts_with[g:]||false> {
          - define group '<def[member].replace[g:]>'
          - define groups '<server.list_permission_groups.filter[starts_with[%group%]]||li@>'
          - if <def[groups].is_empty> define groups '<server.list_permission_groups.alphanumeric||li@>'
          - define result '<def[groups].parse[replace[regex:^].with[g:]]>'
          }
          else {
          - define result '<server.match_player[%owner%].name||null>'
          - if <def[result].is[==].to[null]||true> define result '<server.list_online_players.parse[name].alphanumeric>'
          }
        }
        else define result 'li@'
      }
      else define result 'li@'

  tab_removemember:
  # /drg removemember [ID] g:group player -w world
    - if <player.has_permission[dregions.removemember]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
      - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
      - if !<player.has_permission[dregions.admin]||<player.is_op||false>> {
        - foreach %regions% {
          - if <proc[dRegions_IsOwner].context[%value%|%world%|<player>].not> define regions '<def[regions].exclude[%value%]||%regions%>'
          }
        }
      - if <def[spaces].is[==].to[0]> define result '<def[regions].parse[replace[regex:^].with[removemember ]]>'
        else if <def[spaces].is[==].to[1]> {
        - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||li@>'
        - if <def[result].is_empty||true> define result '%regions%'
        }
        else if <def[spaces].is[OR_MORE].than[2]> {
        - define members '<c.args.remove[1|2]||li@>'
        - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
          - define members '<def[members].remove[<def[members].find[-w]>|<def[members].find[-w].add[1].as_int>]||li@>'
          }
        - define member '<def[members].last||li@>'
        - if <def[member].starts_with[g:]||false> {
          - define group '<def[member].replace[g:]>'
          - define groups '<server.list_permission_groups.filter[starts_with[%group%]]||li@>'
          - if <def[groups].is_empty> define groups '<server.list_permission_groups.alphanumeric||li@>'
          - define result '<def[groups].parse[replace[regex:^].with[g:]]>'
          }
          else {
          - define result '<server.match_player[%owner%].name||null>'
          - if <def[result].is[==].to[null]||true> define result '<server.list_online_players.parse[name].alphanumeric>'
          }
        }
        else define result 'li@'
      }
      else define result 'li@'

  tab_list:
    - define result 'li@'

  tab_flag:
  # TODO
  # /drg flag [ID] [flag] [value] -g group -w world
    - if <player.has_permission[dregions.flag]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - if <def[spaces].is[==].to[0]> define result 'flag [ID]'
        else if <def[spaces].is[==].to[1]> {
        - if <c.args.get[2].is[==].to[null]||true> define result '[ID]'
          else if <c.args.get[2].is[==].to[-w]||false> define result '<server.list_worlds.parse[name.to_lowercase].parse[replace[regex:^].with[-w ]]>'
          else if <context.server.not> {
          - define regions '<yaml[dRegions_<player.world.name.to_lowercase>_regions].list_keys[regions].alphanumeric||li@>'
          - if !<player.has_permission[dregions.admin]||<player.is_op||false>> {
            - foreach %regions% {
              - if <proc[dRegions_IsOwner].context[%value%|<player.world.name.to_lowercase>|<player>].not> define regions '<def[regions].exclude[%value%]||%regions%>'
              }
            }
          - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||li@>'
          - if <def[result].is_empty||true> define result '%regions%'
          }
          else define result 'li@'
        }
        else if <def[spaces].is[==].to[2]> {
        - if <c.args.get[2].is[==].to[-w]||false> {
          - if <c.args.get[3].is[!=].to[null]||false> define result '<server.list_worlds.parse[name.to_lowercase].filter[starts_with[<c.args.get[3].escaped>]]||li@>'
          - if <def[result].is_empty||true> define result '<server.list_worlds.parse[name.to_lowercase]||li@>'
          }
          else if <c.args.get[2].is[!=].to[null]||false> {
          - define allFlagScripts '<server.list_scripts.filter[starts_with[s@dRegions_Flag_]]||li@>'
          - define allFlags '<def[allFlagScripts].parse[name.split[_].get[3].to_lowercase].alphanumeric||li@>'
          - if <c.args.get[3].is[==].to[-w]||false> {
            - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
            - if <c.args.get[3].is[!=].to[null]||false> define result '<server.list_worlds.parse[name.to_lowercase].filter[starts_with[<c.args.get[3].escaped>]]||li@>'
            - if <def[result].is_empty||true> define result '<server.list_worlds.parse[name.to_lowercase].parse[replace[regex:^].with[-w ]]||li@>'
            }
            else if <c.args.get[3].is[!=].to[null]||false> {
            - define result '<def[allFlags].filter[starts_with[<c.args.get[3].escaped>]]||li@>'
            - if <def[result].is_empty||true> define result '<def[allFlags]||li@>'
            }
            else {
            - if <def[result].is_empty||true> define result '<def[allFlags]||li@>'
            }
          }
        }
        else if <def[spaces].is[==].to[3]> {
        - if <c.args.get[2].is[==].to[-w]||false> {
          - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
          - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].alphanumeric||li@>'
          - if <c.args.get[4].is[!=].to[null]||false> define result '<def[regions].filter[starts_with[<c.args.get[4].escaped>]]||li@>'
          - if <def[result].is_empty||true> define result '<def[regions]||li@>'
          }
          else if <c.args.get[3].is[==].to[-w]||false> {
          - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
          - if <c.args.get[4].is[!=].to[null]||false> define result '<server.list_worlds.parse[name.to_lowercase].filter[starts_with[<c.args.get[3].escaped>]].parse[replace[regex:^].with[-w ]]||li@>'
          - if <def[result].is_empty||true> define result '<server.list_worlds.parse[name.to_lowercase]||li@>'
          }
          else if <c.args.get[4].is[==].to[-w]||false> {
          - define result '<server.list_worlds.parse[name.to_lowercase].parse[replace[regex:^].with[-w ]]||li@>'
          }
        }
        else if <def[spaces].is[==].to[4]> {
        - if <c.args.get[4].is[==].to[-w]||false> {
          - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
          - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].alphanumeric||li@>'
          - if <c.args.get[5].is[!=].to[null]||false> define result '<server.list_worlds.parse[name.to_lowercase].filter[starts_with[<c.args.get[5].escaped>]]||li@>'
          - if <def[result].is_empty||true> define result '<server.list_worlds.parse[name.to_lowercase]||li@>'
          }
          else {
          - define allFlagScripts '<server.list_scripts.filter[starts_with[s@dRegions_Flag_]]||li@>'
          - define allFlags '<def[allFlagScripts].parse[name.split[_].get[3].to_lowercase].alphanumeric||li@>'
          - if <c.args.get[5].is[!=].to[null]||false> define result '<def[allFlags].filter[starts_with[<c.args.get[5].escaped>]]||li@>'
          - if <def[result].is_empty||true> define result '<def[allFlags]||li@>'
          }
        }
      }
      else {
      - define result 'li@'
      }

  tab_setpriority:
  # /drg remove [ID] -w world
    - if <player.has_permission[dregions.setpriority]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - if <def[spaces].is[==].to[0]> define result 'setpriority [ID]'
        else if <def[spaces].is[==].to[1]> {
        - if <c.args.get[2].is[==].to[null]||true> define result '[ID]'
          else if <c.args.get[2].is[==].to[-w]||false> define result '<server.list_worlds.parse[name.to_lowercase].parse[replace[regex:^].with[-w ]]>'
          else if <context.server.not> {
          - define regions '<yaml[dRegions_<player.world.name.to_lowercase>_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
          - if !<player.has_permission[dregions.admin]||<player.is_op||false>> {
            - foreach %regions% {
              - if <proc[dRegions_IsOwner].context[%value%|<player.world.name.to_lowercase>|<player>].not> define regions '<def[regions].exclude[%value%]||%regions%>'
              }
            - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||li@>'
            }
            else {
            - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||%regions%>'
            - if <def[result].is_empty> define result '%regions%'
            }
          }
          else define result 'li@'
        }
        else if <def[spaces].is[==].to[2]> {
        - if <c.args.get[2].is[==].to[-w]||false> {
          - if <c.args.get[3].is[!=].to[null]||false> define result '<server.list_worlds.parse[name.to_lowercase].filter[starts_with[<c.args.get[3].escaped>]]||li@>'
          - if <def[result].is_empty||true> define result '<server.list_worlds.parse[name.to_lowercase]||li@>'
          }
          else {
          - if <c.args.get[3].is[MATCHES].to[number]> {
            - define result '<c.args.get[3]>'
            }
            else if <c.args.get[3].is[==].to[-w]||false> {
            - define result '<server.list_worlds.parse[name.to_lowercase].parse[replace[regex:^].with[-w ]]||li@>'
            }
            else {
            - define result '<&ns>'
            }
          }
        }
        else if <def[spaces].is[==].to[3]> {
        - if <c.args.get[2].is[==].to[-w]||false> {
          - if <c.args.get[4].is[!=].to[null]||false> {
            - define regions '<yaml[dRegions_<c.args.get[3].escaped>_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
            - define result '<def[regions].filter[starts_with[<c.args.get[4].escaped>]]||li@>'
            - if <def[result].is_empty||true> define result '%regions%'
            }
            else define result '<yaml[dRegions_<c.args.get[3].escaped>_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
          }
          else if <c.args.get[3].is[==].to[-w]||false> {
          - define result '<server.list_worlds.parse[name.to_lowercase]||li@>'
          }
          else {
          - if <c.args.get[4].is[!=].to[null]||false> define result '<server.list_worlds.parse[name.to_lowercase].filter[starts_with[<c.args.get[4].escaped>]]||li@>'
            else define result '<server.list_worlds.parse[name].parse[replace[regex:^].with[-w ]]||li@>'
          - if <def[result].is_empty||true> define result '<server.list_worlds.parse[name.to_lowercase].parse[replace[regex:^].with[-w ]]||li@>'
          }
        }
        else if <def[spaces].is[==].to[4]> {
        - if <c.args.get[2].is[==].to[-w]||false>
          || <c.args.get[3].is[==].to[-w]||false> {
          - if <c.args.get[5].is[MATCHES].to[number]> {
            - define result '<c.args.get[5]>'
            }
            else {
            - define result '<&ns>'
            }
          }
          else if <c.args.get[4].is[==].to[-w]> {
          - define result '<server.list_worlds.parse[name.to_lowercase]||li@>'
          }
        }
        else define result 'li@'
      }
      else define result 'li@'

  tab_setparent:
  # TODO
    - define result 'li@'

  tab_teleport:
  # TODO
    - define result 'li@'

  tab_remove:
  # /drg remove [ID] -w world
    - if <player.has_permission[dregions.remove]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - if <def[spaces].is[==].to[0]> define result 'remove [ID] -w world'
        else if <def[spaces].is[==].to[1]> {
        - if <c.args.get[2].is[==].to[null]||true> define result '[ID]'
          else if <c.args.get[2].is[==].to[-w]||false> define result '<server.list_worlds.parse[name.to_lowercase].parse[replace[regex:^].with[-w ]]>'
          else if <context.server.not> {
          - define regions '<yaml[dRegions_<player.world.name.to_lowercase>_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
          - if !<player.has_permission[dregions.admin]||<player.is_op||false>> {
            - foreach %regions% {
              - if <proc[dRegions_IsOwner].context[%value%|<player.world.name.to_lowercase>|<player>].not> define regions '<def[regions].exclude[%value%]||%regions%>'
              }
            }
          - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||li@>'
          - if <def[result].is_empty||true> define result '%regions%'
          }
          else define result 'li@'
        }
        else if <def[spaces].is[==].to[2]> {
        - if <c.args.get[2].is[==].to[-w]||false> {
          - if <c.args.get[3].is[!=].to[null]||false> define result '<server.list_worlds.parse[name.to_lowercase].filter[starts_with[<c.args.get[3].escaped>]]||li@>'
          - if <def[result].is_empty||true> define result '<server.list_worlds.parse[name.to_lowercase]||li@>'
          }
          else define result '<server.list_worlds.parse[name.to_lowercase].parse[replace[regex:^].with[-w ]]>'
        }
        else if <def[spaces].is[==].to[3]> {
        - if <c.args.get[2].is[==].to[-w]||false> {
          - if <c.args.get[4].is[!=].to[null]||false> {
            - define regions '<yaml[dRegions_<c.args.get[3].escaped>_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
            - define result '<def[regions].filter[starts_with[<c.args.get[4].escaped>]]||li@>'
            - if <def[result].is_empty||true> define result '%regions%'
            }
            else define result '<yaml[dRegions_<c.args.get[3].escaped>_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
          }
          else {
          - if <c.args.get[4].is[!=].to[null]||false> define result '<server.list_worlds.parse[name.to_lowercase].filter[starts_with[<c.args.get[4].escaped>]]||li@>'
            else define result '<server.list_worlds.parse[name.to_lowercase]||li@>'
          - if <def[result].is_empty||true> define result '<server.list_worlds.parse[name.to_lowercase]||li@>'
          }
        }
        else define result 'li@'
      }
      else define result 'li@'


#
#  END dRegions Command TAB Completion
#--------------------------------------
#
#  dRegions Command Arguments
#
# Each of these subscripts is an argument for the root command.
#
  help:
    - define arg '<c.args.get[2].escaped||null>'
    - if <def[args].contains[%arg%]||false> {
      - run instantly s@dRegions_Msg 'def:<script.yaml_key[commandArgs.%arg%.usage]||No help for you!>'
      - queue clear
      }
    - if <player.has_permission[dRegions.admin]||<player.is_op||<context.server||false>>> inject locally msgsHelpAdmin instantly
      else inject locally msgsHelpUser instantly
    - inject locally msgsFooter instantly
    - queue clear

  about:
    - inject locally msgsHelpUser instantly
    - inject locally msgsFooter instantly
    - queue clear

  reload:
    - if !<player.has_permission[dRegions.reload]||<player.is_op||<context.server||false>>> {
      - inject locally help
      - queue clear
      }
    - inject s@dRegions p:reloadYaml instantly
#    - run instantly s@dRegions_Msg 'def:<&7><&o>System files loaded!'

  restart:
    - if !<player.has_permission[dRegions.restart]||<player.is_op||<context.server||false>>> {
      - inject locally help
      - queue clear
      }
    - run s@dRegions p:start instantly


  define:
  # /drg define [ID] (g:group) (player)
    - inject locally prerun instantly
    # Check for existing region
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]||true>'
    - if <def[exists].is[==].to[orphan]> {
      - run instantly s@dRegions_Msg 'def:<&c>There is an orphaned region by this name!'
      - run instantly s@dRegions_Msg 'def:<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists]> {
      - run instantly s@dRegions_Msg 'def:<&c>There is already a region by this name!'
      - queue clear
      }
    # Check for overlapping regions
    - if !<player.has_permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_RegionOverlaps].context[<def[selectedCuboid].replace[cu@].replace[|].with[/]>|%name%|%world%|<player>]> {
        - run instantly s@dRegions_Msg 'def:<&c>Region selection contains unowned regions!'
        - queue clear
        }
      }
    # Parse any declared owners
    - define owners '<c.args.remove[1|2].replace[:].with[;]||li@>'
    - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
      - define owners '<def[owners].remove[<def[owners].find[-w]>|<def[owners].find[-w].add[1].as_int>]||li@>'
      }
    - define ownerGroups li@
    - define ownerPlayers li@
    - foreach %owners% {
      - if <def[value].starts_with[g;]||false> define ownerGroups '<def[ownerGroups].include[<def[value].replace[g;]>]||%ownerGroups%>'
        else {
        - if !<def[value].as_player.is[!=].to[null]||false> foreach next
        - define ownerPlayers '<def[ownerPlayers].include[<def[value].as_player.uuid>]||%ownerPlayers%>'
        }
      }
    # Automatically add the player that defined the region as the owner
#    - if <def[ownerPlayers].contains[<player.uuid>].not||false> define ownerPlayers '<def[ownerPlayers].include[<player.uuid>]||%ownerPlayers%>'
    # Create the region
    - inject s@dRegions p:createRegionEntry instantly
    - run instantly s@dRegions_Msg 'def:<&7><&o>Created %name% in %world%'

  redefine:
  # /drg redefine [ID]
    - inject locally prerun instantly
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run instantly s@dRegions_Msg 'def:<&c>There is an orphaned region by this name!'
      - run instantly s@dRegions_Msg 'def:<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists].not> {
      - run instantly s@dRegions_Msg 'def:<&c>There is no region by this name!'
      - queue clear
      }
    # Don't redefine global type regions
    - if <yaml[dRegions_%world%_regions].read[regions.%name%.type].is[==].to[global]||false> {
      - run instantly s@dRegions_Msg 'def:<&c>You can not redefine global regions!'
      - queue clear
      }
    # Check if is owner
    - if !<player.has_permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run instantly s@dRegions_Msg 'def:<&c>You are not an owner of this region!'
        - queue clear
        }
      }
    # Check for overlapping regions
    - if !<player.has_permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_RegionOverlaps].context[<def[selectedCuboid].replace[cu@].replace[|].with[/]>|%name%|%world%|<player>]> {
        - run instantly s@dRegions_Msg 'def:<&c>Region selection contains unowned regions!'
        - queue clear
        }
      }
    # Update the region
    - yaml set 'regions.%name%.min:<def[selectedCuboid].min.simple>' 'id:dRegions_%world%_regions'
    - yaml set 'regions.%name%.max:<def[selectedCuboid].max.simple>' 'id:dRegions_%world%_regions'
    - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
    - note cu@<def[selectedCuboid].min.simple>|<def[selectedCuboid].max.simple> 'as:dregions_%world%_%name%'
    - run instantly s@dRegions_Msg 'def:<&f><&o>%name%<&7><&o> updated to selection'

  claim:
  # /drg claim [ID]
    - inject locally prerun instantly
    # Check Global region limits
    - define globalRegionLimit '<yaml[dregions_global_config].read[config.regions.claim.max-region-count-per-player.default]||0>'
    - if <def[globalRegionLimit].is[MORE].than[0]> {
      - define playerGlobalRegions 'li@'
      - foreach <server.list_worlds.parse[name.to_lowercase]> {
        - define thisWorld '%value%'
        - foreach '<yaml[dRegions_%thisWorld%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>' {
          - define region '%value%'
          - if <proc[dRegions_IsOwner].context[<def[region]>|<def[thisWorld]>|<player>]||false> {
            - define playerGlobalRegions '<def[playerGlobalRegions].include[<def[region]>]||<def[playerGlobalRegions]>>'
            }
          }
        }
      - if <def[playerGlobalRegions].size.is[OR_MORE].than[%globalRegionLimit%]> {
        - run instantly s@dRegions_Msg 'def:<&c>You already have <def[playerGlobalRegions].size> total regions!'
        - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
          - queue clear
          }
        - run instantly s@dRegions_Msg 'def:<&c>But you are an admin so it is ok!'
        }
      }
    # Check World region limits
    - define worldRegionLimit '<yaml[dregions_%world%_config].read[config.regions.claim.max-region-count-per-player.default]||0>'
    - if <def[worldRegionLimit].is[MORE].than[0]> {
      - define playerWorldRegions 'li@'
      - foreach '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>' {
        - define region '%value%'
        - if <proc[dRegions_IsOwner].context[<def[region]>|<def[world]>|<player>]||false> {
          - define playerWorldRegions '<def[playerWorldRegions].include[<def[region]>]||<def[playerWorldRegions]>>'
          }
        }
      - if <def[playerWorldRegions].size.is[OR_MORE].than[%worldRegionLimit%]> {
        - run instantly s@dRegions_Msg 'def:<&c>You already have <def[playerWorldRegions].size> regions in this world!'
        - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
          - queue clear
          }
        - run instantly s@dRegions_Msg 'def:<&c>But you are an admin so it is ok!'
        }
      }
    # Check selection volume
    - define globalClaimVol '<yaml[dregions_global_config].read[config.regions.claim.max-volume]||0>'
    - inject s@dWE_Commands p:selection_Size instantly
    - if <def[globalClaimVol].is[MORE].than[0]> {
      - if <def[size].is[MORE].than[%globalClaimVol%]> {
        - run instantly s@dRegions_Msg 'def:<&c>Your selection exceeds the global limit!'
        - run instantly s@dRegions_Msg 'def:<&7><&o>Selected <&8>(<&7><&o>%size%<&8>) <&7><&o>Limit <&8>(<&7><&o>%globalClaimVol%<&8>) <&7><&o>Over <&8>(<&7><&o><def[size].sub[%globalClaimVol%].as_int><&8>)'
        - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
          - queue clear
          }
        - run instantly s@dRegions_Msg 'def:<&c>But you are an admin so it is ok!'
        }
      }
    - define worldClaimVol '<yaml[dregions_%world%_config].read[config.regions.claim.max-volume]||0>'
    - if <def[worldClaimVol].is[MORE].than[0]> {
      - if <def[size].is[MORE].than[%worldClaimVol%]> {
        - run instantly s@dRegions_Msg 'def:<&c>Your selection exceeds the world limit!'
        - run instantly s@dRegions_Msg 'def:<&7><&o>Selected <&8>(<&7><&o>%size%<&8>) <&7><&o>Limit <&8>(<&7><&o>%worldClaimVol%<&8>) <&7><&o>Over <&8>(<&7><&o><def[size].sub[%worldClaimVol%].as_int><&8>)'
        - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
          - queue clear
          }
        - run instantly s@dRegions_Msg 'def:<&c>But you are an admin so it is ok!'
        }
      }
    # Check inside existing/owned region
    - if '<yaml[dregions_global_config].read[config.regions.claim.only-inside-existing-regions]||false>' {
      - if <def[playerWorldRegions].exists.not> {
        - define playerWorldRegions 'li@'
        - foreach '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>' {
          - define region '%value%'
          - if <proc[dRegions_IsOwner].context[<def[region]>|<def[world]>|<player>]||false> {
            - define playerWorldRegions '<def[playerWorldRegions].include[<def[region]>]||<def[playerWorldRegions]>>'
            }
          }
        }
      - define cuboids '<def[playerWorldRegions].parse[replace[regex:^()].with[cu@dregions_%world%_]].filter[as_cuboid.is[!=].to[null]||false]||li@>'
      - foreach %cuboids% {
        - if <def[pos1].as_location.is_within[%value%]>
          && <def[pos2].as_location.is_within[%value%]> {
          - define isWithin ''
          - foreach stop
          }
        }
      - if <def[isWithin].exists.not> {
        - run instantly s@dRegions_Msg 'def:<&c>You may only claim regions within land you own'
        - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
          - queue clear
          }
        - run instantly s@dRegions_Msg 'def:<&c>But you are an admin so it is ok!'
        }
      }
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run instantly s@dRegions_Msg 'def:<&c>There is an orphaned region by this name!'
      - run instantly s@dRegions_Msg 'def:<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists]> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run instantly s@dRegions_Msg 'def:<&c>You are not an owner of this region!'
        - queue clear
        }
      - if <yaml[dRegions_%world%_regions].read[regions.%name%.type].is[==].to[global]||false> {
        - run instantly s@dRegions_Msg 'def:<&c>You can not redefine global regions!'
        - queue clear
        }
      - run instantly s@dRegions_Msg 'def:<&c>Region already exists!'
      - run instantly s@dRegions_Msg 'def:<&7>You must want to update the region'
      - define update ''
      }
    # Check for overlapping regions
    - if !<player.has_permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_RegionOverlaps].context[<def[selectedCuboid].replace[cu@].replace[|].with[/]>|%name%|%world%|<player>]> {
        - run instantly s@dRegions_Msg 'def:<&c>Region selection contains unowned regions!'
        - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
          - queue clear
          }
        - run instantly s@dRegions_Msg 'def:<&c>But you are an admin so it is ok!'
        }
      }
    # Update the region
    - if <def[update].exists||false> {
      - yaml set 'regions.%name%.min:<def[selectedCuboid].min.simple>' 'id:dRegions_%world%_regions'
      - yaml set 'regions.%name%.max:<def[selectedCuboid].max.simple>' 'id:dRegions_%world%_regions'
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - note cu@<def[selectedCuboid].min.simple>|<def[selectedCuboid].max.simple> 'as:dregions_%world%_%name%'
      - run instantly s@dRegions_Msg 'def:<&f><&o>%name%<&7><&o> updated to selection'
      }
      else {
      - define ownerPlayers 'li@<player.uuid>'
      - inject s@dRegions p:createRegionEntry instantly
      - run instantly s@dRegions_Msg 'def:<&7><&o>Created %name% in %world%'
      }

  select:
  # /drg select [ID]
    - inject locally prerun instantly
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run instantly s@dRegions_Msg 'def:<&c>There is an orphaned region by this name!'
      - run instantly s@dRegions_Msg 'def:<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists].not> {
      - run instantly s@dRegions_Msg 'def:<&c>There is no region by this name!'
      - queue clear
      }
    # Don't select global type regions
    - if <yaml[dRegions_%world%_regions].read[regions.%name%.type].is[==].to[global]||false> {
      - run instantly s@dRegions_Msg 'def:<&c>You can not select global regions!'
      - queue clear
      }
    # Check if is owner
    - if !<player.has_permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run instantly s@dRegions_Msg 'def:<&c>You are not an owner of this region!'
        - queue clear
        }
      }
    - define min '<yaml[dRegions_%world%_regions].read[regions.%name%.min].as_location.simple||null>'
    - define max '<yaml[dRegions_%world%_regions].read[regions.%name%.max].as_location.simple||null>'
    - flag player 'dWEWand_Type:cuboid'
    - flag player dWEWand:!
    - flag player dWEWand:|:%min%|%max%
    - run instantly s@dRegions_Msg 'def:<&7><&o>Selected <&f><&o>%name%'

  info:
  # /drg info [ID] -w world
    - inject locally prerun instantly
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run instantly s@dRegions_Msg 'def:<&c>There is an orphaned region named %name%!'
      - run instantly s@dRegions_Msg 'def:<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists].not> {
      - run instantly s@dRegions_Msg 'def:<&c>There is no region by this name!'
      - queue clear
      }
    # Check if is owner
    - if !<player.has_permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run instantly s@dRegions_Msg 'def:<&c>You are not an owner of this region!'
        - queue clear
        }
      }
    - inject locally regionInfo instantly
    - define msgsHeaderTitle '<&7>Region Info<&co> <&e>%name% <&8><&lb><&7>%world%<&8><&rb>'
    - inject locally msgsHeader instantly
    - narrate "<&5><el@val[|].pad_right[3]><&7>Type<&co> <&f>%type% <&8><&lb><&7><&o><def[pos1].split[,].remove[4].comma_separated.replace[ ]> <&8><&pipe> <&7><&o><def[pos2].split[,].remove[4].comma_separated.replace[ ]><&8><&rb> <&lb><&7><&o>%size%<&8><&rb>"
    - narrate "<&5><el@val[|].pad_right[3]><&7>Priority<&co> <&f><el@val[%priority%].pad_right[3]><&7>  Parent<&co> <&f>%parent%"
    - if <def[ownerPlayers].is_empty||true>
      && <def[ownerGroups].is_empty||true> {
      - narrate "<&5><el@val[|].pad_right[3]><&7>Owners<&co> <&c>none"
      }
      else {
      - define ownerList '<def[ownerPlayers].parse[as_player.name].include[<def[ownerGroups].parse[replace[regex:^()].with[<&b>]]||>].comma_separated>'
      - define lines '<proc[dRegions_LineWrap].context[Owners, <def[ownerList]>|45]>'
      - narrate "<&5><el@val[|].pad_right[3]><&7><def[lines].get[1].split[, ].get[1]><&co>  <&f><def[lines].get[1].split[, ].remove[1].comma_separated>"
      - foreach <def[lines].remove[1]> {
        - narrate "<&5><el@val[|].pad_right[7]><&f><def[value]>"
        }
      }
    - if <def[memberPlayers].is_empty||true>
      && <def[memberGroups].is_empty||true> {
      - narrate "<&5><el@val[|].pad_right[3]><&7>Members<&co> <&c>none"
      }
      else {
      - define memberList '<def[memberPlayers].parse[as_player.name].include[<def[memberGroups].parse[replace[regex:^()].with[<&b>]]||>].comma_separated>'
      - define lines '<proc[dRegions_LineWrap].context[Members, <def[memberList]>|45]>'
      - narrate "<&5><el@val[|].pad_right[3]><&7><def[lines].get[1].split[, ].get[1]><&co>  <&f><def[lines].get[1].split[, ].remove[1].comma_separated>"
      - foreach <def[lines].remove[1]> {
        - narrate "<&5><el@val[|].pad_right[7]><&f><def[value]>"
        }
      }
    - if <def[flags].is_empty> {
      - narrate "<&5><el@val[|].pad_right[3]><&7>Flags<&co> <&c>none"
      }
      else {
      - narrate "<&5><el@val[|].pad_right[3]><&7>Flags<&co>"
      - foreach '<def[flags].alphanumeric>' {
        - define flag '<def[value].split[/].get[1]>'
        - define flagVal '<def[value].after[/]>'
        - define flagValLength '<def[flagVal].length>'
        - define lines '<proc[dRegions_LineWrap].context[%flag%, <def[flagVal]>|45]>'
        - narrate "<&5><el@val[|].pad_right[5]><&e><def[lines].get[1].split[, ].get[1]><&co> <&f><def[lines].get[1].split[, ].remove[1].comma_separated>"
        - foreach <def[lines].remove[1]> {
          - narrate "<&5><el@val[|].pad_right[7]><&f><def[value]>"
          }
        }
      }
    - narrate "<&5>|"
    - inject locally msgsFooter instantly

  addowner:
  # /drg addowner [ID] g:group player
    - inject locally prerun instantly
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run instantly s@dRegions_Msg 'def:<&c>There is an orphaned region by this name!'
      - run instantly s@dRegions_Msg 'def:<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists].not> {
      - run instantly s@dRegions_Msg 'def:<&c>There is no region by this name!'
      - queue clear
      }
    # Check if is owner
    - if !<player.has_permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run instantly s@dRegions_Msg 'def:<&c>You are not an owner of this region!'
        - queue clear
        }
      }
    # Parse specified owners
    - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
      - define args '<c.args.remove[<c.args.find[-w].add[1].as_int>].exclude[-w]>'
      - define owners '<def[args].get[3].to[<def[args].size>].replace[:].with[;]||null>'
      }
      else define owners '<c.args.get[3].to[<c.args.size>].replace[:].with[;]||null>'
    - if <def[owners].is_empty||true> {
      - run instantly s@dRegions_Msg 'def:<&c>Must specify at least one owner'
      - queue clear
      }
    - foreach %owners% {
      - if <def[value].starts_with[g;]||false> {
        - define group '<def[value].replace[g;]>'
        - define groups '<yaml[dRegions_%world%_regions].read[regions.%name%.owners.groups]||li@>'
        - if <def[groups].contains[%group%]||false> {
          - run instantly s@dRegions_Msg 'def:<&c>Group %group% is already an owner'
          - foreach next
          }
        - define pass true
        - yaml set 'regions.%name%.owners.groups:->:%group%' 'id:dRegions_%world%_regions'
        }
        else {
        - if !<def[value].as_player.is[!=].to[null]||false> foreach next
        - define players '<yaml[dRegions_%world%_regions].read[regions.%name%.owners.players]||li@>'
        - if <def[players].contains[<def[value].as_player.uuid>]||false> {
          - run instantly s@dRegions_Msg 'def:<&c>Player %value% is already an owner'
          - foreach next
          }
        - define pass true
        - yaml set 'regions.%name%.owners.players:->:<def[value].as_player.uuid>' 'id:dRegions_%world%_regions'
        }
      }
    - if <def[pass].exists||false> {
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - run instantly s@dRegions_Msg 'def:<&f><&o>%name%<&7><&o> owners updated'
      }

  removeowner:
  # /drg removeowner [ID] g:group player
    - inject locally prerun instantly
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run instantly s@dRegions_Msg 'def:<&c>There is an orphaned region by this name!'
      - run instantly s@dRegions_Msg 'def:<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists].not> {
      - run instantly s@dRegions_Msg 'def:<&c>There is no region by this name!'
      - queue clear
      }
    # Check if is owner
    - if !<player.has_permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run instantly s@dRegions_Msg 'def:<&c>You are not an owner of this region!'
        - queue clear
        }
      }
    # Parse specified owners
    - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
      - define args '<c.args.remove[<c.args.find[-w].add[1].as_int>].exclude[-w]>'
      - define owners '<def[args].get[3].to[<def[args].size>].replace[:].with[;]||null>'
      }
      else define owners '<c.args.get[3].to[<c.args.size>].replace[:].with[;]||null>'
    - if <def[owners].is_empty||true> {
      - run instantly s@dRegions_Msg 'def:<&c>Must specify at least one owner'
      - queue clear
      }
    - foreach %owners% {
      - if <def[value].starts_with[g;]||false> {
        - define group '<def[value].replace[g;]>'
        - define groups '<yaml[dRegions_%world%_regions].read[regions.%name%.owners.groups]||li@>'
        - if <def[groups].contains[%group%].not||true> {
          - run instantly s@dRegions_Msg 'def:<&c>Group %group% is not an owner'
          - foreach next
          }
        - define pass true
        - yaml set 'regions.%name%.owners.groups:<-:%group%' 'id:dRegions_%world%_regions'
        }
        else {
        - if !<def[value].as_player.is[!=].to[null]||false> foreach next
        - define players '<yaml[dRegions_%world%_regions].read[regions.%name%.owners.players]||li@>'
        - if <def[players].contains[<def[value].as_player.uuid>].not||true> {
          - run instantly s@dRegions_Msg 'def:<&c>Player %value% is not an owner'
          - foreach next
          }
        - define pass true
        - yaml set 'regions.%name%.owners.players:<-:<def[value].as_player.uuid>' 'id:dRegions_%world%_regions'
        }
      }
    - if <def[pass].exists||false> {
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - run instantly s@dRegions_Msg 'def:<&f><&o>%name%<&7><&o> owners updated'
      }
      else {
      - run instantly s@dRegions_Msg 'def:<&6><&o>%name%<&c><&o> owners not updated!'
      }

  addmember:
  # /drg addmember [ID] g:group player
    - inject locally prerun instantly
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run instantly s@dRegions_Msg 'def:<&c>There is an orphaned region by this name!'
      - run instantly s@dRegions_Msg 'def:<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists].not> {
      - run instantly s@dRegions_Msg 'def:<&c>There is no region by this name!'
      - queue clear
      }
    # Check if is owner
    - if !<player.has_permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run instantly s@dRegions_Msg 'def:<&c>You are not an owner of this region!'
        - queue clear
        }
      }
    # Parse specified members
    - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
      - define args '<c.args.remove[<c.args.find[-w].add[1].as_int>].exclude[-w]>'
      - define members '<def[args].get[3].to[<def[args].size>].replace[:].with[;]||null>'
      }
      else define members '<c.args.get[3].to[<c.args.size>].replace[:].with[;]||null>'
    - if <def[members].is_empty||true> {
      - run instantly s@dRegions_Msg 'def:<&c>Must specify at least one member'
      - queue clear
      }
    - foreach %members% {
      - if <def[value].starts_with[g;]||false> {
        - define group '<def[value].replace[g;]>'
        - define groups '<yaml[dRegions_%world%_regions].read[regions.%name%.members.groups]||li@>'
        - if <def[groups].contains[%group%]||false> {
          - run instantly s@dRegions_Msg 'def:<&c>Group %group% is already a member'
          - foreach next
          }
        - define pass true
        - yaml set 'regions.%name%.members.groups:->:%group%' 'id:dRegions_%world%_regions'
        }
        else {
        - if !<def[value].as_player.is[!=].to[null]||false> foreach next
        - define players '<yaml[dRegions_%world%_regions].read[regions.%name%.members.players]||li@>'
        - if <def[players].contains[<def[value].as_player.uuid>]||false> {
          - run instantly s@dRegions_Msg 'def:<&c>Player %value% is already a member'
          - foreach next
          }
        - define pass true
        - yaml set 'regions.%name%.members.players:->:<def[value].as_player.uuid>' 'id:dRegions_%world%_regions'
        }
      }
    - if <def[pass].exists||false> {
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - run instantly s@dRegions_Msg 'def:<&f><&o>%name%<&7><&o> members updated'
      }
      else {
      - run instantly s@dRegions_Msg 'def:<&6><&o>%name%<&c><&o> members not updated!'
      }

  removemember:
  # /drg reomvemember [ID] g:group player
    - inject locally prerun instantly
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run instantly s@dRegions_Msg 'def:<&c>There is an orphaned region by this name!'
      - run instantly s@dRegions_Msg 'def:<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists].not> {
      - run instantly s@dRegions_Msg 'def:<&c>There is no region by this name!'
      - queue clear
      }
    # Check if is owner
    - if !<player.has_permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run instantly s@dRegions_Msg 'def:<&c>You are not an owner of this region!'
        - queue clear
        }
      }
    # Parse specified members
    - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
      - define args '<c.args.remove[<c.args.find[-w].add[1].as_int>].exclude[-w]>'
      - define members '<def[args].get[3].to[<def[args].size>].replace[:].with[;]||null>'
      }
      else define members '<c.args.get[3].to[<c.args.size>].replace[:].with[;]||null>'
    - if <def[members].is_empty||true> {
      - run instantly s@dRegions_Msg 'def:<&c>Must specify at least one member'
      - queue clear
      }
    - foreach %members% {
      - if <def[value].starts_with[g;]||false> {
        - define group '<def[value].replace[g;]>'
        - define groups '<yaml[dRegions_%world%_regions].read[regions.%name%.members.groups]||li@>'
        - if <def[groups].contains[%group%].not||true> {
          - run instantly s@dRegions_Msg 'def:<&c>Group %group% is not a member'
          - foreach next
          }
        - define pass true
        - yaml set 'regions.%name%.members.groups:<-:%group%' 'id:dRegions_%world%_regions'
        }
        else {
        - if !<def[value].as_player.is[!=].to[null]||false> foreach next
        - define players '<yaml[dRegions_%world%_regions].read[regions.%name%.members.players]||li@>'
        - if <def[players].contains[<def[value].as_player.uuid>].not||true> {
          - run instantly s@dRegions_Msg 'def:<&c>Player %value% is not a member'
          - foreach next
          }
        - define pass true
        - yaml set 'regions.%name%.members.players:<-:<def[value].as_player.uuid>' 'id:dRegions_%world%_regions'
        }
      }
    - if <def[pass].exists||false> {
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - run instantly s@dRegions_Msg 'def:<&f><&o>%name%<&7><&o> members updated'
      }
      else {
      - run instantly s@dRegions_Msg 'def:<&6><&o>%name%<&c><&o> members not updated!'
      }

  list:
  # /drg list (page#) -r region -w world -p player

    - define args '<c.args.remove[1]>'
    # Check the specified player
    - if <def[args].find[-p].is[OR_MORE].than[0]||false> {
      - if !<player.has_permission[dregions.admin]||<player.is_op||false>> {
        - run instantly s@dRegions_Msg 'def:<&c>You may not list other players regions!'
        - queue clear
        }
      - define player '<def[args].get[<def[args].find[-p].add[1].as_int>].escaped||null>'
      - if !<def[player].as_player.is[!=].to[null]||false> {
        - run instantly s@dRegions_Msg 'def:<&c>Invalid player specfied!'
        - queue clear
        }
      - define filterPlayer ''
      - define args '<def[args].remove[<def[args].find[-p].add[1].as_int>].exclude[-p]||li@>'
      }
      else {
      - if <context.server.not> define player '<player.name>'
        else define player 'null'
      }

    # Check the specified world
    - if <def[args].find[-w].is[OR_MORE].than[0]||false> {
      - define world '<def[args].get[<def[args].find[-w].add[1].as_int>].as_world.name.to_lowercase.escaped||null>'
      - if <def[world].is[==].to[null]||true> {
        - run instantly s@dRegions_Msg 'def:<&c>Invalid world specfied!'
        - queue clear
        }
      - define filterWorld ''
      - define args '<def[args].remove[<def[args].find[-w].add[1].as_int>].exclude[-w]||li@>'
      }
      else {
      - if <context.server.not> define world '<player.world.name.to_lowercase>'
        else define world 'null'
      }

    # Does the player want to list the regions where he stands?
    - if <def[args].find[-h].is[OR_MORE].than[0]||false> {
      - define filterHere ''
      - define args '<def[args].remove[<def[args].find[-h]>]||li@>'
      }

    # Do we want to show results for ALL worlds?
    - if <def[args].find[-a].is[OR_MORE].than[0]||false> {
      - define worlds '<server.list_worlds.parse[name.to_lowercase]>'
      - define getAll ''
      - define args '<def[args].remove[<def[args].find[-a]>]||li@>'
      }

    # Check the specified region name
    - if <def[args].find[-r].is[OR_MORE].than[0]||false> {
      - define region '<def[args].get[<def[args].find[-r].add[1].as_int>].escaped||null>'
      - if <def[region].is[!=].to[null]||true> {
        - define exists '<proc[dRegions_RegionExists].context[<def[region]>|<def[world]>]>'
        - if <def[exists].is[==].to[orphan]> {
          - run instantly s@dRegions_Msg 'def:<&c>There is an orphaned region by this name!'
          - run instantly s@dRegions_Msg 'def:<&c>Please notify an admin!'
          - queue clear
          }
          else if <def[exists].not> {
          - run instantly s@dRegions_Msg 'def:<&c>There is no region by this name!'
          - queue clear
          }
        - if !<player.has_permission[dregions.admin]||<player.is_op||false>> {
          - if <proc[dRegions_IsOwner].context[<def[region]>|<def[world]>|<player>].not> {
            - run instantly s@dRegions_Msg 'def:<&c>You are not an owner of this region!'
            - queue clear
            }
          }
        }
        else {
        - run instantly s@dRegions_Msg 'def:<&c>You must specify a valid region ID!'
        - queue clear
        }
      - define filterRegion ''
      - define args '<def[args].remove[<def[args].find[-r].add[1].as_int>].exclude[-r]||li@>'
      }

    # OK, we've validated all the user input, let's get the regions and apply filters
    - define regions li@
    - if <def[filterHere].exists> {
      - define standingIn '<player.location.cuboids.parse[notable_name].filter[split[_].get[1].is[==].to[dRegions]].parse[after[dregions_%world%_]].replace[li@].replace[|].with[,]>'
      - define worldRegions '<proc[dRegions_HighestPriority].context[%world%|%standingIn%]||li@>'
      - if <def[worldRegions].is_empty||true> {
        - define worldRegions 'li@__global__'
        }
      - inject locally filterRegionList
      }
      else if <def[getAll].exists> {
      - foreach %worlds% {
        - define world %value%
        - define worldRegions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
        - inject locally filterRegionList
        }
      }
      else {
      - define worldRegions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
      - inject locally filterRegionList
      }

    # Display the list
    - define page '<def[args].get[1].replace[-].escaped||1>'
    - if <def[page].is[MATCHES].to[number].not> {
      - define page '1'
      }
    - define pages '<def[regions].size.div[14].round_up||1>'
    - if <def[page].is[MORE].than[%pages%]> {
      - define page '%pages%'
      }
    - define highNumber '<def[page].mul[14].as_int>'
    - define lowNumber '<def[highNumber].sub[13].as_int>'
    - define msgsHeaderTitle '<&e>Region List   <el@val[<&7><&o>Page <&f><&o>%page% <&7><&o>of %pages%].pad_left[30]>'
    - inject locally msgsHeader instantly
    - foreach <def[regions].get[%lowNumber%].to[%highNumber%]||li@> {
      - define color '<t[<def[value].split[/].get[3].is[==].to[owner]>]:&6||<t[<def[value].split[/].get[3].is[==].to[member]>]:&e||&f>>'
      - narrate "<&5>|<&sp><&7><el@val[<el@val[<def[lowNumber].add[<def[loop_index].sub[1]>].as_int>.].pad_left[4].with[<&sp>]>].pad_right[5].with[<&sp>]> <%color%><def[value].split[/].get[2]>"
      }
    - narrate "<&5>|"
    - inject locally msgsFooter instantly

  flag:
  # /drg flag [ID] [flag] [value] -g group -w world

    - define args '<c.args.remove[1]>'

    # Check the specified world
    - if <def[args].find[-w].is[OR_MORE].than[0]||false> {
      - define world '<def[args].get[<def[args].find[-w].add[1].as_int>].as_world.name.escaped.to_lowercase||null>'
      - if <def[world].is[==].to[null]||true> {
        - run instantly s@dRegions_Msg 'def:<&c>Invalid world specfied!'
        - queue clear
        }
      - define args '<def[args].remove[<def[args].find_all[-w].parse[add[1].as_int]>].exclude[-w]||li@>'
      }
      else {
      - if <context.server.not> define world '<player.world.name.to_lowercase>'
        else define world 'null'
      }

    # Check the specified group
    - if <def[args].find[-g].is[OR_MORE].than[0]||false> {
      - define group '<def[args].get[<def[args].find[-g].add[1].as_int>].escaped.to_lowercase||null>'
      - if !<el@val[members|nonmembers|owners|nonowners|all].as_list.contains[%group%]||false> {
        - run instantly s@dRegions_Msg 'def:<&c><def[group].unescaped> is an invalid group!'
        - queue clear
        }
      - define args '<def[args].remove[<def[args].find_all[-g].parse[add[1].as_int]>].exclude[-g]||li@>'
      }

    # Check the specified region name
    - define region '<def[args].get[1].escaped.to_lowercase||null>'
    - if <def[region].is[!=].to[null]||true> {
      - define exists '<proc[dRegions_RegionExists].context[<def[region]>|<def[world]>]>'
      - if <def[exists].is[==].to[orphan]> {
        - run instantly s@dRegions_Msg 'def:<&c>There is an orphaned region by this name!'
        - run instantly s@dRegions_Msg 'def:<&c>Please notify an admin!'
        - queue clear
        }
        else if <def[exists].not> {
        - run instantly s@dRegions_Msg 'def:<&c>There is no region by this name!'
        - queue clear
        }
      - if !<player.has_permission[dregions.admin]||<player.is_op||false>> {
        - if <proc[dRegions_IsOwner].context[<def[region]>|<def[world]>|<player>].not> {
          - run instantly s@dRegions_Msg 'def:<&c>You are not an owner of this region!'
          - queue clear
          }
        }
      }
      else {
      - run instantly s@dRegions_Msg 'def:<&c>You must specify a valid region ID!'
      - queue clear
      }

    # Check the specified flag name
    - define flag '<def[args].get[2].escaped.to_lowercase||null>'
    - if <def[flag].is[!=].to[null]||true> {
      - define flags '<server.list_scripts.filter[starts_with[s@dRegions_Flag_]].parse[name.split[_].get[3]]||li@>'
      - if !<def[flags].contains[%flag%]||false> {
        - run instantly s@dRegions_Msg 'def:<&c>You must specify a valid region flag!'
        - queue clear
        }
      }
      else {
      - run instantly s@dRegions_Msg 'def:<&c>You must specify a valid region flag!'
      - queue clear
      }

    # Check the specified flag value and set or clear it.
    - define flagValue '<def[args].get[3].to[<def[args].size>].space_separated.escaped||null>'
    - if <def[flagValue].is[!=].to[null]||true> {
      - define type "<s@dRegions_Flag_%flag%.yaml_key[flag_type]||null>"
      - define typeMatch '<proc[dRegion_FlagTypeMatch].context[%flagValue%|%flag%]>'
      - if !<def[TypeMatch]> {
        - define lines '<proc[dRegions_LineWrap].context[<s@dRegions_Flag_%Flag%.yaml_key[flag_help]||<&c>%flag% flag requires a %type% value!>|45]>'
        - foreach <def[lines]> {
          - run instantly s@dRegions_Msg 'def:<&c><def[value]>'
          }
        - queue clear
        }
      - if <def[type].is[==].to[state]||false>
        && <def[flagValue].is[==].to[none]||false> {
        - inject s@dRegions_Flag_%flag% p:command_handler
        - yaml set 'regions.%region%.flags.%flag%:!' 'id:dRegions_%world%_regions'
        - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
        - run instantly s@dRegions_Msg 'def:<&c>Cleared %flag% flag for region %region%'
        - queue clear
        }
      - inject s@dRegions_Flag_%flag% p:command_handler
      - if <s@dRegions_Flag_%flag%.yaml_key[flag_takeGroup]||false> {
        - if <def[group].exists> {
          - yaml set 'regions.%region%.flags.%flag%:<def[flagValue].unescaped>/%group%' 'id:dRegions_%world%_regions'
          }
          else {
          - yaml set 'regions.%region%.flags.%flag%:<def[flagValue].unescaped>' 'id:dRegions_%world%_regions'
          }
        }
        else {
        - yaml set 'regions.%region%.flags.%flag%:<def[flagValue].unescaped>' 'id:dRegions_%world%_regions'
        }
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - define string "<&f><&o>%region%<&7><&o> set %flag% flag to <&f><&o>%flagValue%"
      - define lines '<proc[dRegions_LineWrap].context[<def[string]>|45]>'
      - foreach <def[lines]> {
        - run instantly s@dRegions_Msg 'def:<&f><&o><def[value].unescaped>'
        }
      }
      else {
      - inject s@dRegions_Flag_%flag% p:command_handler
      - yaml set 'regions.%region%.flags.%flag%:!' 'id:dRegions_%world%_regions'
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - run instantly s@dRegions_Msg 'def:<&c>Cleared %flag% flag for region %region%'
      - queue clear
      }

  setpriority:
  # /drg setpriority [ID] [#]
    - inject locally prerun instantly
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run instantly s@dRegions_Msg 'def:<&c>There is an orphaned region by this name!'
      - run instantly s@dRegions_Msg 'def:<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists].not> {
      - run instantly s@dRegions_Msg 'def:<&c>There is no region by this name!'
      - queue clear
      }
    # Check if is owner
    - if !<player.has_permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run instantly s@dRegions_Msg 'def:<&c>You are not an owner of this region!'
        - queue clear
        }
      }
    # Verify specified priority
    - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
      - define args '<c.args.remove[<c.args.find[-w].add[1].as_int>].exclude[-w]>'
      - define priority '<def[args].get[3].escaped||null>'
      }
      else define priority '<c.args.get[3].escaped||null>'
    - if <def[priority].is[matches].to[number].not||true> {
      - run instantly s@dRegions_Msg 'def:<&c>Must specify a numeric value for priority'
      - queue clear
      }
    # Update region
    - yaml set 'regions.%name%.priority:%priority%' 'id:dRegions_%world%_regions'
    - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
    - run instantly s@dRegions_Msg 'def:<&f><&o>%name%<&7><&o> set priority to <&f><&o>%priority%'

  setparent:
  # /drg setparent [ID] [parent]
    - inject locally prerun instantly
    # Check if child region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run instantly s@dRegions_Msg 'def:<&c>There is an orphaned region by this name!'
      - run instantly s@dRegions_Msg 'def:<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists].not> {
      - run instantly s@dRegions_Msg 'def:<&c>There is no region by this name!'
      - queue clear
      }
    # Check if is owner
    - if !<player.has_permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run instantly s@dRegions_Msg 'def:<&c>You are not an owner of this region!'
        - queue clear
        }
      }
    # Check if parent region exists
    - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
      - define args '<c.args.remove[<c.args.find[-w].add[1].as_int>].exclude[-w]>'
      - define parent '<def[args].get[3].escaped||null>'
      }
      else define parent '<c.args.get[3].escaped||null>'
    - if <def[parent].is[==].to[null]> {
      - yaml set 'regions.%name%.parent:!' 'id:dRegions_%world%_regions'
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - run instantly s@dRegions_Msg 'def:<&7><&o>Unset parent for <&f><&o>%name%'
      - queue clear
      }
    # Check if parent region exists
    - define exists '<proc[dRegions_RegionExists].context[%parent%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run instantly s@dRegions_Msg 'def:<&c>There is an orphaned region by this name!'
      - run instantly s@dRegions_Msg 'def:<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists].not> {
      - run instantly s@dRegions_Msg 'def:<&c>There is no region by this name!'
      - queue clear
      }
    # Check if player owns parent
    - if !<player.has_permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%parent%|%world%|<player>].not> {
        - run instantly s@dRegions_Msg 'def:<&c>You are not an owner of this region!'
        - queue clear
        }
      }
    # Update the region
    - yaml set 'regions.%name%.parent:%parent%' 'id:dRegions_%world%_regions'
    - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
    - run instantly s@dRegions_Msg 'def:<&f><&o>%name%<&7><&o> set parent to <&f><&o>%parent%'

  teleport:
    - narrate "Stub"

  remove:
  # /drg remove [ID] -w world
    - inject locally prerun instantly
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run instantly s@dRegions_Msg 'def:<&c>There is an orphaned region by this name!'
      - run instantly s@dRegions_Msg 'def:<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists].not> {
      - run instantly s@dRegions_Msg 'def:<&c>There is no region by this name!'
      - queue clear
      }
    # Don't remove the __global__ region
    - if <def[name].is[==].to[__global__]> {
      - run instantly s@dRegions_Msg 'def:<&c>You can not remove the __global__ region!'
      - queue clear
      }
    # Check if is owner
    - if !<player.has_permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run instantly s@dRegions_Msg 'def:<&c>You are not an owner of this region!'
        - queue clear
        }
      }
    # Check for child regions and unset parent
    - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__]||li@>'
    - foreach %regions% {
      - if <yaml[dRegions_%world%_regions].read[regions.%value%.parent].is[==].to[%name%]||false> {
        - yaml set 'regions.%value%.parent:<-:%name%' 'id:dRegions_%world%_regions'
        }
      }
    # Remove the region
    - yaml set 'regions.%name%:!' 'id:dRegions_%world%_regions'
    - note remove 'as:dregions_%world%_%name%'
    - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
    - run instantly s@dRegions_Msg 'def:<&f><&o>%name%<&7><&o> has been removed from <&f><&o>%world%'

#
#  END dRegions Command Arguments
#--------------------------------------
#
#  dRegions Command Utilities
#
# Just some commonly used code blocks
#
  prerun:
  # Block of checks run before /most/ commands
    - if !<player.has_permission[dRegions.%command%]||<player.is_op||false>> {
      - inject locally help
      - queue clear
      }
    - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
      - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||null>'
      - if <def[world].is[==].to[null]||true> {
        - run instantly s@dRegions_Msg 'def:<&c>Invalid world specfied!'
        - run instantly s@dRegions_Msg 'def:<script.yaml_key[commandArgs.%command%.usage]>'
        - queue clear
        }
      - define args '<c.args.remove[<c.args.find[-w].add[1].as_int>].exclude[-w]>'
      - define name '<def[args].get[2].escaped.to_lowercase||null>'
      }
      else define world '<player.world.name.to_lowercase>'
    - if <li@define|redefine|claim.contains[%command%]> {
      - define wandType '<player.flag[dWEWand_Type]||cuboid>'
      - if <li@cuboid|extender.contains[%wandType%].not||true> {
        - run instantly s@dRegions_Msg 'def:<&c>You must select a cuboid type region!'
        - run instantly s@dRegions_Msg 'def:<script.yaml_key[commandArgs.%command%.usage]>'
        - queue clear
        }
      - define pos1 '<player.flag[dWEWand].get[1].as_location||null>'
      - define pos2 '<player.flag[dWEWand].get[2].as_location||null>'
      - if <def[pos1].is[==].to[null]>
        || <def[pos2].is[==].to[null]> {
        - run instantly s@dRegions_Msg 'def:<&c>No region selected!'
        - run instantly s@dRegions_Msg 'def:<script.yaml_key[commandArgs.%command%.usage]>'
        - queue clear
        }
      - if <def[pos1].world.name.is[!=].to[%world%]>
        || <def[pos2].world.name.is[!=].to[%world%]> {
        - run instantly s@dRegions_Msg 'def:<&c>Selected region not within specified world!'
        - run instantly s@dRegions_Msg 'def:<script.yaml_key[commandArgs.%command%.usage]>'
        - queue clear
        }
      - define selectedCuboid '<cu@%pos1%|%pos2%>'
      }
    - define name '<def[name]||<c.args.get[2].escaped.to_lowercase||null>>'
    - if '<def[name].is[==].to[null]||true>' {
      - if <li@info|select.contains[%command%]> {
        - define dRegions '<player.location.cuboids.parse[notable_name].filter[split[_].get[1].is[==].to[dRegions]].parse[after[dregions_%world%_]].replace[li@].replace[|].with[,]>'
        - define orderedRegions '<proc[dRegions_HighestPriority].context[%world%|%dRegions%]>'
        - if <def[orderedRegions].is_empty||true> {
          - define name '__global__'
          }
          else {
          - define name '<def[orderedRegions].get[1]>'
          - if <def[orderedRegions].size.is[MORE].than[1]> {
            - run instantly s@dRegions_Msg 'def:<&c><&o>There are multiple regions at this location!'
            - run instantly s@dRegions_Msg 'def:<&7><&o>Getting highest priority region info.'
            }
          }
        }
        else {
        - run instantly s@dRegions_Msg 'def:<&c>You must specify a region ID!'
        - run instantly s@dRegions_Msg 'def:<script.yaml_key[commandArgs.%command%.usage]>'
        - queue stop
        }
      }
    - if '<def[name].matches[^[a-z0-9-_]+$].not>' {
      - run instantly s@dRegions_Msg 'def:<&c>Region ID may only contain letters, numbers,'
      - run instantly s@dRegions_Msg 'def:<&c>hyphen, and underscore!'
      - run instantly s@dRegions_Msg 'def:<script.yaml_key[commandArgs.%command%.usage]>'
      - queue stop
      }
#    - inject s@dRegions_Commands p:selection_Size instantly
#    - define oldSize '%size%'


  filterRegionList:
  # Used in /drg list to apply various filters
    - if <def[filterRegion].exists||false> {
      - define filteredRegions 'li@'
      - foreach %worldRegions% {
        - define worldRegion '%value%'
        - if <yaml[dRegions_%world%_regions].read[regions.%worldRegion%.parent].is[==].to[<def[region]>]||false> {
          - define filteredRegions '<def[filteredRegions].include[%worldRegion%]||<def[filteredRegions]>>'
          }
        }
      }
    - if <def[filteredRegions].exists> {
      - define worldRegions '<def[filteredRegions]>'
      }
    - foreach %worldRegions% {
      - define worldRegion '%value%'
      - if <proc[dRegions_IsOwner].context[<def[worldRegion]>|<def[world]>|<def[player].as_player>]||false> {
        - define regions '<def[regions].include[<def[world]>/<def[worldRegion]>/owner]||<def[regions]>>'
        }
        else if <proc[dRegions_IsMember].context[<def[worldRegion]>|<def[world]>|<def[player].as_player>]||false> {
        - define regions '<def[regions].include[<def[world]>/<def[worldRegion]>/member]||<def[regions]>>'
        }
        else if <def[filterPlayer].exists.not||true> {
        - define regions '<def[regions].include[<def[world]>/<def[worldRegion]>/nonmember]||<def[regions]>>'
        }
      }

  regionInfo:
  # Build the data set for region info
    - define type '<yaml[dRegions_%world%_regions].read[regions.%name%.type]||null>'
    - if <def[type].is[==].to[cuboid]||false> {
      - define POS1 '<yaml[dRegions_%world%_regions].read[regions.%name%.min]||null>'
      - define POS2 '<yaml[dRegions_%world%_regions].read[regions.%name%.max]||null>'
      - inject s@dWE_Commands p:selection_Size instantly
      }
      else if <def[type].is[==].to[global]||false> {
      - define POS1 '0,0,0,%world%'
      - define POS2 '0,0,0,%world%'
      - define size 'infinite'
      }
      else {
      - run instantly s@dRegions_Msg 'def:<&c>This region is misconfigured!'
      - run instantly s@dRegions_Msg 'def:<&c>Notify an Admin!'
      - queue clear
      }
    - define priority '<yaml[dRegions_%world%_regions].read[regions.%name%.priority]||0>'
    - define parent '<yaml[dRegions_%world%_regions].read[regions.%name%.parent]||<&c>none>'
    - define ownerGroups '<yaml[dRegions_%world%_regions].read[regions.%name%.owners.groups]||li@>'
    - define ownerPlayers '<yaml[dRegions_%world%_regions].read[regions.%name%.owners.players]||li@>'
    - define memberGroups '<yaml[dRegions_%world%_regions].read[regions.%name%.members.groups]||li@>'
    - define memberPlayers '<yaml[dRegions_%world%_regions].read[regions.%name%.members.players]||li@>'
    - define flagList '<yaml[dRegions_%world%_regions].list_keys[regions.%name%.flags]||li@>'
    - define flags 'li@'
    - foreach %flagList% {
      - define flags '<def[flags].include[%value%/<yaml[dRegions_%world%_regions].read[regions.%name%.flags.%value%].as_list.comma_separated||null>]||%flags%>'
      }

#
#  END dRegions dRegions Command Utilities
#--------------------------------------
#
#  dRegions Command Messages
#
# Some messages used by commands. Should probably move to s@dRegions_Msg
#
  msgsHeader:
    - narrate "<&5>|----------------------------------------|"
    - narrate "<&5>|<&sp><&sp><&sp><&6>dRegions   <&7><def[msgsHeaderTitle]||>"
    - narrate "<&5>|<&f>"

  msgsFooter:
    - define anthony "text<&co>'<&7>|Anthony|',clickEvent<&co><&chr[007B]>action<&co>open_url,value<&co>'http<&co>//mineconomy.org'<&chr[007D]>,hoverEvent<&co><&chr[007B]>action<&co>show_item,value<&co>'<&chr[007B]><i@AnthonyBanner.json><&chr[007D]>'<&chr[007D]>"
    - define spacer "text<&co>'  '"
    - define prefix "text<&co>'<&5>|  <&f>Authors<&co>  '"
    - if <player.is_player||false> {
      - execute as_server "tellraw <player.name> <&chr[007B]>text<&co>'',extra<&co>[<&chr[007B]>%prefix%<&chr[007D]>,<&chr[007B]>%anthony%<&chr[007D]>]<&chr[007D]>"
      }
      else {
      - announce to_console "<&5>|  <&f>Authors<&co>    <&7>|Anthony|"
      }
    - narrate "<&5>|-----------<&d>S<&5>-<&d>c<&5>-<&d>r<&5>-<&d>o<&5>-<&d>l<&5>-<&d>l<&5>---<&d>U<&5>-<&d>p<&5>-------------|"

  msgsHelpAdmin:
    # Filter the list of commands this player can use
    - define commands '<script.list_keys[commandArgs].alphanumeric.to_lowercase||li@>'
    - foreach %commands% {
      - if !<player.has_permission[dregions.%value%]||<player.is_op||<c.server||false>>> {
        - define commands '<def[commands].exclude[%value%]>'
        }
        else foreach next
      }

    # Display the list
    - define page '<def[arg].replace[-].escaped||1>'
    - if <def[page].is[MATCHES].to[number].not> {
      - define page '1'
      }
    - define pages '<def[commands].size.div[5].round_up||1>'
    - if <def[page].is[MORE].than[%pages%]> {
      - define page '%pages%'
      }
    - define highNumber '<def[page].mul[5].as_int>'
    - define lowNumber '<def[highNumber].sub[4].as_int>'
    - define msgsHeaderTitle '<&e>Admin Help   <el@val[<&7><&o>Page <&f><&o>%page% <&7><&o>of %pages%].pad_left[30]>'
    - inject locally msgsHeader instantly
    - foreach <def[commands].get[%lowNumber%].to[%highNumber%]||li@> {
      - narrate "<&5>|<&sp><&sp><&f><def[value].to_titlecase><&co>"
      - narrate "<&5>|<&sp><&sp><&sp><&sp><&7><script.yaml_key[commandArgs.%value%.usage]||No usage info available!>"
      }
    - narrate "<&5>|"

  msgsHelpUser:
    - define msgsHeaderTitle 'User Help'
    - inject locally msgsHeader instantly
    - define par1 "dRegions is an advanced region management and world protection system written with the Denizen Scripting Engine."
    - define par2 "Heavily inspired by WorldGuard, the goal is to have an extremely efficient events system supporting an exhaustive set of region flags and configuration options."
    - define par3 "dRegions offers an intuitive command interface and provides thorough TAB completion."
    - define strings "<el@val[%par1%|%par2%|%par3%].as_list>"
    - foreach <def[strings]> {
      - define string "<&f><&sp><def[value]>"
      - define lines '<proc[dRegions_LineWrap].context[<def[string]>|44]>'
      - foreach <def[lines]> {
        - narrate "<&5>|<&f><&sp><&sp><def[value].unescaped>"
        }
      - narrate "<&5>|"
      }

#
#  END dRegions Command Messages
#--------------------------------------
#
#  I want to test moving all command arguments to their own command script so I
# can have the dregions command and the alias of these scripts run the same
# code. I'd like to add the flexibility for folks to type the full command
#    /dregions select
# or the shorter alias
#    /.sel
# and use the same code base, tab completion and all
#
# -----
#  dRegions Select Command
#
# Select a region by ID and optionally world
#
#dRegions_Command_Sel:
#  type: command
#  debug: false
#  name: select
#  description: Select a region by ID and optionally world
#  usage: /.sel
#  aliases:
#  - .sel
#  allowed help:
#  - determine true
#  tab complete:
#    - define args 'li@help|reload|define|redefine|claim|select|info|addowner|removeowner|addmember|removemember|list|flag|setpriority|setparent|teleport|remove'
#    - define arg '<c.args.get[1]||null>'
#    - if <def[arg].is[==].to[null]>
#      || !<def[args].contains[%arg%]> {
#      - inject locally tab_arg_1
#      }
#      else inject locally tab_%arg%
#    - determine '<def[result]||li@>'

#  script:
#  # We only want to run it if the user issues the alias /.sel command
#    - if <c.alias.is[!=].to[.sel]||true> queue clear

#    - define command 'select'
#    - define args 'li@help|reload|select|define|redefine|remove|addowner|addmember|setparent|setpriority'
#    - if !<def[args].contains[%command%]> inject locally help instantly
#      else inject locally %command% instantly

#  sel:
#  # /drg select [ID]
#    - inject locally prerun instantly
#    # Check if region exists
#    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
#    - if <def[exists].is[==].to[orphan]> {
#      - run instantly s@dRegions_Msg 'def:<&c>There is an orphaned region by this name!'
#      - run instantly s@dRegions_Msg 'def:<&c>Please notify an admin!'
#      - queue clear
#      }
#      else if <def[exists].not> {
#      - run instantly s@dRegions_Msg 'def:<&c>There is no region by this name!'
#      - queue clear
#      }
#    # Check if is owner
#    - if !<player.has_permission[dregions.admin]||false> {
#      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
#        - run instantly s@dRegions_Msg 'def:<&c>You are not an owner of this region!'
#        - queue clear
#        }
#      }
#    - define min '<yaml[dRegions_%world%_regions].read[regions.%name%.min].as_location.simple||null>'
#    - define max '<yaml[dRegions_%world%_regions].read[regions.%name%.max].as_location.simple||null>'
#    - flag player 'dWEWand_Type:cuboid'
#    - flag player dWEWand:!
#    - flag player dWEWand:|:%min%|%max%
#    - run instantly s@dRegions_Msg 'def:<&7><&o>Selected <&f><&o>%name%'

#  prerun:
#  # Block of checks run before /most/ commands
#    - if !<player.has_permission[dRegions.%command%]||<player.is_op||false>> {
#      - inject locally help
#      - queue clear
#      }
#    - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
#      - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name||null>'
#      - if <def[world].is[==].to[null]||true> {
#        - run instantly s@dRegions_Msg 'def:<&c>Invalid world specfied!'
#        - queue clear
#        }
#      - define args '<c.args.remove[<c.args.find[-w].add[1].as_int>].exclude[-w]>'
#      - define name '<def[args].get[2].escaped||null>'
#      }
#      else define world '<player.world.name>'
#    - if <li@define|redefine|claim.contains[%command%]> {
#      - define wandType '<player.flag[dWEWand_Type]||cuboid>'
#      - if <li@cuboid|extender.contains[%wandType%].not||true> {
#        - run instantly s@dRegions_Msg 'def:<&c>You must select a cuboid type region!'
#        - queue clear
#        }
#      - define pos1 '<player.flag[dWEWand].get[1].as_location||null>'
#      - define pos2 '<player.flag[dWEWand].get[2].as_location||null>'
#      - if <def[pos1].is[==].to[null]>
#        || <def[pos2].is[==].to[null]> {
#        - run instantly s@dRegions_Msg 'def:<&c>No region selected!'
#        - queue clear
#        }
#      - if <def[pos1].world.name.is[!=].to[%world%]>
#        || <def[pos2].world.name.is[!=].to[%world%]> {
#        - run instantly s@dRegions_Msg 'def:<&c>Selected region not within specified world!'
#        - queue clear
#        }
#      - define selectedCuboid '<cu@%pos1%|%pos2%>'
#      }
#    - define name '<def[name]||<c.args.get[2].escaped||null>>'
#    - if <def[name].is[==].to[null]||true> {
#      - run instantly s@dRegions_Msg 'def:<&c>You must specify a name!'
#      - queue stop
#      }

#
#  END dRegions Command Script Basics
#--------------------------------------
#
#  dRegions Command TAB Completion
#
# Each of these subscripts handles TAB completion for the positional argument.
#
#
#--------------------------------------
#
#  dRegions Other Utilities
#
# Other Utility functions used throughout dRegions
#
##dRegions_HasPerm:
##  I have to think about this more...
##  # A procedure script to check if a player has any of the required permissions for a command
##  # <proc[dRegions_HasPerm].context[command|player|region]>
##  type: procedure
##  definition: command|player|region
##  constants:
##    define:
##    - admin
##    - define
##    redefine:
##    - admin
##    - redefine
##    - redefine.own.*
##    - redefine.own.%region%
##    - redefine.member.*
##    - redefine.member.%region%
##
##  script:
##    - if '<def[region].exsits.not||true>' determine false
##    - define perms <script.constant[%command%]>


dRegions_IsOwner:
  # A procedure script to check if a player is a region owner
  # <proc[dRegions_IsOwner].context[region|world|player]>
  type: procedure
  definitions: region|world|player
  debug: false

  script:
    - define playerUUID '<def[player].uuid>'
    - define playerGroups '<def[player].groups||li@>'
    - define players '<yaml[dRegions_%world%_regions].read[regions.%region%.owners.players]||li@>'
    - define groups '<yaml[dRegions_%world%_regions].read[regions.%region%.owners.groups]||li@>'
    - if <def[players].contains[<def[playerUUID]>].not||false>
      && <def[groups].contains_any[<def[playerGroups]>].not||false> {
      - define return 'null'
      }
      else {
      - determine 'true'
      }

    - define thisRegion '<def[region]>'
    - while <def[return].is[==].to[null]||false> {
      - define thisRegion '<yaml[dRegions_%world%_regions].read[regions.%thisRegion%.parent]||null>'
      - if <def[thisRegion].is[==].to[null]||false>
        || <def[loop_index].is[MORE].than[25]||false> {
        - while stop
        }
      - define players '<yaml[dRegions_%world%_regions].read[regions.%thisRegion%.owners.players]||li@>'
      - define groups '<yaml[dRegions_%world%_regions].read[regions.%thisRegion%.owners.groups]||li@>'
      - if <def[players].contains[<def[playerUUID]>].not||false>
        && <def[groups].contains_any[<def[playerGroups]>].not||false> {
        - define return 'null'
        }
        else {
        - determine 'true'
        }
      }
    - determine 'false'


dRegions_IsMember:
  # A procedure script to check if a player is a region member
  # <proc[dRegions_IsMember].context[region|world|player]>
  type: procedure
  definitions: region|world|player
  debug: false

  script:
#    - define players '<yaml[dRegions_%world%_regions].read[regions.%region%.members.players]||li@>'
#    - define groups '<yaml[dRegions_%world%_regions].read[regions.%region%.members.groups]||li@>'
#    - if <def[players].contains[<def[player].uuid>].not||false>
#      && <def[groups].contains_any[<def[player].groups>].not||false> determine false
#      else determine true
    - define playerUUID '<def[player].uuid>'
    - define playerGroups '<def[player].groups||li@>'
    - define players '<yaml[dRegions_%world%_regions].read[regions.%region%.members.players]||li@>'
    - define groups '<yaml[dRegions_%world%_regions].read[regions.%region%.members.groups]||li@>'
    - if <def[players].contains[<def[playerUUID]>].not||false>
      && <def[groups].contains_any[<def[playerGroups]>].not||false> {
      - define return 'null'
      }
      else {
      - determine 'true'
      }

    - define thisRegion '<def[region]>'
    - while <def[return].is[==].to[null]||false> {
      - define thisRegion '<yaml[dRegions_%world%_regions].read[regions.%thisRegion%.parent]||null>'
      - if <def[thisRegion].is[==].to[null]||false>
        || <def[loop_index].is[MORE].than[25]||false> {
        - while stop
        }
      - define players '<yaml[dRegions_%world%_regions].read[regions.%thisRegion%.members.players]||li@>'
      - define groups '<yaml[dRegions_%world%_regions].read[regions.%thisRegion%.members.groups]||li@>'
      - if <def[players].contains[<def[playerUUID]>].not||false>
        && <def[groups].contains_any[<def[playerGroups]>].not||false> {
        - define return 'null'
        }
        else {
        - determine 'true'
        }
      }
    - determine 'false'


dRegions_RegionExists:
  # A procedure script to check if a region exists
  # <proc[dRegions_RegionExists].context[region|world]>
  type: procedure
  definitions: region|world
  debug: false

  script:
    - if <def[region].is[==].to[__global__]> {
      - determine true
      }
    - define notables '<cu@dregions_%world%_%region%.as_cuboid.is[!=].to[null].not||true>'
    - define regions '<yaml[dRegions_%world%_regions].contains[regions.%region%].not||true>'
    - if %notables% && %regions% determine false
      else if %notables% || %regions% determine orphan
      else determine true


dRegions_HighestPriority:
  # Filter a list of regions by priority in descending order
  # <proc[dRegions_HighestPriority].context[world|region1,...]>
  type: procedure
  definitions: world|regions
  debug: false

  script:
    - define regions '<def[regions].split[,]||li@>'
    - define priList '<parse:<def[regions].parse[replace[regex:^()].with[<&lt>yaml<&lb>dRegions_%world%_regions<&rb>.read<&lb>regions.]].parse[replace[regex:()$].with[.priority<&rb>||0<&gt>]]>>'
    - define regionPri 'li@'
    - foreach <def[regions]> {
      - define regionPri '<def[regionPri].include[<def[priList].get[%loop_index%]>/%value%]>'
      }
    - determine '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]]>'


dRegions_RegionOverlaps:
  # A procedure script to check if a region overlaps other (un)owned regions
  # <proc[dRegions_RegionOverlaps].context[<def[selectedCuboid].replace[cu@].replace[|].with[/]>|%name%|%world%|<player>]>
  # NOTE: We have the ability to return %overlaps% and %unowned% if we want
  type: procedure
  definitions: selectedCuboid|region|world|player
  debug: false

  script:
    - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__]||li@>'
    - define notables '<def[regions].parse[replace[regex:^()].with[cu@dregions_%world%_]].filter[as_cuboid.is[!=].to[null]||false]||li@>'
    - define overlaps '<def[notables].filter[intersects[<def[selectedCuboid].split[/].as_cuboid>]].parse[replace[cu@dregions_%world%_]]||li@>'
#    - define unowned '<def[overlaps].filter[<proc[dRegions_IsOwner].context[%region%|%world%|<player>].not>]||li@>'
    - define unowned li@
    - foreach %overlaps% {
      - if <proc[dRegions_IsOwner].context[%value%|%world%|<player>].not> {
        - define unowned '<def[unowned].include[%value%]||%unowned%>'
        }
      }
    - if <def[unowned].is_empty.not||true> determine true
      else determine false


dRegions_PlayerMatchRegionGroup:
  # Check if a player matches a region flag group setting.
  # <proc[dRegions_PlayerMatchRegionGroup].context[group|isMember|isOwner]>
  type: procedure
  definitions: group|isMember|isOwner
  debug: false

  script:
    - if <def[group].is[==].to[nonmembers]> {
      - if <def[isMember].not> && <def[isOwner].not> {
        - determine true
        }
      }
    - if <def[group].is[==].to[owners]> {
      - if <def[isOwner]> {
        - determine true
        }
      }
    - if <def[group].is[==].to[nonowners]> {
      - if <def[isOwner].not> {
        - determine true
        }
      }
    - if <def[group].is[==].to[members]> {
      - if <def[isMember]> {
        - determine true
        }
      }
    - if <def[group].is[==].to[all]> {
      - determine true
      }
    - determine false


dRegions_GetInheritedFlag:
  # Get a region flag value. Start at current child and ascend through parents
  # until a value is set or you reach the origin ancestor
  # <proc[dRegions_GetInheritedFlag].context[world|region|flag]>
  type: procedure
  definitions: world|region|flag
  debug: false

  script:
    - define return '<yaml[dRegions_%world%_regions].read[regions.%region%.flags.%flag%]||null>'
    - define thisRegion '<def[region]>'
    - while <def[return].is[==].to[null]||false> {
      - define thisRegion '<yaml[dRegions_%world%_regions].read[regions.%thisRegion%.parent]||null>'
      - if <def[thisRegion].is[==].to[null]||false>
        || <def[loop_index].is[MORE].than[25]||false> {
        - while stop
        }
      - define return '<yaml[dRegions_%world%_regions].read[regions.%thisRegion%.flags.%flag%]||null>'
      }
    - determine '<def[return]||null>'


dRegions_LineWrap:
  # Turn a long string into a list of smaller strings
  type: procedure
  definitions: string|targetLen
  debug: false

  script:
    - define stringLen '<def[string].length>'
    - if <def[stringLen].is[MORE].than[%targetLen%]> {
      - define lines 'li@'
      - while <def[stringLen].is[MORE].than[0]> {
        - define low '<def[increment].add[1].as_int||1>'
        - define hi '<def[increment].add[<def[targetLen].add[1]>].as_int||%targetLen%>'
        - define pass '<def[string].substring[%low%,%hi%]>'
        - if <def[pass].length.is[==].to[%stringLen%]> {
          - define lines '<def[lines].include[%pass%]||<def[lines]>>'
          - while stop
          }
          else {
          - define brake '<def[pass].last_index_of[ ]>'
          - define increment '<def[increment].add[%brake%]||%brake%>'
          - define passtrim '<def[pass].substring[1,<t[<def[brake].is[MORE].than[0]>]:%brake%||<def[pass].length>>]>'
          - define lines '<def[lines].include[%passtrim%]||<def[lines]>>'
          - define stringLen '<def[stringLen].sub[%brake%]>'
          }
        - if <def[loop_index].is[MORE].than[10]> {
          - while stop
          }
        }
      - determine '<def[lines].as_list>'
      }
      else {
      - determine '<def[string].as_list>'
      }


################################################################################
#
#  FlagTypeMatch Procedure script
#
#    Used to check that the player specified value matches the type required
#   by the flag.
#
#    Use this to compare 2 values. Check if they are one of NUMBER, DECIMAL,
#   LOCATION, BOOLEAN, STATE, GROUP, LIST or any other STRING.
#
#   usage:
#     - define YourValue "Some string"
#     - define Type "<s@dRegions_Flag_%flag%.yaml_key[flag_type]||null>"
#     - define TypeMatch '<proc[dRegion_FlagTypeMatch].context[%YourValue%|%flag%]>'
#     - if <def[TypeMatch]> {
#       - narrate "%YourValue% matches %type%."
#       }
#       else {
#       - narrate "%YourValue% is a %YourValueType% not a %type%"
#       }
#
dRegion_FlagTypeMatch:
  type: procedure
  debug: false
  definitions: YourValue|Flag

  script:

    - define Type "<s@dRegions_Flag_%Flag%.yaml_key[flag_type]||null>"
    - if <def[Type].is[==].to[number]> {
      - if <def[YourValue].is[MATCHES].to[number]> {
        - determine 'true'
        }
        else {
        - determine 'false'
        }
      }
    - if <def[Type].is[==].to[decimal]> {
      - if <def[YourValue].is[MATCHES].to[decimal]> {
        - determine 'true'
        }
        else {
        - determine 'false'
        }
      }
    - if <def[Type].is[==].to[boolean]> {
      - if <def[YourValue].is[MATCHES].to[boolean]> {
        - determine 'true'
        }
        else {
        - determine 'false'
        }
      }
    - if <def[Type].is[==].to[location]> {
      - if <def[YourValue].as_location.world.is[!=].to[null]||false> {
        - determine 'true'
        }
        else {
        - determine 'false'
        }
      }
    - if <def[Type].is[==].to[state]> {
      - if <el@val[allow|deny|none].as_list.contains[%YourValue%]||false> {
        - determine 'true'
        }
        else {
        - determine 'false'
        }
      }
    - if <def[Type].is[==].to[group]> {
      - if <el@val[members|nonmembers|owners|nonowners|all].as_list.contains[%YourValue%]||false> {
        - determine 'true'
        }
        else {
        - determine 'false'
        }
      }
    - if <def[Type].is[==].to[list]> {
      - if '<def[YourValue].split[ ].get[1].contains_any_text[-a|-r]||false>' {
        - determine 'true'
        }
        else {
        - determine 'false'
        }
      }
    - if <def[Type].is[==].to[custom]> {
      - if <s@dRegions_Flag_%flag%.yaml_key[flag_type_customVal].as_list.contains[%YourValue%]||false> {
        - determine 'true'
        }
        else {
        - determine 'false'
        }
      }
    - if <def[Type].is[==].to[string]> {
      - if <def[YourValue].is[!=].to[null]||false> {
        - determine 'true'
        }
        else {
        - determine 'false'
        }
      }
    - determine 'false'

#
#  END other utilities
#--------------------------------------
#
#  dRegions author banner items
#
# Banner items representing the authors
#
dRegions_Author_Anthony:
  type: item
  debug: false
  material: i@human_skull
  display name: "<&f>             |Anthony|"
  lore:
  - <&7>  Owner<&co> <&e>M<&6>ine<&e>C<&6>onomy <&e>N<&6>etwork
  - <&5>-------------------------
  - <&7>
  - <&7>  I`ve been playing minecraft
  - <&7> and running a server since
  - <&7> 2010. I have fun and share
  - <&7> what I do.
  - <&7>
  - <&9>           Click To Visit
#
#  END dRegions author banner items
#--------------------------------------
#
#  dRegions Interaction Mapping
#
# Mapping what to do when interacting with blocks and items
#
dRegions_Map_Interactions:
  type: yaml data

  block:
# Containers
    chest: openContainer
    ender_chest: openContainer
    locked_chest: openContainer
    trapped_chest: openContainer
    dispenser: openContainer
    hopper: openContainer
    dropper: openContainer
# Doors
    trap_door: openDoor
    iron_trapdoor: openDoor
    wooden_door: openDoor
    iron_door_block: openDoor
    spruce_door: openDoor
    birch_door: openDoor
    jungle_door: openDoor
    dark_oak_door: openDoor
    acacia_door: openDoor
    fence_gate: openDoor
    spruce_fence_gate: openDoor
    birch_fence_gate: openDoor
    jungle_fence_gate: openDoor
    dark_oak_fence_gate: openDoor
    acacia_fence_gate: openDoor
# Switches
    lever: useSwitch
    wood_button: useSwitch
    stone_button: useSwitch
    wood_plate: useSwitch
    stone_plate: useSwitch
    iron_plate: useSwitch
    gold_plate: useSwitch
# Utility Blocks
    workbench: useUtility
    furnace: useUtility
    burning_furnace: useUtility
    brewing_stand: useUtility
    enchantment_table: useUtility
    anvil: useUtility
    beacon: useUtility
#    jukebox: useUtility
    note_block: useUtility
#    cauldron: useUtility
#    tnt: useUtility
# Other blocks that change when clicked regardless of item in hand
    flower_pot: Build
    cake_block: Build
    diode_block_on: Build
    diode_block_off: Build
    redstone_comparator_off: Build
    redstone_comparator_on: Build

  block_withItem:
    jukebox: useUtility/gold_record|green_record|record_3|record_4|record_5|record_6|record_7|record_8|record_9|record_10|record_11|record_12
    cauldron: useUtility/bucket|water_bucket|glass_bottle
    tnt: useUtility/flint_and_steel
    activator_rail: placeVehicle/minecart|storage_minecart|powered_minecart|explosive_minecart|hopper_minecart|command_minecart
    detector_rail: placeVehicle/minecart|storage_minecart|powered_minecart|explosive_minecart|hopper_minecart|command_minecart
    powered_rail: placeVehicle/minecart|storage_minecart|powered_minecart|explosive_minecart|hopper_minecart|command_minecart
    rails: placeVehicle/minecart|storage_minecart|powered_minecart|explosive_minecart|hopper_minecart|command_minecart
    stationary_water: placeVehicle/boat
    water: placeVehicle/boat

  item:
    ink_sac:
    gold_record: jukebox
    glass_bottle: cauldron
    flint_and_steel: tnt

#
#  END dRegions Interaction Mapping
#--------------------------------------




################################################################################
#                                                                              #
# Configuration Files                                                          #
#                                                                              #
#   These are the default config files. They will be used to build the default #
# configuration and data storage files.                                        #
#                                                                              #
#______________________________________________________________________________#
#                                                                              #
#______________________________DO_NOT_EDIT_THIS_DATA___________________________#
#______________________________________________________________________________#


dRegions_Configurations:
  type: yaml data

  config:
    version: 0.26
    regions:
      enable: true
      invincibility-removes-mobs: false
      wand: dWE_Wand
      claim:
        max-volume: 0
        only-inside-existing-regions: true
        max-region-count-per-player:
          default: 7
    spread:
      water: true
      water-list: []
      lava: true
      lava-list: []
      mycel: true
      grass: true
      mushroom: true
      vines: true
    physics:
      gravel: true
      sand: true
    portal:
      create: true
      entity-enter: true
      player-enter: true
    fire:
      ender_crystal: true
      explosion: true
      fireball: true
      flint_and_steel: true
      lava: true
      spread: true
      spread-list: []
      destroyBlocks: true
      destroyBlocks-list: []
    entity:
      changeBlocks: true
      changeBlocks-list: []
      explode: true
      explode-list: []
    entity-break-item_frame: true
    entity-break-painting: true
    blockform:
      ice: true
      snow: true
      snow-list: []
    blockfade:
      ice: true
      snow: true
    lightning-strike: true
    lightning-strike-list: []
    trample-crops:
      player: true
      entity: true
    leaf-decay: true
#    auto-invincible: false
#    protection:
#      item-durability: true
#      remove-infinite-stacks: false
#      disable-xp-orb-drops: false
#      disable-obsidian-generators: true
#    ignition:
#      block-tnt: false
#      block-tnt-block-damage: false
#      block-lighter: false
#    mobs:
#      block-creeper-explosions: false
#      block-creeper-block-damage: false
#      block-wither-explosions: false
#      block-wither-block-damage: false
#      block-wither-skull-explosions: false
#      block-wither-skull-block-damage: false
#      block-enderdragon-block-damage: false
#      block-fireball-explosions: false
#      block-fireball-block-damage: false
#      disable-enderman-griefing: false
#      block-painting-destroy: false
#      block-item-frame-destroy: false
#      block-creature-spawn: []
#    player-damage:
#      disable-fall-damage: false
#      disable-lava-damage: false
#      disable-fire-damage: false
#      disable-lightning-damage: false
#      disable-drowning-damage: false
#      disable-suffocation-damage: false
#      disable-contact-damage: false
#      teleport-on-suffocation: false
#      disable-void-damage: false
#      teleport-on-void-falling: false
#      disable-explosion-damage: false
#      disable-mob-damage: false
#      disable-death-messages: false
#    crops:
#      disable-creature-trampling: false
#      disable-player-trampling: false
#    weather:
#      prevent-lightning-strike-blocks: []
#      disable-lightning-strike-fire: false
#      disable-thunderstorm: false
#      disable-weather: false
#      disable-pig-zombification: false
#      disable-powered-creepers: false
#      always-raining: false
#      always-thundering: false
#    dynamics:
#      disable-mushroom-spread: false
#      disable-ice-melting: false
#      disable-snow-melting: false
#      disable-snow-formation: false
#      disable-ice-formation: false
#      disable-leaf-decay: false
#      disable-grass-growth: false
#      disable-mycelium-spread: false

  regions:
    __global__:
      type: global
      priority: 0
      flags: []
      owners: []
      members: []

  inventories:
    info:
      - This is the inventory save file.
      - DO NOT EDIT!
    example:
      region:
        entry:
          kit:
            equip: []
            inv: []
          players:
            player:
              equip: []
              inv: []
        exit:
          players:
            player:
              equip: []
              inv: []


#
