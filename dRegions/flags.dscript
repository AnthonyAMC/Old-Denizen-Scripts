################################################################################
#
#                                d R e g i o n s
#
#                                 Flag Modules
#
#   Authors: |Anthony|
#   Version: 0.1
#   dScript Version: 0.9.6-DEV_b60
#
#
#
#--- About this script
#
#  Adding new flags /can/ be as easy as making a new module!
#
#
#
################################################################################


dRegions_Flag_Entry:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Entry<&4>]"
  lore:
  - <&5>Who can enter a region
  event_hook: regionEnter
  event_priority: 0
  flag_type: state
  flag_takeGroup: true
  flag_defaultValue: allow/all
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event-cleanup:
    - if <player.has_flag[dRegions_Message_Cooldown].not> {
      - flag player dRegions_Message_Cooldown duration:3s
      - run instantly s@dRegions_Msg 'def:<&c><&o>You do not have permission to enter this region'
      }

  event:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - define player <player>
      - define flag 'entry'
      - inject s@dRegions_Flags_Processors p:state-withGroup instantly
      }


dRegions_Flag_Greeting:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Greeting<&4>]"
  lore:
  - <&5>Message on enter region
  event_hook: regionEnter
  event_priority: 10
  flag_type: string
  flag_takeGroup: false
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
  # Now using GetInheritedFlag procedure
  # I split the tag up into 3 parts so folks could maybe possibly better understand it
  # The original msgList is left commented out. No touchy
    - define prefix '<&lt>proc<&lb>dRegions_GetInheritedFlag<&rb>.context<&lb>%world%<&pipe>'
    - define suffix '<&pipe>greeting<&rb>||null<&gt>'
    - define msgList '<parse:<def[orderedRegions].parse[replace[regex:^()].with[<def[prefix]>]].parse[replace[regex:()$].with[<def[suffix]>]]>>'
#    - define msgList '<parse:<def[orderedRegions].parse[replace[regex:^()].with[<&lt>yaml<&lb>dRegions_%world%_regions<&rb>.read<&lb>regions.]].parse[replace[regex:()$].with[.flags.greeting<&rb>||null<&gt>]]>>'
    - foreach %msgList% {
      - if <def[value].is[!=].to[null]||false> {
        - narrate "<parse:%value%>"
        - foreach stop
        }
      }


dRegions_Flag_Exit:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Exit<&4>]"
  lore:
  - <&5>Who can exit a region
  event_hook: regionExit
  event_priority: 0
  flag_type: state
  flag_takeGroup: true
  flag_defaultValue: allow/all
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event-cleanup:
    - if <player.has_flag[dRegions_Message_Cooldown].not> {
      - flag player dRegions_Message_Cooldown duration:3s
      - run instantly s@dRegions_Msg 'def:<&c><&o>You do not have permission to exit this region'
      }

  event:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - define player <player>
      - define flag 'exit'
      - inject s@dRegions_Flags_Processors p:state-withGroup instantly
      }


dRegions_Flag_Farewell:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Farewell<&4>]"
  lore:
  - <&5>Message on exit region
  event_hook: regionExit
  event_priority: 10
  flag_type: string
  flag_takeGroup: false
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - define prefix '<&lt>proc<&lb>dRegions_GetInheritedFlag<&rb>.context<&lb>%world%<&pipe>'
    - define suffix '<&pipe>farewell<&rb>||null<&gt>'
    - define msgList '<parse:<def[orderedRegions].parse[replace[regex:^()].with[<def[prefix]>]].parse[replace[regex:()$].with[<def[suffix]>]]>>'
    - foreach %msgList% {
      - if <def[value].is[!=].to[null]||false> {
        - narrate "<parse:%value%>"
        - foreach stop
        }
      }


dRegions_Flag_Gamemode:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Gamemode<&4>]"
  lore:
  - <&5>Change gamemode inside a region
  event_hook: regionToggle
  event_priority: 20
  flag_type: custom
  flag_type_customVal: creative|survival|adventure
  flag_help: Gamemode flag can be set to creative, survival, or adventure
  flag_takeGroup: true
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - define prefix '<&lt>proc<&lb>dRegions_GetInheritedFlag<&rb>.context<&lb>%world%<&pipe>'
    - define suffix '<&pipe>gamemode<&rb>||null<&gt>'
    - define gmList '<parse:<def[orderedRegions].parse[replace[regex:^()].with[<def[prefix]>]].parse[replace[regex:()$].with[<def[suffix]>]]>>'
    - foreach %gmList% {
      - if <def[value].is[!=].to[null]||false> {
        - define region "<def[orderedRegions].get[<def[loop_index]>]>"
        - define gm '<def[value].split[/].get[1]||survival>'
        - define group '<def[value].split[/].get[2]||all>'
        - define isOwner '<proc[dRegions_IsOwner].context[<def[region]>|%world%|<player>]>'
        - define isMember '<proc[dRegions_isMember].context[<def[region]>|%world%|<player>]>'

        - if <proc[dRegions_PlayerMatchRegionGroup].context[%group%|%isMember%|%isOwner%]> {
          - if <def[isExit].exists> {
            - if <player.flag[dRegions_<def[world]>_<def[region]>_PreviousGamemode].is[!=].to[<player.gamemode>]||false> {
              - adjust <player> 'gamemode:<player.flag[dRegions_<def[world]>_<def[region]>_PreviousGamemode]||survival>'
              - run instantly s@dRegions_Msg 'def:<&7><&o>Your gamemode has been updated.'
              }
            - flag <player> 'dRegions_<def[world]>_<def[region]>_PreviousGamemode:!'
            }
            else if <def[isEnter].exists> {
            - if <def[gm].is[!=].to[<player.gamemode>]> {
              - flag <player> 'dRegions_<def[world]>_<def[region]>_PreviousGamemode:<player.gamemode>'
              - adjust <player> 'gamemode:%gm%'
              - run instantly s@dRegions_Msg 'def:<&7><&o>Your gamemode has been updated.'
              }
            }
            else {
            - adjust <player> 'gamemode:survival'
            - run instantly s@dRegions_Msg 'def:<&7><&o>Your gamemode has been updated.'
            }
          - foreach stop
          }
        }
      }


dRegions_Flag_Inventory:
  type: item
  debug: true
  material: i@paper
  display name: "<&4>[<&6>Inventory<&4>]"
  lore:
  - <&5>Save inventory before going into a region
  event_hook: regionToggle
  event_priority: 10
  flag_type: custom
  flag_type_customVal: unique|kit
  flag_help: Inventory flag can be set to unique or kit. Unique inventories start empty. Kit inventories use your current inventory.
  flag_takeGroup: true
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - if <def[flagValue].is[==].to[kit]> {
      - yaml set 'inventories.regions.%region%.entry.kit.equip:<player.equipment>' 'id:dRegions_%world%_inventories'
      - yaml set 'inventories.regions.%region%.entry.kit.inv:<player.inventory.list_contents>' 'id:dRegions_%world%_inventories'
      - yaml set 'inventories.regions.%region%.exit.players:|:' 'id:dRegions_%world%_inventories'
      }
    - if <def[flagValue].is[==].to[unique]> {
      - yaml set 'inventories.regions.%region%.entry.players:|:' 'id:dRegions_%world%_inventories'
      - yaml set 'inventories.regions.%region%.exit.players:|:' 'id:dRegions_%world%_inventories'
      }
    - if <def[flagValue].is[==].to[null]> {
      - yaml set 'inventories.regions.%region%:!' 'id:dRegions_%world%_inventories'
      }
    - yaml 'savefile:dRegions/worlds/%world%/inventories.yml' 'id:dRegions_%world%_inventories'

  event:
    - define prefix '<&lt>proc<&lb>dRegions_GetInheritedFlag<&rb>.context<&lb>%world%<&pipe>'
    - define suffix '<&pipe>inventory<&rb>||null<&gt>'
    - define invList '<parse:<def[orderedRegions].parse[replace[regex:^()].with[<def[prefix]>]].parse[replace[regex:()$].with[<def[suffix]>]]>>'
    - foreach %invList% {
      - define region '<def[orderedRegions].get[%loop_index%]>'
      - if <def[value].is[!=].to[null]||false> {
        - define inv '<def[value].split[/].get[1]||unique>'
        - define group '<def[value].split[/].get[2]||nonmembers>'
        - define isOwner '<proc[dRegions_IsOwner].context[%region%|%world%|<player>]>'
        - define isMember '<proc[dRegions_isMember].context[%region%|%world%|<player>]>'

        - if <proc[dRegions_PlayerMatchRegionGroup].context[%group%|%isMember%|%isOwner%]> {
          - if <def[isEnter].exists> {
            - if <def[inv].is[==].to[kit]||false> {
              - yaml set 'inventories.regions.%region%.exit.players.<player.uuid>.equip:<player.equipment>' 'id:dRegions_%world%_inventories'
              - yaml set 'inventories.regions.%region%.exit.players.<player.uuid>.inv:<player.inventory.list_contents>' 'id:dRegions_%world%_inventories'
              - inventory clear
              - inventory set 'd:<player.inventory>' 'o:<yaml[dRegions_%world%_inventories].read[inventories.regions.%region%.entry.kit.inv]||li@>'
              - define equipment '<yaml[dRegions_%world%_inventories].read[inventories.regions.%region%.entry.kit.equip]||li@>'
              - equip <player> 'boots:<def[equipment].get[1]||i@air>' 'legs:<def[equipment].get[2]||i@air>' 'chest:<def[equipment].get[3]||i@air>' 'head:<def[equipment].get[4]||i@air>'
              }
              else if <def[inv].is[==].to[unique]||false> {
              - yaml set 'inventories.regions.%region%.exit.players.<player.uuid>.equip:<player.equipment>' 'id:dRegions_%world%_inventories'
              - yaml set 'inventories.regions.%region%.exit.players.<player.uuid>.inv:<player.inventory.list_contents>' 'id:dRegions_%world%_inventories'
              - inventory clear
              - inventory set 'd:<player.inventory>' 'o:<yaml[dRegions_%world%_inventories].read[inventories.regions.%region%.entry.players.<player.uuid>.inv]||li@>'
              - define equipment '<yaml[dRegions_%world%_inventories].read[inventories.regions.%region%.entry.players.<player.uuid>.equip]||li@>'
              - equip <player> 'boots:<def[equipment].get[1]||i@air>' 'legs:<def[equipment].get[2]||i@air>' 'chest:<def[equipment].get[3]||i@air>' 'head:<def[equipment].get[4]||i@air>'
              }
            - run instantly s@dRegions_Msg 'def:<&7><&o>Your inventory has been updated.'
            }
            else if <def[isExit].exists> {
            - if <def[inv].is[==].to[kit]||false> {
              - define equipment '<yaml[dRegions_%world%_inventories].read[inventories.regions.%region%.exit.players.<player.uuid>.equip]||li@>'
              - inventory clear
              - inventory set 'd:<player.inventory>' 'o:<yaml[dRegions_%world%_inventories].read[inventories.regions.%region%.exit.players.<player.uuid>.inv]||li@>'
              - equip <player> 'boots:<def[equipment].get[1]||i@air>' 'legs:<def[equipment].get[2]||i@air>' 'chest:<def[equipment].get[3]||i@air>' 'head:<def[equipment].get[4]||i@air>'
              - yaml set 'inventories.regions.%region%.exit.players.<player.uuid>:!' 'id:dRegions_%world%_inventories'
              - run instantly s@dRegions_Msg 'def:<&7><&o>Your inventory has been updated.'
              }
              else if <def[inv].is[==].to[unique]||false> {
              - yaml set 'inventories.regions.%region%.entry.players.<player.uuid>.equip:<player.equipment>' 'id:dRegions_%world%_inventories'
              - yaml set 'inventories.regions.%region%.entry.players.<player.uuid>.inv:<player.inventory.list_contents>' 'id:dRegions_%world%_inventories'
              - define equipment '<yaml[dRegions_%world%_inventories].read[inventories.regions.%region%.exit.players.<player.uuid>.equip]||li@>'
              - inventory clear
              - inventory set 'd:<player.inventory>' 'o:<yaml[dRegions_%world%_inventories].read[inventories.regions.%region%.exit.players.<player.uuid>.inv]||li@>'
              - equip <player> 'boots:<def[equipment].get[1]||i@air>' 'legs:<def[equipment].get[2]||i@air>' 'chest:<def[equipment].get[3]||i@air>' 'head:<def[equipment].get[4]||i@air>'
              - yaml set 'inventories.regions.%region%.exit.players.<player.uuid>:!' 'id:dRegions_%world%_inventories'
              - run instantly s@dRegions_Msg 'def:<&7><&o>Your inventory has been updated.'
              }
            }
            else {
            - run instantly s@dRegions_Msg 'def:<&7><&o>THIS SHOULD NOT RUN EVER!'
            }
          - yaml 'savefile:dRegions/worlds/%world%/inventories.yml' 'id:dRegions_%world%_inventories'
          - foreach stop
          }
        }
      }


dRegions_Flag_Build:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Build<&4>]"
  lore:
  - <&5>Override default build perms
  event_hook: build
  event_priority: 0
  flag_type: state
  flag_help: By default, all members and owners can build in their regions. Setting this flag can over ride that behavior. Can be set to allow, deny, or none and accepts the -g group switch.
  flag_takeGroup: true
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
  # Build is handled differently than the other flags. It checks only the HIGHEST
  # priority region. It does inherit owners, members, and flags from parent regions.
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - define region '<def[orderedRegions].get[1]>'
      - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|build]||null>'
      - if <def[flagVal].is[==].to[null]||true> {
        - define flagVal 'deny/nonmembers'
        }
      - define flag '<def[flagVal].split[/].get[1]>'
      - define group '<def[flagVal].split[/].get[2]||nonmembers>'
      - define isOwner '<proc[dRegions_IsOwner].context[<def[orderedRegions].get[%loop_index%]>|%world%|<player>]>'
      - define isMember '<proc[dRegions_isMember].context[<def[orderedRegions].get[%loop_index%]>|%world%|<player>]>'

      - if <def[flag].is[==].to[deny]||false> {
        - if <proc[dRegions_PlayerMatchRegionGroup].context[%group%|%isMember%|%isOwner%]> {
          - if <player.has_flag[dRegions_Message_Cooldown].not> {
            - flag player dRegions_Message_Cooldown duration:3s
            - run instantly s@dRegions_Msg 'def:<&c><&o>You do not have permission to build in this region'
            }
          - determine cancelled
          - queue clear
          }
        }

      - if <def[flag].is[==].to[allow]||false> {
        - if <proc[dRegions_PlayerMatchRegionGroup].context[%group%|%isMember%|%isOwner%].not> {
          - if <player.has_flag[dRegions_Message_Cooldown].not> {
            - flag player dRegions_Message_Cooldown duration:3s
            - run instantly s@dRegions_Msg 'def:<&c><&o>You do not have permission to build in this region'
            }
          - determine cancelled
          - queue clear
          }
        }
      }


dRegions_Flag_Mob-Targeting:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Mob-Targeting<&4>]"
  lore:
  - <&5>Can mobs target players
  event_hook: ENTITY_Target_Player
  event_priority: 0
  flag_type: state
  flag_takeGroup: true
  flag_defaultValue: allow/all
  flag_help: State flag controlling whether mobs will be able to target players in this region. Defaults to allow all. Use mob-target flag to specify mob types. Takes the -g group switch.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - define player <c.target>
    - define flag 'mob-targeting'
    - define flag-targetList 'mob-target'
    - inject s@dRegions_Flags_Processors p:state-withTarget-withGroup instantly

  event-cleanup:
    - remove <c.projectile||li@>
    - attack <c.entity||li@> target:cancel


dRegions_Flag_Mob-Target:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Mob-Target<&4>]"
  lore:
  - <&5>List of mobs used by mob-targeting flag
  command_entryType: mob
  command_verifyEntry: <def[value].is[matches].to[entity].not>
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with mob-targeting flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of mobs.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - inject instantly s@dRegions_Flags_CommandProcessors p:command_verifiedList


dRegions_Flag_Mob-Damage:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Mob-Damage<&4>]"
  lore:
  - <&5>Can mobs damage players
  event_hook: ENTITY_Damage_Player
  event_priority: 10
  flag_type: state
  flag_takeGroup: true
  flag_defaultValue: allow/all
  flag_help: State flag controlling whether mobs will be able to damage players in this region. Defaults to allow all. Use mob-damagelist flag to specify mob types. Takes the -g group switch.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - define player <c.entity>
    - define flag 'mob-damage'
    - define flag-targetList 'mob-damagelist'
    - inject s@dRegions_Flags_Processors p:state-withTarget-withGroup instantly

  event-cleanup:
    - remove <c.projectile||li@>
    - attack <c.damager||li@> target:cancel


dRegions_Flag_Mob-Damagelist:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Mob-DamageList<&4>]"
  lore:
  - <&5>List of mobs used by mob-damage flag
  command_entryType: mob
  command_verifyEntry: <def[value].is[matches].to[entity].not>
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with mob-damage flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of mobs.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - inject instantly s@dRegions_Flags_CommandProcessors p:command_verifiedList


dRegions_Flag_Mob-Spawn:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Mob-Spawn<&4>]"
  lore:
  - <&5>Can mobs Spawn
  event_hook: ENTITY_Spawn
  event_priority: 10
  flag_type: state
  flag_takeGroup: false
  flag_defaultValue: allow
  flag_help: State flag controlling whether mobs will be able to spawn in this region. Defaults to allow all. Use mob-spawnlist flag to specify mob types.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - define flag 'mob-spawn'
    - define flag-targetList 'mob-spawnlist'
    - inject s@dRegions_Flags_Processors p:state-withTarget


dRegions_Flag_Mob-SpawnList:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Mob-Spawnlist<&4>]"
  lore:
  - <&5>List of mobs used by mob-spawn flag
  command_entryType: mob
  command_verifyEntry: <def[value].is[matches].to[entity].not>
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with mob-spawn flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of mobs.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - inject instantly s@dRegions_Flags_CommandProcessors p:command_verifiedList


dRegions_Flag_PVE:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>PVE<&4>]"
  lore:
  - <&5>Can players damage mobs
  event_hook: PLAYER_Damage_Entity
  event_priority: 10
  flag_type: state
  flag_takeGroup: true
  flag_defaultValue: allow/all
  flag_help: State flag controlling whether players will be able to damage mobs in this region. Defaults to allow all. Use pve-moblist flag to specify mob types. Takes the -g group switch.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - define player <c.damager>
      - define target '<c.entity.entity_type>'
      - define flag 'pve'
      - define flag-targetList 'pve-moblist'
      - inject s@dRegions_Flags_Processors p:state-withTarget-withGroup instantly
      }

  event-cleanup:
    - remove <c.projectile||li@>
    - if <player.has_flag[dRegions_Message_Cooldown].not> {
      - flag player dRegions_Message_Cooldown duration:3s
      - run instantly s@dRegions_Msg 'def:<&c><&o>You can not attack <def[target]> here!'
      }


dRegions_Flag_PVE-Moblist:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>PVE-Moblist<&4>]"
  lore:
  - <&5>List of mobs used by pve flag
  command_entryType: mob
  command_verifyEntry: <def[value].is[matches].to[entity].not>
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with pve flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of mobs.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - inject instantly s@dRegions_Flags_CommandProcessors p:command_verifiedList


dRegions_Flag_Entity-Explode:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Entity-Explode<&4>]"
  lore:
  - <&5>Can entities explode
  event_hook: entity-explode
  event_priority: 10
  flag_type: state
  flag_takeGroup: false
  flag_defaultValue: allow
  flag_help: State flag controlling whether entities will be able to explode in this region. Defaults to allow all. Use entity-explodelist flag to specify entities types.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - define flag 'entity-explode'
    - define flag-targetList 'entity-explodelist'
    - inject s@dRegions_Flags_Processors p:state-withTarget


dRegions_Flag_Entity-ExplodeList:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Entity-Explodelist<&4>]"
  lore:
  - <&5>List of mobs used by entity-explode flag
  command_entryType: entity
  command_verifyEntry: <el@val[creeper|ender_crystal|ender_dragon|primed_tnt|minecart_tnt|fireball|small_fireball|wither|wither_skull].as_list.contains[<def[value]>].not>
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with entity-explode flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of entities. Valid entities<&co> creeper, ender_crystal, ender_dragon, primed_tnt, minecart_tnt, fireball, small_fireball, wither, wither_skull
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - inject instantly s@dRegions_Flags_CommandProcessors p:command_verifiedList


dRegions_Flag_Entity-Grief:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Entity-Grief<&4>]"
  lore:
  - <&5>Can entities alter blocks
  event_hook: entity-changeBlock
  event_priority: 10
  flag_type: state
  flag_takeGroup: false
  flag_defaultValue: allow
  flag_help: State flag controlling whether entities will be able to alter blocks in this region. Defaults to allow all. Use entity-grieflist flag to specify entities types.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - define flag 'entity-grief'
    - define flag-targetList 'entity-grieflist'
    - inject s@dRegions_Flags_Processors p:state-withTarget


dRegions_Flag_Entity-GriefList:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Entity-Grieflist<&4>]"
  lore:
  - <&5>List of mobs used by entity-grief flag
  command_entryType: entity
  command_verifyEntry: <el@val[enderman|sheep|zombie|squid].as_list.contains[<def[value]>].not>
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with entity-grief flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of entities. Valid entities<&co> sheep, enderman, zombie, squid
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - inject instantly s@dRegions_Flags_CommandProcessors p:command_verifiedList


dRegions_Flag_Entity-Drops-OnDeath:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Entity-Drops-OnDeath<&4>]"
  lore:
  - <&5>Can mobs drop items
  event_hook: EntityDies
  event_priority: 10
  flag_type: state
  flag_takeGroup: false
  flag_defaultValue: allow
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event-cleanup:
    - determine no_drops

  event:
    - repeat 1 {
      - if <c.entity.is_living.not> {
        - repeat stop
        }
      - define flag 'entity-drops-ondeath'
      - define flag-targetList 'entity-drops-ondeathlist'
      - inject s@dRegions_Flags_Processors p:state-withTarget
      }


dRegions_Flag_Entity-Drops-OnDeathList:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Entity-Drops-OnDeathlist<&4>]"
  lore:
  - <&5>List of mobs used by entity-drops-ondeath flag
  command_entryType: entity
  command_verifyEntry: <def[value].is[matches].to[entity].not>
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with entity-drops-ondeath flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of entities.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - inject instantly s@dRegions_Flags_CommandProcessors p:command_verifiedList


dRegions_Flag_Fire-Spread:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Fire-Spread<&4>]"
  lore:
  - <&5>Can fire spread
#  event_hook: fireFrom-Spread
  event_priority: 10
  flag_type: state
  flag_takeGroup: false
  flag_defaultValue: allow
#  flag_help: State flag controlling whether fire will be able to spread in this region. Defaults to allow all. Use fire-spreadblocks flag to specify blocks to check when spreading.
  flag_help: This flag is temporarily disabled. Please use the fire-destroyblocks flag.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - define flag 'fire-spread'
    - define flag-targetList 'fire-spreadblocks'
    - inject s@dRegions_Flags_Processors p:state-withTarget

  command_handler:
    - define lines '<proc[dRegions_LineWrap].context[<s@dRegions_Flag_%Flag%.yaml_key[flag_help]||<&c>%flag% flag requires a %type% value!>|45]>'
    - foreach <def[lines]> {
      - run instantly s@dRegions_Msg 'def:<&c><def[value]>'
      }
    - queue clear


dRegions_Flag_Fire-SpreadBlocks:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Fire-Spread-BlockList<&4>]"
  lore:
  - <&5>List of blocks involved in fire spread
  command_entryType: block
  command_verifyEntry: <def[value].as_material.is_block.not||true>
  flag_type: list
  flag_takeGroup: false
#  flag_help: List flag used with fire-spread flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of blocks.
  flag_help: This flag is temporarily disabled. Please use the fire-destroyblocks flag.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - define lines '<proc[dRegions_LineWrap].context[<s@dRegions_Flag_%Flag%.yaml_key[flag_help]||<&c>%flag% flag requires a %type% value!>|45]>'
    - foreach <def[lines]> {
      - run instantly s@dRegions_Msg 'def:<&c><def[value]>'
      }
    - queue clear
#    - inject instantly s@dRegions_Flags_CommandProcessors p:command_verifiedList


dRegions_Flag_Fire-Destroy:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Fire-Destroy<&4>]"
  lore:
  - <&5>Can fire destroy blocks
  event_hook: fire-destroyBlocks
  event_priority: 10
  flag_type: state
  flag_takeGroup: false
  flag_defaultValue: allow
  flag_help: State flag controlling whether fire will be able to spread to and destroy blocks in this region. Defaults to allow all. Use fire-destroyblocks flag to specify blocks to check when spreading.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - define flag 'fire-destroy'
    - define flag-targetList 'fire-destroyblocks'
    - inject s@dRegions_Flags_Processors p:state-withTarget


dRegions_Flag_Fire-DestroyBlocks:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Fire-Destroy-BlockList<&4>]"
  lore:
  - <&5>List of blocks involved in fire-destroy
  command_entryType: block
  command_verifyEntry: <def[value].as_material.is_block.not||true>
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with fire-destroy flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of blocks.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - inject instantly s@dRegions_Flags_CommandProcessors p:command_verifiedList


dRegions_Flag_Lightning-Strikes:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Lightning-Strikes<&4>]"
  lore:
  - <&5>Can lightning strike
  event_hook: lightning-strikes
  event_priority: 10
  flag_type: state
  flag_takeGroup: false
  flag_defaultValue: allow
  flag_help: State flag controlling whether lightning will be able to strike in this region. Defaults to allow all. Use lightning-strikeblocks flag to specify blocks to check when striking.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - define flag 'lightning-strikes'
    - define flag-targetList 'lightning-strikesblocks'
    - inject s@dRegions_Flags_Processors p:state-withTarget


dRegions_Flag_Lightning-StrikesBlocks:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Lightning-StrikesBlocks<&4>]"
  lore:
  - <&5>List of blocks involved in lightning strikes
  command_entryType: block
  command_verifyEntry: <def[value].as_material.is_block.not||true>
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with lightning-strike flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of blocks.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - inject instantly s@dRegions_Flags_CommandProcessors p:command_verifiedList


dRegions_Flag_Water-Spread:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Water-Spread<&4>]"
  lore:
  - <&5>Can Water spread
  event_hook: WaterSpread
  event_priority: 10
  flag_type: state
  flag_takeGroup: false
  flag_defaultValue: allow
  flag_help: State flag controlling whether water will be able to spread in this region. Defaults to allow all. Use water-spreadblocks flag to specify blocks to check when spreading.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - define flag 'water-spread'
    - define flag-targetList 'water-spreadblocks'
    - inject s@dRegions_Flags_Processors p:state-withTarget


dRegions_Flag_Water-SpreadBlocks:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Water-Spread-BlockList<&4>]"
  lore:
  - <&5>List of blocks involved in fire spread
  command_entryType: block
  command_verifyEntry: <def[value].as_material.is_block.not||true>
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with water-spread flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of blocks.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - inject instantly s@dRegions_Flags_CommandProcessors p:command_verifiedList


dRegions_Flag_Lava-Spread:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Lava-Spread<&4>]"
  lore:
  - <&5>Can Lava spread
  event_hook: LavaSpread
  event_priority: 10
  flag_type: state
  flag_takeGroup: false
  flag_defaultValue: allow
  flag_help: State flag controlling whether lava will be able to spread in this region. Defaults to allow all. Use lava-spreadblocks flag to specify blocks to check when spreading.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - define flag 'lava-spread'
    - define flag-targetList 'lava-spreadblocks'
    - inject s@dRegions_Flags_Processors p:state-withTarget


dRegions_Flag_Lava-SpreadBlocks:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Lava-Spread-BlockList<&4>]"
  lore:
  - <&5>List of blocks involved in lava spread
  command_entryType: block
  command_verifyEntry: <def[value].as_material.is_block.not||true>
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with lava-spread flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of blocks.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - inject instantly s@dRegions_Flags_CommandProcessors p:command_verifiedList


dRegions_Flag_Snow-Fall:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Snow-Fall<&4>]"
  lore:
  - <&5>Can Snow accumulate
  event_hook: blockForm-snow
  event_priority: 10
  flag_type: state
  flag_takeGroup: false
  flag_defaultValue: allow
  flag_help: State flag controlling whether snow will be able to accumulate on the ground in this region. Defaults to allow all. Use snow-fallblocks flag to specify blocks below the snow to check when forming.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - define flag 'snow-fall'
    - define flag-targetList 'snow-fallblocks'
    - inject s@dRegions_Flags_Processors p:state-withTarget


dRegions_Flag_Snow-FallBlocks:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Snow-Fall-BlockList<&4>]"
  lore:
  - <&5>List of blocks to check under snow
  command_entryType: block
  command_verifyEntry: <def[value].as_material.is_block.not||true>
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with snow-fall flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of blocks.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - inject instantly s@dRegions_Flags_CommandProcessors p:command_verifiedList


dRegions_Flag_Ice-Form:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Ice-Form<&4>]"
  lore:
  - <&5>Can water turn into ice
  event_hook: blockForm-ice
  event_priority: 10
  flag_type: boolean
  flag_defaultValue: true
  flag_help: Boolean flag controlling whether water will be able to turn into ice in this region. Defaults to true.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - define flag 'ice-form'
    - inject s@dRegions_Flags_Processors p:boolean


dRegions_Flag_Ice-Melt:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Ice-Melt<&4>]"
  lore:
  - <&5>Can ice melt
  event_hook: blockFade-ice
  event_priority: 10
  flag_type: boolean
  flag_defaultValue: true
  flag_help: Boolean flag controlling whether ice can melt in this region. Defaults to true.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - define flag 'ice-melt'
    - inject s@dRegions_Flags_Processors p:boolean


dRegions_Flag_Snow-Melt:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Snow-Melt<&4>]"
  lore:
  - <&5>Can snow melt
  event_hook: blockFade-snow
  event_priority: 10
  flag_type: boolean
  flag_defaultValue: true
  flag_help: Boolean flag controlling whether snow can melt in this region. Defaults to true.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - define flag 'snow-melt'
    - inject s@dRegions_Flags_Processors p:boolean


dRegions_Flag_Soil-Dry:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Soil-Dry<&4>]"
  lore:
  - <&5>Can soil dry up
  event_hook: blockFade-soil
  event_priority: 10
  flag_type: boolean
  flag_defaultValue: true
  flag_help: Boolean flag controlling whether soil can dry in this region. Defaults to true.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - define flag 'soil-dry'
    - inject s@dRegions_Flags_Processors p:boolean


dRegions_Flag_Trample-Crops-Player:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Trample-Crops-Player<&4>]"
  lore:
  - <&5>Can players trample crops
  event_hook: trample-crops-player
  event_priority: 10
  flag_type: boolean
  flag_defaultValue: true
  flag_help: Boolean flag controlling whether players can trample crops in this region. Defaults to true.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - define flag 'trample-crops-player'
    - inject s@dRegions_Flags_Processors p:boolean


dRegions_Flag_Trample-Crops-Entity:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Trample-Crops-Entity<&4>]"
  lore:
  - <&5>Can entities trample crops
  event_hook: trample-crops-entity
  event_priority: 10
  flag_type: boolean
  flag_defaultValue: true
  flag_help: Boolean flag controlling whether entities can trample crops in this region. Defaults to true.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - define flag 'trample-crops-entity'
    - inject s@dRegions_Flags_Processors p:boolean


dRegions_Flag_Mushroom-Spread:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Mushroom-Spread<&4>]"
  lore:
  - <&5>Can Mushrooms spread
  event_hook: MushroomSpread
  event_priority: 10
  flag_type: boolean
  flag_takeGroup: false
  flag_defaultValue: true
  flag_help: Boolean flag controlling whether mushrooms will be able to spread in this region. Set to true or false. Defaults to true.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - define flag 'mushroom-spread'
    - inject s@dRegions_Flags_Processors p:boolean


dRegions_Flag_Grass-Spread:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Grass-Spread<&4>]"
  lore:
  - <&5>Can Grass spread
  event_hook: GrassSpread
  event_priority: 10
  flag_type: boolean
  flag_takeGroup: false
  flag_defaultValue: true
  flag_help: Boolean flag controlling whether grass will be able to spread in this region. Set to true or false. Defaults to true.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - define flag 'grass-spread'
    - inject s@dRegions_Flags_Processors p:boolean


dRegions_Flag_Mycel-Spread:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Mycel-Spread<&4>]"
  lore:
  - <&5>Can Mycelium spread
  event_hook: MycelSpread
  event_priority: 10
  flag_type: boolean
  flag_takeGroup: false
  flag_defaultValue: true
  flag_help: Boolean flag controlling whether mycelium will be able to spread in this region. Set to true or false. Defaults to true.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - define flag 'mycel-spread'
    - inject s@dRegions_Flags_Processors p:boolean


dRegions_Flag_Vine-Growth:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Vine-Growth<&4>]"
  lore:
  - <&5>Can Vines grow
  event_hook: VinesSpread
  event_priority: 10
  flag_type: boolean
  flag_takeGroup: false
  flag_defaultValue: true
  flag_help: Boolean flag controlling whether vines will be able to grow in this region. Set to true or false. Defaults to true.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - define flag 'vine-growth'
    - inject s@dRegions_Flags_Processors p:boolean


dRegions_Flag_Leaf-Decay:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Leaf-Decay<&4>]"
  lore:
  - <&5>Can leaves decay
  event_hook: leaf-decay
  event_priority: 10
  flag_type: boolean
  flag_takeGroup: false
  flag_defaultValue: true
  flag_help: Boolean flag controlling whether leaves will be able to decay in this region. Set to true or false. Defaults to true.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - define flag 'leaf-decay'
    - inject s@dRegions_Flags_Processors p:boolean


dRegions_Flag_Falling-Sand:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Falling-Sand<&4>]"
  lore:
  - <&5>Can sand fall
  event_hook: physics-sand
  event_priority: 10
  flag_type: boolean
  flag_takeGroup: false
  flag_defaultValue: true
  flag_help: Boolean flag controlling whether sand will be able to fall in this region. Set to true or false. Defaults to true.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - define flag 'falling-sand'
    - inject s@dRegions_Flags_Processors p:boolean


dRegions_Flag_Falling-Gravel:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Falling-Gravel<&4>]"
  lore:
  - <&5>Can gravel fall
  event_hook: physics-gravel
  event_priority: 10
  flag_type: boolean
  flag_takeGroup: false
  flag_defaultValue: true
  flag_help: Boolean flag controlling whether gravel will be able to fall in this region. Set to true or false. Defaults to true.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - define flag 'falling-gravel'
    - inject s@dRegions_Flags_Processors p:boolean


dRegions_Flag_Lighter:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Lighter<&4>]"
  lore:
  - <&5>Who can use the flint and steel a region
  event_hook: fireFrom-Lighter
  event_priority: 0
  flag_type: state
  flag_takeGroup: true
  flag_defaultValue: allow/all
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event-cleanup:
    - if <player.has_flag[dRegions_Message_Cooldown].not> {
      - flag player dRegions_Message_Cooldown duration:3s
      - run instantly s@dRegions_Msg 'def:<&c><&o>You can not use a lighter in this region'
      }

  event:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - define player <player>
      - define flag 'lighter'
      - inject s@dRegions_Flags_Processors p:state-withGroup instantly
      }


dRegions_Flag_Hanging-Place:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Hanging-Place<&4>]"
  lore:
  - <&5>Who can place item frames and paintings
  event_hook: hangingPlace
  event_priority: 10
  flag_type: state
  flag_takeGroup: true
  flag_defaultValue: allow/all
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event-cleanup:
    - if <player.has_flag[dRegions_Message_Cooldown].not> {
      - flag player dRegions_Message_Cooldown duration:3s
      - run instantly s@dRegions_Msg 'def:<&c><&o>You can not hang that in this region'
      }

  event:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - define player <player>
      - define flag 'hanging-place'
      - inject s@dRegions_Flags_Processors p:state-withGroup instantly
      }


dRegions_Flag_Hanging-Break:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Hanging-Break<&4>]"
  lore:
  - <&5>Who can break item frames and paintings
  event_hook: hangingBreak
  event_priority: 10
  flag_type: state
  flag_takeGroup: true
  flag_defaultValue: allow/all
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event-cleanup:
    - if <player.has_flag[dRegions_Message_Cooldown].not> {
      - flag player dRegions_Message_Cooldown duration:3s
      - run instantly s@dRegions_Msg 'def:<&c><&o>You can not break that in this region'
      }

  event:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - define player <player>
      - define flag 'hanging-break'
      - inject s@dRegions_Flags_Processors p:state-withGroup instantly
      }


dRegions_Flag_Sleep:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Sleep<&4>]"
  lore:
  - <&5>Who can Sleep
  event_hook: sleep
  event_priority: 10
  flag_type: state
  flag_takeGroup: true
  flag_defaultValue: allow/all
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event-cleanup:
    - if <player.has_flag[dRegions_Message_Cooldown].not> {
      - flag player dRegions_Message_Cooldown duration:3s
      - run instantly s@dRegions_Msg 'def:<&c><&o>You can not sleep here.'
      }

  event:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - define player <player>
      - define flag 'sleep'
      - inject s@dRegions_Flags_Processors p:state-withGroup instantly
      }


dRegions_Flag_Player-Drops:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Player-Drops<&4>]"
  lore:
  - <&5>Who can drop items
  event_hook: player-drop
  event_priority: 10
  flag_type: state
  flag_takeGroup: true
  flag_defaultValue: allow/all
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event-cleanup:
    - if <player.has_flag[dRegions_Message_Cooldown].not> {
      - flag player dRegions_Message_Cooldown duration:3s
      - run instantly s@dRegions_Msg 'def:<&c><&o>You can not drop items here.'
      }

  event:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - define player <player>
      - define flag 'player-drops'
      - inject s@dRegions_Flags_Processors p:state-withGroup instantly
      }


dRegions_Flag_Player-Drops-OnDeath:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Player-Drops-OnDeath<&4>]"
  lore:
  - <&5>Who can drop items when they die
  event_hook: PlayerDies
  event_priority: 20
  flag_type: state
  flag_takeGroup: true
  flag_defaultValue: allow/all
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event-cleanup:
    - determine NO_DROPS

  event:
    - define player <player>
    - define flag 'player-drops-ondeath'
    - inject s@dRegions_Flags_Processors p:state-withGroup instantly


dRegions_Flag_Player-KeepItems:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Player-KeepItems<&4>]"
  lore:
  - <&5>Can players keep items on death
  event_hook: PlayerDies
  event_priority: 10
  flag_type: state
  flag_takeGroup: true
  flag_defaultValue: deny/all
  flag_help: State flag controlling whether players will keep their items when they die in a region. Default is to deny all. Takes the -g group switch.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - define prefix '<&lt>proc<&lb>dRegions_GetInheritedFlag<&rb>.context<&lb>%world%<&pipe>'
    - define suffix '<&pipe>player-keepitems<&rb>||deny<&gt>'
    - define InheritedFlags '<parse:<def[orderedRegions].parse[replace[regex:^()].with[<def[prefix]>]].parse[replace[regex:()$].with[<def[suffix]>]]>>'
    - foreach %InheritedFlags% {
      - define flagObj '<def[value]>'
      - if <def[flagObj].is[==].to[null]||true> {
        - if <def[loop_index].is[==].to[<def[InheritedFlags].size>]> {
          - define flagObj 'deny/all'
          }
          else foreach next
        }
      - define flagVal '<def[flagObj].split[/].get[1]>'
      - define group '<def[flagObj].split[/].get[2]||all>'
      - define region '<def[orderedRegions].get[%loop_index%]>'
      - define isOwner '<proc[dRegions_IsOwner].context[%region%|%world%|<player>]>'
      - define isMember '<proc[dRegions_isMember].context[%region%|%world%|<player>]>'
      - define isGroup '<proc[dRegions_PlayerMatchRegionGroup].context[%group%|%isMember%|%isOwner%]>'

      - if <def[flagVal].is[==].to[allow]||false> {
        - if <def[isGroup]> {
          - run locally returnItems 'def:<player.inventory.list_contents.escaped>|<player.equipment.escaped>' delay:2t
          - determine NO_DROPS_NO_XP
          }
          else foreach stop
        }
        else {
        - if !<def[isGroup]> {
          - run locally returnItems 'def:<player.inventory.list_contents.escaped>|<player.equipment.escaped>' delay:2t
          - determine NO_DROPS_NO_XP
          }
          else foreach stop
        }
      }

  returnItems:
    - inventory clear
    - run s@dRegions_Msg 'def:<&9>You died, but your inventory is safe!'
    - inventory set 'd:<player.inventory>' 'o:<def[1].unescaped>'
    - define equipment '<def[2].unescaped>'
    - equip <player> 'boots:<def[equipment].get[1]||i@air>' 'legs:<def[equipment].get[2]||i@air>' 'chest:<def[equipment].get[3]||i@air>' 'head:<def[equipment].get[4]||i@air>'


dRegions_Flag_Player-Pickup:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Player-Pickup<&4>]"
  lore:
  - <&5>Who can pickup items
  event_hook: player-pickup
  event_priority: 10
  flag_type: state
  flag_takeGroup: true
  flag_defaultValue: allow/all
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event-cleanup:
    - if <player.has_flag[dRegions_Message_Cooldown].not> {
      - flag player dRegions_Message_Cooldown duration:3s
      - run instantly s@dRegions_Msg 'def:<&c><&o>You can not pick up items here.'
      }

  event:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - define player <player>
      - define flag 'player-pickup'
      - inject s@dRegions_Flags_Processors p:state-withGroup instantly
      }


dRegions_Flag_Entity-Break-Painting:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Entity-Break-Painting<&4>]"
  lore:
  - <&5>Can Entities break paintings
  event_hook: entity-break-painting
  event_priority: 10
  flag_type: boolean
  flag_takeGroup: false
  flag_defaultValue: true
  flag_help: Boolean flag controlling whether mobs will be able to destroy paintings in this region. Set to true or false. Defaults to true.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - define flag 'entity-break-painting'
    - inject s@dRegions_Flags_Processors p:boolean


dRegions_Flag_Entity-Break-ItemFrame:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Entity-Break-ItemFrame<&4>]"
  lore:
  - <&5>Can Entities break item frames
  event_hook: entity-break-itemframe
  event_priority: 10
  flag_type: boolean
  flag_takeGroup: false
  flag_defaultValue: true
  flag_help: Boolean flag controlling whether mobs will be able to destroy item frames in this region. Set to true or false. Defaults to true.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - define flag 'entity-break-itemframe'
    - inject s@dRegions_Flags_Processors p:boolean


dRegions_Flag_PVP:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>PVP<&4>]"
  lore:
  - <&5>Can players damage each other
  event_hook: player_damage_player
  event_priority: 10
  flag_type: boolean
  flag_takeGroup: false
  flag_defaultValue: true
  flag_help: Boolean flag controlling whether players can attack eachother in this region. Set to true or false. Defaults to true.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event-cleanup:
    - remove <c.projectile||li@>

  event:
    - define flag 'pvp'
    - inject s@dRegions_Flags_Processors p:boolean


dRegions_Flag_Notify-Enter:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Notify-Enter<&4>]"
  lore:
  - <&5>Send notification to marked players
  event_hook: regionEnter
  event_priority: 5
  flag_type: boolean
  flag_takeGroup: false
  flag_defaultValue: false
  flag_help: Boolean flag controlling whether notifications are sent for entering this region. Set to true or false. Defaults to false.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - define player <player>
    - define prefix '<&lt>proc<&lb>dRegions_GetInheritedFlag<&rb>.context<&lb>%world%<&pipe>'
    - define suffix '<&pipe>notify-enter<&rb>||null<&gt>'
    - define msgList '<parse:<def[orderedRegions].parse[replace[regex:^()].with[<def[prefix]>]].parse[replace[regex:()$].with[<def[suffix]>]]>>'
    - foreach %msgList% {
      - if <def[value].is[==].to[true]||false> {
        - foreach <server.list_online_players.filter[has_permission[dregions.notify]].include[<server.list_online_ops>].deduplicate> {
          - run instantly s@dRegions_Msg 'def:<&5><&o><def[player].name> entered <def[orderedRegions].get[%loop_index%]> in %world%'
          }
        - foreach stop
        }
      }


dRegions_Flag_Notify-Exit:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Notify-Exit<&4>]"
  lore:
  - <&5>Send notification to marked players
  event_hook: regionExit
  event_priority: 5
  flag_type: boolean
  flag_takeGroup: false
  flag_defaultValue: false
  flag_help: Boolean flag controlling whether notifications are sent for exiting this region. Set to true or false. Defaults to false.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - define player <player>
    - define prefix '<&lt>proc<&lb>dRegions_GetInheritedFlag<&rb>.context<&lb>%world%<&pipe>'
    - define suffix '<&pipe>notify-exit<&rb>||null<&gt>'
    - define msgList '<parse:<def[orderedRegions].parse[replace[regex:^()].with[<def[prefix]>]].parse[replace[regex:()$].with[<def[suffix]>]]>>'
    - foreach %msgList% {
      - if <def[value].is[==].to[true]||false> {
        - foreach <server.list_online_players.filter[has_permission[dregions.notify]].include[<server.list_online_ops>].deduplicate> {
          - run instantly s@dRegions_Msg 'def:<&d><&o><def[player].name> left <def[orderedRegions].get[%loop_index%]> in %world%'
          }
        - foreach stop
        }
      }


dRegions_Flag_Block-Place:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Block-Place<&4>]"
  lore:
  - <&5>Can players place blocks.
  event_hook: blockPlace
  event_priority: 10
  flag_type: state
  flag_takeGroup: true
  flag_defaultValue: allow/all
  flag_help: State flag controlling whether players will be able to place blocks in this region. Defaults to allow all. Use block-placelist flag to specify block types. Takes the -g group switch.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - define player <player>
      - define flag 'block-place'
      - define flag-targetList 'block-placelist'
      - inject s@dRegions_Flags_Processors p:state-withTarget-withGroup instantly
      }

  event-cleanup:
    - if <player.has_flag[dRegions_Message_Cooldown].not> {
      - flag player dRegions_Message_Cooldown duration:3s
      - run instantly s@dRegions_Msg 'def:<&c><&o>You can not place <def[target]> in this region!'
      }


dRegions_Flag_Block-PlaceList:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Block-PlaceList<&4>]"
  lore:
  - <&5>List of blocks used by block-place flag
  command_entryType: block
  command_verifyEntry: <def[value].as_material.is_block.not||true>
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with block-place flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of blocks.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - inject instantly s@dRegions_Flags_CommandProcessors p:command_verifiedList


dRegions_Flag_Block-Break:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Block-Break<&4>]"
  lore:
  - <&5>Can players break blocks.
  event_hook: blockBreak
  event_priority: 10
  flag_type: state
  flag_takeGroup: true
  flag_defaultValue: allow/all
  flag_help: State flag controlling whether players will be able to break blocks in this region. Defaults to allow all. Use block-breaklist flag to specify block types. Takes the -g group switch.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - define player <player>
      - define flag 'block-break'
      - define flag-targetList 'block-breaklist'
      - inject s@dRegions_Flags_Processors p:state-withTarget-withGroup instantly
      }

  event-cleanup:
    - if <player.has_flag[dRegions_Message_Cooldown].not> {
      - flag player dRegions_Message_Cooldown duration:3s
      - run instantly s@dRegions_Msg 'def:<&c><&o>You can not break <def[target]> in this region!'
      }


dRegions_Flag_Block-BreakList:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Block-BreakList<&4>]"
  lore:
  - <&5>List of blocks used by block-break flag
  command_entryType: block
  command_verifyEntry: <def[value].as_material.is_block.not||true>
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with block-break flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of blocks.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - inject instantly s@dRegions_Flags_CommandProcessors p:command_verifiedList



################################################################################

dRegions_Flags_Processors:
  type: task
  debug: false

  boolean:
    - define prefix '<&lt>proc<&lb>dRegions_GetInheritedFlag<&rb>.context<&lb>%world%<&pipe>'
    - define suffix '<&pipe>%flag%<&rb>||null<&gt>'
    - define InheritedFlags '<parse:<def[orderedRegions].parse[replace[regex:^()].with[<def[prefix]>]].parse[replace[regex:()$].with[<def[suffix]>]]>>'
    - foreach %InheritedFlags% {
      - define flagVal '<def[value]>'
      - if <def[flagVal].is[==].to[null]||true> {
        - if <def[loop_index].is[==].to[<def[InheritedFlags].size>]> {
          - define flagVal '<def[FlagScript].yaml_key[flag_defaultValue]||true>'
          }
          else foreach next
        }
      - if <def[flagVal]||true> {
        - foreach stop
        }
        else {
        - inject <def[FlagScript]||null> p:event-cleanup instantly
        - determine cancelled
        }
      }

  state-withTarget:
    - define prefix '<&lt>proc<&lb>dRegions_GetInheritedFlag<&rb>.context<&lb>%world%<&pipe>'
    - define suffix '<&pipe>%flag-targetList%<&rb>||all<&gt>'
    - define InheritedTargets '<parse:<def[orderedRegions].parse[replace[regex:^()].with[<def[prefix]>]].parse[replace[regex:()$].with[<def[suffix]>]]>>'
    - define suffix '<&pipe>%flag%<&rb>||null<&gt>'
    - define InheritedFlags '<parse:<def[orderedRegions].parse[replace[regex:^()].with[<def[prefix]>]].parse[replace[regex:()$].with[<def[suffix]>]]>>'
    - foreach %InheritedFlags% {
      - define targetList '<def[InheritedTargets].get[%loop_index%].replace[, ].with[|].as_list||li@all>'
      - if <def[targetList].is[==].to[li@null]> {
        - define targetList 'li@all'
        }
      - define flagVal '<def[value]>'
      - if <def[flagVal].is[==].to[null]||true> {
        - if <def[loop_index].is[==].to[<def[InheritedFlags].size>]> {
          - define flagVal '<def[FlagScript].yaml_key[flag_defaultValue]||allow>'
          }
          else foreach next
        }

      - if <def[flagVal].is[==].to[allow]||false> {
        - if <def[targetList].is[!=].to[li@all]||true> {
          - if !<def[targetList].contains[<def[target]>]||false> {
            - inject <def[FlagScript]||null> p:event-cleanup instantly
            - determine cancelled
            }
            else foreach stop
          }
          else foreach stop
        }
        else {
        - if <def[targetList].is[==].to[li@all]||true> {
          - inject <def[FlagScript]||null> p:event-cleanup instantly
          - determine cancelled
          }
          else {
          - if <def[targetList].contains[<def[target]>]||false> {
            - inject <def[FlagScript]||null> p:event-cleanup instantly
            - determine cancelled
            }
            else foreach stop
          }
        }
      }

  state-withGroup:
    # requires %player% to be filled with a valid player object
    - define prefix '<&lt>proc<&lb>dRegions_GetInheritedFlag<&rb>.context<&lb>%world%<&pipe>'
    - define suffix '<&pipe>%flag%<&rb>||allow<&gt>'
    - define InheritedFlags '<parse:<def[orderedRegions].parse[replace[regex:^()].with[<def[prefix]>]].parse[replace[regex:()$].with[<def[suffix]>]]>>'
    - foreach %InheritedFlags% {
      - define flagObj '<def[value]>'
      - if <def[flagObj].is[==].to[null]||true> {
        - if <def[loop_index].is[==].to[<def[InheritedFlags].size>]> {
          - define flagObj '<def[FlagScript].yaml_key[flag_defaultValue]||allow/all>'
          }
          else foreach next
        }
      - define flagVal '<def[flagObj].split[/].get[1]>'
      - define group '<def[flagObj].split[/].get[2]||all>'
      - define region '<def[orderedRegions].get[%loop_index%]>'
      - define isOwner '<proc[dRegions_IsOwner].context[%region%|%world%|<def[player]>]>'
      - define isMember '<proc[dRegions_isMember].context[%region%|%world%|<def[player]>]>'
      - define isGroup '<proc[dRegions_PlayerMatchRegionGroup].context[%group%|%isMember%|%isOwner%]>'

      - if <def[flagVal].is[==].to[allow]||false> {
        - if !<def[isGroup]> {
          - inject <def[FlagScript]||null> p:event-cleanup instantly
          - determine cancelled
          }
          else foreach stop
        }
        else {
        - if <def[isGroup]> {
          - inject <def[FlagScript]||null> p:event-cleanup instantly
          - determine cancelled
          }
          else foreach stop
        }
      }

  state-withTarget-withGroup:
    # requires %player% to be filled with a valid player object
    - define prefix '<&lt>proc<&lb>dRegions_GetInheritedFlag<&rb>.context<&lb>%world%<&pipe>'
    - define suffix '<&pipe>%flag-targetList%<&rb>||all<&gt>'
    - define InheritedTargets '<parse:<def[orderedRegions].parse[replace[regex:^()].with[<def[prefix]>]].parse[replace[regex:()$].with[<def[suffix]>]]>>'
    - define suffix '<&pipe>%flag%<&rb>||allow<&gt>'
    - define InheritedFlags '<parse:<def[orderedRegions].parse[replace[regex:^()].with[<def[prefix]>]].parse[replace[regex:()$].with[<def[suffix]>]]>>'
    - foreach %InheritedFlags% {
      - define targetList '<def[InheritedTargets].get[%loop_index%].replace[, ].with[|].as_list||li@all>'
      - if <def[targetList].is[==].to[li@null]> {
        - define targetList 'li@all'
        }
      - define flagObj '<def[value]>'
      - if <def[flagObj].is[==].to[null]||true> {
        - if <def[loop_index].is[==].to[<def[InheritedFlags].size>]> {
          - define flagObj '<def[FlagScript].yaml_key[flag_defaultValue]||allow/all>'
          }
          else foreach next
        }
      - define flagVal '<def[flagObj].split[/].get[1]>'
      - define group '<def[flagObj].split[/].get[2]||all>'
      - define region '<def[orderedRegions].get[%loop_index%]>'
      - define isOwner '<proc[dRegions_IsOwner].context[%region%|%world%|<def[player]>]>'
      - define isMember '<proc[dRegions_isMember].context[%region%|%world%|<def[player]>]>'
      - define isGroup '<proc[dRegions_PlayerMatchRegionGroup].context[%group%|%isMember%|%isOwner%]>'

      - if <def[flagVal].is[==].to[allow]||false> {
        - if <def[isGroup]> {
          - if <def[targetList].is[!=].to[li@all]||true> {
            - if !<def[targetList].contains[<def[target]>]||false> {
              - inject <def[FlagScript]||null> p:event-cleanup instantly
              - determine cancelled
              }
              else foreach stop
            }
            else foreach stop
          }
          else {
          - inject <def[FlagScript]||null> p:event-cleanup instantly
          - determine cancelled
          }
        }
        else {
        - if <def[isGroup]> {
          - if <def[targetList].is[==].to[li@all]||true> {
            - inject <def[FlagScript]||null> p:event-cleanup instantly
            - determine cancelled
            }
            else {
            - if <def[targetList].contains[<def[target]>]||false> {
              - inject <def[FlagScript]||null> p:event-cleanup instantly
              - determine cancelled
              }
              else foreach stop
            }
          }
          else foreach stop
        }
      }


dRegions_Flags_CommandProcessors:
  type: task
  debug: false

  command_verifiedList:
    - if <def[flagValue].is[==].to[null]||false> {
      - yaml set 'regions.%region%.flags.%flag%:!' 'id:dRegions_%world%_regions'
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - run instantly s@dRegions_Msg 'def:<&c>Cleared %flag% list for region %region%'
      - queue clear
      }
      else {
      - define entries '<def[flagValue].split[ ].get[2].to[<def[flagValue].split[ ].size>].parse[to_lowercase].deduplicate||li@>'
      - if <def[entries].get[1].is[==].to[all]> {
        - if '<def[flagValue].split[ ].get[1].is[==].to[-a]||false>' {
          - yaml set 'regions.%region%.flags.%flag%:all' 'id:dRegions_%world%_regions'
          - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
          - run instantly s@dRegions_Msg 'def:<&f><&o>%region%<&7><&o> set %flag% flag to <&f><&o>%flagValue%'
          - queue clear
          }
        - if '<def[flagValue].split[ ].get[1].is[==].to[-r]||false>' {
          - yaml set 'regions.%region%.flags.%flag%:!' 'id:dRegions_%world%_regions'
          - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
          - run instantly s@dRegions_Msg 'def:<&c>Cleared %flag% list for region %region%'
          - queue clear
          }
        }
      - foreach %entries% {
        - if <parse:<s@dRegions_Flag_%Flag%.yaml_key[command_verifyEntry]||false>> {
          - define entries '<def[entries].exclude[%value%]||li@>'
          - run  s@dRegions_Msg 'def:<&c><&o>%value% is not a valid <s@dRegions_Flag_%Flag%.yaml_key[command_entryType]>!'
          }
        }
      - if <def[entries].is_empty||true> {
        - run  s@dRegions_Msg 'def:<&c><&o>No valid <s@dRegions_Flag_%Flag%.yaml_key[command_entryType]>s specified!'
        - define lines '<proc[dRegions_LineWrap].context[<s@dRegions_Flag_%Flag%.yaml_key[flag_help]||<&c>%flag% flag requires a %type% value!>|45]>'
        - foreach <def[lines]> {
          - run instantly s@dRegions_Msg 'def:<&c><def[value]>'
          }
        - queue clear
        }

      - define currentEntries '<yaml[dRegions_%world%_regions].read[regions.%region%.flags.%flag%].replace[, ].with[|].as_list||li@>'
      - if '<def[flagValue].split[ ].get[1].is[==].to[-a]||false>' {
        - define flagValue '<def[currentEntries].include[<def[entries].replace[li@]>].deduplicate||li@>'
        }
      - if '<def[flagValue].split[ ].get[1].is[==].to[-r]||false>' {
        - define flagValue '<def[currentEntries].exclude[<def[entries].replace[li@]>].deduplicate||li@>'
        }
      - if <def[flagValue].is_empty||true> {
        - yaml set 'regions.%region%.flags.%flag%:!' 'id:dRegions_%world%_regions'
        - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
        - run instantly s@dRegions_Msg 'def:<&c>Cleared %flag% list for region %region%'
        - queue clear
        }
      - define flagValue '<def[flagValue].comma_separated>'
      }



#
