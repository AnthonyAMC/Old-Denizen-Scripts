################################################################################
#
#                                d R e g i o n s
#
#                                 Flag Modules
#
#   Authors: |Anthony|
#   Version: 0.1
#   dScript Version: 0.9.6-DEV_b146
#
#
#
#--- About this script
#
#  Adding new flags /can/ be as easy as making a new module!
#
#
#
################################################################################


dRegions_Flag_Entry:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Entry<&4>]"
  lore:
  - <&5>Who can enter a region
  event_hook: regionEnter
  event_priority: 0
  flag_type: state
  flag_takeGroup: true
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."


  event:
    - define prefix '<&lt>proc<&lb>dRegions_GetInheritedFlag<&rb>.context<&lb>%world%<&pipe>'
    - define suffix '<&pipe>entry<&rb>||null<&gt>'
    - define entryList '<parse:<def[orderedRegions].parse[replace[regex:^()].with[<def[prefix]>]].parse[replace[regex:()$].with[<def[suffix]>]]>>'
#    - define entryList '<parse:<def[orderedRegions].parse[replace[regex:^()].with[<&lt>yaml<&lb>dRegions_%world%_regions<&rb>.read<&lb>regions.]].parse[replace[regex:()$].with[.flags.entry<&rb>||null<&gt>]]>>'
    - foreach %entryList% {
      - if <def[value].split[/].get[1].is[==].to[deny]||false> {
        - define group '<def[value].split[/].get[2]||nonmembers>'
        - define isOwner '<proc[dRegions_IsOwner].context[<def[orderedRegions].get[%loop_index%]>|%world%|<player>]>'
        - define isMember '<proc[dRegions_isMember].context[<def[orderedRegions].get[%loop_index%]>|%world%|<player>]>'

        - if <proc[dRegions_PlayerMatchRegionGroup].context[%group%|%isMember%|%isOwner%]> {
          - if <player.has_flag[dRegions_Message_Cooldown].not> {
            - flag player dRegions_Message_Cooldown duration:3s
            - run s@dRegions_Msg 'def:<&c><&o>You do not have permission to enter this region'
            }
          - determine cancelled
          - queue clear
          }
        }
      }



dRegions_Flag_Greeting:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Greeting<&4>]"
  lore:
  - <&5>Message on enter region
  event_hook: regionEnter
  event_priority: 10
  flag_type: string
  flag_takeGroup: false
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."


  event:
  # Now using GetInheritedFlag procedure
  # I split the tag up into 3 parts so folks could maybe possibly better understand it
  # The original msgList is left commented out. No touchy
    - define prefix '<&lt>proc<&lb>dRegions_GetInheritedFlag<&rb>.context<&lb>%world%<&pipe>'
    - define suffix '<&pipe>greeting<&rb>||null<&gt>'
    - define msgList '<parse:<def[orderedRegions].parse[replace[regex:^()].with[<def[prefix]>]].parse[replace[regex:()$].with[<def[suffix]>]]>>'
#    - define msgList '<parse:<def[orderedRegions].parse[replace[regex:^()].with[<&lt>yaml<&lb>dRegions_%world%_regions<&rb>.read<&lb>regions.]].parse[replace[regex:()$].with[.flags.greeting<&rb>||null<&gt>]]>>'
    - foreach %msgList% {
      - if <def[value].is[!=].to[null]||false> {
        - narrate "<parse:%value%>"
        - foreach stop
        }
      }


dRegions_Flag_Exit:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Exit<&4>]"
  lore:
  - <&5>Who can exit a region
  event_hook: regionExit
  event_priority: 0
  flag_type: state
  flag_takeGroup: true
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."


  event:
    - define prefix '<&lt>proc<&lb>dRegions_GetInheritedFlag<&rb>.context<&lb>%world%<&pipe>'
    - define suffix '<&pipe>exit<&rb>||null<&gt>'
    - define exitList '<parse:<def[orderedRegions].parse[replace[regex:^()].with[<def[prefix]>]].parse[replace[regex:()$].with[<def[suffix]>]]>>'
#    - define exitList '<parse:<def[orderedRegions].parse[replace[regex:^()].with[<&lt>yaml<&lb>dRegions_%world%_regions<&rb>.read<&lb>regions.]].parse[replace[regex:()$].with[.flags.exit<&rb>||null<&gt>]]>>'
    - foreach %exitList% {
      - if <def[value].split[/].get[1].is[==].to[deny]||false> {
        - define group '<def[value].split[/].get[2]||nonmembers>'
        - define isOwner '<proc[dRegions_IsOwner].context[<def[orderedRegions].get[%loop_index%]>|%world%|<player>]>'
        - define isMember '<proc[dRegions_isMember].context[<def[orderedRegions].get[%loop_index%]>|%world%|<player>]>'

        - if <proc[dRegions_PlayerMatchRegionGroup].context[%group%|%isMember%|%isOwner%]> {
          - if <player.has_flag[dRegions_Message_Cooldown].not> {
            - flag player dRegions_Message_Cooldown duration:3s
            - run s@dRegions_Msg 'def:<&c><&o>You do not have permission to exit this region'
            }
          - determine cancelled
          - queue clear
          }
        }
      }



dRegions_Flag_Farewell:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Farewell<&4>]"
  lore:
  - <&5>Message on exit region
  event_hook: regionExit
  event_priority: 10
  flag_type: string
  flag_takeGroup: false
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."


  event:
    - define prefix '<&lt>proc<&lb>dRegions_GetInheritedFlag<&rb>.context<&lb>%world%<&pipe>'
    - define suffix '<&pipe>farewell<&rb>||null<&gt>'
    - define msgList '<parse:<def[orderedRegions].parse[replace[regex:^()].with[<def[prefix]>]].parse[replace[regex:()$].with[<def[suffix]>]]>>'
    - foreach %msgList% {
      - if <def[value].is[!=].to[null]||false> {
        - narrate "<parse:%value%>"
        - foreach stop
        }
      }



dRegions_Flag_Gamemode:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Gamemode<&4>]"
  lore:
  - <&5>Change gamemode inside a region
  event_hook: regionToggle
  event_priority: 20
  flag_type: custom
  flag_type_customVal: creative|survival|adventure
  flag_help: Gamemode flag can be set to creative, survival, or adventure
  flag_takeGroup: true
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."


  event:
    - define prefix '<&lt>proc<&lb>dRegions_GetInheritedFlag<&rb>.context<&lb>%world%<&pipe>'
    - define suffix '<&pipe>gamemode<&rb>||null<&gt>'
    - define gmList '<parse:<def[orderedRegions].parse[replace[regex:^()].with[<def[prefix]>]].parse[replace[regex:()$].with[<def[suffix]>]]>>'
    - foreach %gmList% {
      - if <def[value].is[!=].to[null]||false> {
        - define gm '<def[value].split[/].get[1]||survival>'
        - define group '<def[value].split[/].get[2]||members>'
        - define isOwner '<proc[dRegions_IsOwner].context[<def[orderedRegions].get[%loop_index%]>|%world%|<player>]>'
        - define isMember '<proc[dRegions_isMember].context[<def[orderedRegions].get[%loop_index%]>|%world%|<player>]>'

        - if <proc[dRegions_PlayerMatchRegionGroup].context[%group%|%isMember%|%isOwner%]> {
          - if <def[isExit].exists> {
            - if <player.flag[dRegions_PreviousGamemode].is[!=].to[<player.gamemode>]||false> {
              - adjust <player> 'gamemode:<player.flag[dRegions_PreviousGamemode]||survival>'
              - run s@dRegions_Msg 'def:<&7><&o>Your gamemode has been updated.'
              }
            - flag <player> 'dRegions_PreviousGamemode:!'
            }
            else if <def[isEnter].exists> {
            - if <def[gm].is[!=].to[<player.gamemode>]> {
              - flag <player> 'dRegions_PreviousGamemode:<player.gamemode>'
              - adjust <player> 'gamemode:%gm%'
              - run s@dRegions_Msg 'def:<&7><&o>Your gamemode has been updated.'
              }
            }
            else {
            - adjust <player> 'gamemode:survival'
            - run s@dRegions_Msg 'def:<&7><&o>Your gamemode has been updated.'
            }
          - foreach stop
          }
        }
      }



dRegions_Flag_Inventory:
  type: item
  debug: true
  material: i@paper
  display name: "<&4>[<&6>Inventory<&4>]"
  lore:
  - <&5>Save inventory before going into a region
  event_hook: regionToggle
  event_priority: 20
  flag_type: custom
  flag_type_customVal: unique|kit
  flag_help: Inventory flag can be set to unique or kit. Unique inventories start empty. Kit inventories use your current inventory.
  flag_takeGroup: true
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."


  command_handler:
    - if <def[flagValue].is[==].to[kit]> {
      - yaml set 'inventories.regions.%region%.entry.kit.equip:<player.equipment>' 'id:dRegions_%world%_inventories'
      - yaml set 'inventories.regions.%region%.entry.kit.inv:<player.inventory.list_contents>' 'id:dRegions_%world%_inventories'
      - yaml set 'inventories.regions.%region%.exit.players:|:' 'id:dRegions_%world%_inventories'
      }
    - if <def[flagValue].is[==].to[unique]> {
      - yaml set 'inventories.regions.%region%.entry.players:|:' 'id:dRegions_%world%_inventories'
      - yaml set 'inventories.regions.%region%.exit.players:|:' 'id:dRegions_%world%_inventories'
      }
    - if <def[flagValue].is[==].to[null]> {
      - yaml set 'inventories.regions.%region%:!' 'id:dRegions_%world%_inventories'
      }
    - yaml 'savefile:dRegions/worlds/%world%/inventories.yml' 'id:dRegions_%world%_inventories'


  event:
    - define prefix '<&lt>proc<&lb>dRegions_GetInheritedFlag<&rb>.context<&lb>%world%<&pipe>'
    - define suffix '<&pipe>inventory<&rb>||null<&gt>'
    - define invList '<parse:<def[orderedRegions].parse[replace[regex:^()].with[<def[prefix]>]].parse[replace[regex:()$].with[<def[suffix]>]]>>'
    - foreach %invList% {
      - define region '<def[orderedRegions].get[%loop_index%]>'
      - if <def[value].is[!=].to[null]||false> {
        - define inv '<def[value].split[/].get[1]||unique>'
        - define group '<def[value].split[/].get[2]||nonmembers>'
        - define isOwner '<proc[dRegions_IsOwner].context[%region%|%world%|<player>]>'
        - define isMember '<proc[dRegions_isMember].context[%region%|%world%|<player>]>'

        - if <proc[dRegions_PlayerMatchRegionGroup].context[%group%|%isMember%|%isOwner%]> {
          - if <def[isEnter].exists> {
            - if <def[inv].is[==].to[kit]||false> {
              - define equipment '<yaml[dRegions_%world%_inventories].read[inventories.regions.%region%.entry.kit.equip]||li@>'
              - yaml set 'inventories.regions.%region%.exit.players.<player.uuid>.equip:<player.equipment>' 'id:dRegions_%world%_inventories'
              - yaml set 'inventories.regions.%region%.exit.players.<player.uuid>.inv:<player.inventory.list_contents>' 'id:dRegions_%world%_inventories'
              - inventory set 'd:<player.inventory>' 'o:<yaml[dRegions_%world%_inventories].read[inventories.regions.%region%.entry.kit.inv]||li@>'
              - equip <player> 'boots:<def[equipment].get[1]||i@air>' 'legs:<def[equipment].get[2]||i@air>' 'chest:<def[equipment].get[3]||i@air>' 'head:<def[equipment].get[4]||i@air>'
              }
              else if <def[inv].is[==].to[unique]||false> {
              - define equipment '<yaml[dRegions_%world%_inventories].read[inventories.regions.%region%.entry.players.<player.uuid>.equip]||li@>'
              - yaml set 'inventories.regions.%region%.exit.players.<player.uuid>.equip:<player.equipment>' 'id:dRegions_%world%_inventories'
              - yaml set 'inventories.regions.%region%.exit.players.<player.uuid>.inv:<player.inventory.list_contents||li@i@air>' 'id:dRegions_%world%_inventories'
              - inventory set 'd:<player.inventory>' 'o:<yaml[dRegions_%world%_inventories].read[inventories.regions.%region%.entry.players.<player.uuid>.inv]||li@>'
              - equip <player> 'boots:<def[equipment].get[1]||i@air>' 'legs:<def[equipment].get[2]||i@air>' 'chest:<def[equipment].get[3]||i@air>' 'head:<def[equipment].get[4]||i@air>'
              }
            - run s@dRegions_Msg 'def:<&7><&o>Your inventory has been updated.'
            }
            else if <def[isExit].exists> {
            - define equipment '<yaml[dRegions_%world%_inventories].read[inventories.regions.%region%.exit.players.<player.uuid>.equip]||li@>'
            - inventory set 'd:<player.inventory>' 'o:<yaml[dRegions_%world%_inventories].read[inventories.regions.%region%.exit.players.<player.uuid>.inv]||li@>'
            - equip <player> 'boots:<def[equipment].get[1]||i@air>' 'legs:<def[equipment].get[2]||i@air>' 'chest:<def[equipment].get[3]||i@air>' 'head:<def[equipment].get[4]||i@air>'
            - yaml set 'inventories.regions.%region%.exit.players.<player.uuid>:!' 'id:dRegions_%world%_inventories'
            - run s@dRegions_Msg 'def:<&7><&o>Your inventory has been updated.'
            }
            else {
            - run s@dRegions_Msg 'def:<&7><&o>THIS SHOULD NOT RUN EVER!'
            }
          - yaml 'savefile:dRegions/worlds/%world%/inventories.yml' 'id:dRegions_%world%_inventories'
          - foreach stop
          }
        }
      }


dRegions_Flag_Build:
  type: item
  debug: true
  material: i@paper
  display name: "<&4>[<&6>Build<&4>]"
  lore:
  - <&5>Override default build perms
  event_hook: build
  event_priority: 0
  flag_type: state
  flag_help: By default, all members and owners can build in their regions. Setting this flag can over ride that behavior. Can be set to allow, deny, or none and accepts the -g group switch.
  flag_takeGroup: true
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - define region '<def[orderedRegions].get[1]>'
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|build]||null>'
    - if <def[flagVal].is[==].to[null]||true> {
      - define flagVal 'deny/nonmembers'
      }
    - define flag '<def[flagVal].split[/].get[1]>'
    - define group '<def[flagVal].split[/].get[2]||nonmembers>'
    - define isOwner '<proc[dRegions_IsOwner].context[<def[orderedRegions].get[%loop_index%]>|%world%|<player>]>'
    - define isMember '<proc[dRegions_isMember].context[<def[orderedRegions].get[%loop_index%]>|%world%|<player>]>'

    - if <def[flag].is[==].to[deny]||false> {
      - if <proc[dRegions_PlayerMatchRegionGroup].context[%group%|%isMember%|%isOwner%]> {
        - if <player.has_flag[dRegions_Message_Cooldown].not> {
          - flag player dRegions_Message_Cooldown duration:3s
          - run s@dRegions_Msg 'def:<&c><&o>You do not have permission to build in this region'
          }
        - determine cancelled
        - queue clear
        }
      }

    - if <def[flag].is[==].to[allow]||false> {
      - if <proc[dRegions_PlayerMatchRegionGroup].context[%group%|%isMember%|%isOwner%].not> {
        - if <player.has_flag[dRegions_Message_Cooldown].not> {
          - flag player dRegions_Message_Cooldown duration:3s
          - run s@dRegions_Msg 'def:<&c><&o>You do not have permission to build in this region'
          }
        - determine cancelled
        - queue clear
        }
      }


dRegions_Flag_Mob-Targeting:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Mob-Targeting<&4>]"
  lore:
  - <&5>Can mobs target players
  event_hook: ENTITY_Target_Player
  event_priority: 0
  flag_type: state
  flag_takeGroup: true
  flag_help: State flag controlling whether mobs will be able to target players in this region. Defaults to allow all. Use mob-targeting flag to specify mob types. Takes the -g group switch.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."


  event:
    - define player <c.target>
    - define prefix '<&lt>proc<&lb>dRegions_GetInheritedFlag<&rb>.context<&lb>%world%<&pipe>'
    - define suffix '<&pipe>mob-target<&rb>||all<&gt>'
    - define InheritedMobs '<parse:<def[orderedRegions].parse[replace[regex:^()].with[<def[prefix]>]].parse[replace[regex:()$].with[<def[suffix]>]]>>'
    - define suffix '<&pipe>mob-targeting<&rb>||allow<&gt>'
    - define InheritedFlags '<parse:<def[orderedRegions].parse[replace[regex:^()].with[<def[prefix]>]].parse[replace[regex:()$].with[<def[suffix]>]]>>'
    - foreach %InheritedFlags% {
      - define mobList '<def[InheritedMobs].get[%loop_index%].replace[, ].with[|].as_list||li@all>'
      - if <def[mobList].is[==].to[li@null]> {
        - define mobList 'li@all'
        }
      - if <def[mobList].is[==].to[li@all]||false>
        || <def[moblist].contains[<c.entity.entity_type>]||false> {
        - define flagVal '<def[value]>'
        - if <def[flagVal].is[==].to[null]||true> {
          - define flagVal 'allow/all'
          }
        - define flag '<def[flagVal].split[/].get[1]>'
        - define group '<def[flagVal].split[/].get[2]||all>'
        - define region '<def[orderedRegions].get[%loop_index%]>'
        - define isOwner '<proc[dRegions_IsOwner].context[%region%|%world%|<def[player]>]>'
        - define isMember '<proc[dRegions_isMember].context[%region%|%world%|<def[player]>]>'

        - if <def[flag].is[==].to[allow]||false> {
          - if <proc[dRegions_PlayerMatchRegionGroup].context[%group%|%isMember%|%isOwner%].not> {
            - remove <c.projectile||li@>
            - attack <def[mob]> target:cancel
            - determine cancelled
            - queue clear
            }
          }

        - if <def[flag].is[==].to[deny]||false> {
          - if <proc[dRegions_PlayerMatchRegionGroup].context[%group%|%isMember%|%isOwner%]> {
            - remove <c.projectile||li@>
            - attack <def[mob]> target:cancel
            - determine cancelled
            - queue clear
            }
          }
        }
      }



dRegions_Flag_Mob-Target:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Mob-Target<&4>]"
  lore:
  - <&5>List of mobs used by mob-targeting flag
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with mob-targeting flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of mobs.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - if <def[flagValue].is[==].to[null]||false> {
      - yaml set 'regions.%region%.flags.%flag%:!' 'id:dRegions_%world%_regions'
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - run s@dRegions_Msg 'def:<&c>Cleared %flag% list for region %region%'
      - queue clear
      }
      else {
      - define mobs '<def[flagValue].split[ ].get[2].to[<def[flagValue].split[ ].size>].parse[to_lowercase].deduplicate||li@>'
      - if <def[mobs].get[1].is[==].to[all]> {
        - if '<def[flagValue].split[ ].get[1].is[==].to[-a]||false>' {
          - yaml set 'regions.%region%.flags.%flag%:all' 'id:dRegions_%world%_regions'
          - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
          - run s@dRegions_Msg 'def:<&f><&o>%region%<&7><&o> set %flag% flag to <&f><&o>%flagValue%'
          - queue clear
          }
        - if '<def[flagValue].split[ ].get[1].is[==].to[-r]||false>' {
          - yaml set 'regions.%region%.flags.%flag%:!' 'id:dRegions_%world%_regions'
          - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
          - run s@dRegions_Msg 'def:<&c>Cleared %flag% list for region %region%'
          - queue clear
          }
        }
      - foreach %mobs% {
        - if <def[value].is[matches].to[entity].not> {
          - define mobs '<def[mobs].exclude[%value%]||li@>'
          - run  s@dRegions_Msg 'def:<&c><&o>%value% is not a valid a mob!'
          }
        }
      - if <def[mobs].is_empty||true> {
        - run  s@dRegions_Msg 'def:<&c><&o>No valid mobs specified!'
        - define lines '<proc[dRegions_LineWrap].context[<s@dRegions_Flag_%Flag%.yaml_key[flag_help]||<&c>%flag% flag requires a %type% value!>|45]>'
        - foreach <def[lines]> {
          - run s@dRegions_Msg 'def:<&c><def[value]>'
          }
        - queue clear
        }

      - define currentMobs '<yaml[dRegions_%world%_regions].read[regions.%region%.flags.%flag%].replace[, ].with[|].as_list||li@>'
      - if '<def[flagValue].split[ ].get[1].is[==].to[-a]||false>' {
        - define flagValue '<def[currentMobs].include[<def[mobs].replace[li@]>].deduplicate||li@>'
        }
      - if '<def[flagValue].split[ ].get[1].is[==].to[-r]||false>' {
        - define flagValue '<def[currentMobs].exclude[<def[mobs].replace[li@]>].deduplicate||li@>'
        }
      - if <def[flagValue].is_empty||true> {
        - yaml set 'regions.%region%.flags.%flag%:!' 'id:dRegions_%world%_regions'
        - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
        - run s@dRegions_Msg 'def:<&c>Cleared %flag% list for region %region%'
        - queue clear
        }
      - define flagValue '<def[flagValue].comma_separated>'
      }


dRegions_Flag_Mob-Damage:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Mob-Damage<&4>]"
  lore:
  - <&5>Can mobs damage players
  event_hook: ENTITY_Damage_Player
  event_priority: 10
  flag_type: state
  flag_takeGroup: true
  flag_help: State flag controlling whether mobs will be able to damage players in this region. Defaults to allow all. Use mob-damagelist flag to specify mob types. Takes the -g group switch.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."


  event:
    - define player <c.entity>
    - define prefix '<&lt>proc<&lb>dRegions_GetInheritedFlag<&rb>.context<&lb>%world%<&pipe>'
    - define suffix '<&pipe>mob-damagelist<&rb>||all<&gt>'
    - define InheritedMobs '<parse:<def[orderedRegions].parse[replace[regex:^()].with[<def[prefix]>]].parse[replace[regex:()$].with[<def[suffix]>]]>>'
    - define suffix '<&pipe>mob-damage<&rb>||allow<&gt>'
    - define InheritedFlags '<parse:<def[orderedRegions].parse[replace[regex:^()].with[<def[prefix]>]].parse[replace[regex:()$].with[<def[suffix]>]]>>'
    - foreach %InheritedFlags% {
      - define mobList '<def[InheritedMobs].get[%loop_index%].replace[, ].with[|].as_list||li@all>'
      - if <def[mobList].is[==].to[li@null]> {
        - define mobList 'li@all'
        }
      - if <def[mobList].is[==].to[li@all]||false>
        || <def[moblist].contains[<c.damager.entity_type>]||false> {
        - define flagVal '<def[value]>'
        - if <def[flagVal].is[==].to[null]||true> {
          - define flagVal 'allow/all'
          }
        - define flag '<def[flagVal].split[/].get[1]>'
        - define group '<def[flagVal].split[/].get[2]||all>'
        - define region '<def[orderedRegions].get[%loop_index%]>'
        - define isOwner '<proc[dRegions_IsOwner].context[%region%|%world%|<def[player]>]>'
        - define isMember '<proc[dRegions_isMember].context[%region%|%world%|<def[player]>]>'

        - if <def[flag].is[==].to[allow]||false> {
          - if <proc[dRegions_PlayerMatchRegionGroup].context[%group%|%isMember%|%isOwner%].not> {
            - remove <c.projectile||li@>
            - attack <def[mob]> target:cancel
            - determine cancelled
            - queue clear
            }
          }

        - if <def[flag].is[==].to[deny]||false> {
          - if <proc[dRegions_PlayerMatchRegionGroup].context[%group%|%isMember%|%isOwner%]> {
            - remove <c.projectile||li@>
            - attack <def[mob]> target:cancel
            - determine cancelled
            - queue clear
            }
          }
        }
      }



dRegions_Flag_Mob-Damagelist:
  type: item
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Mob-DamageList<&4>]"
  lore:
  - <&5>List of mobs used by mob-damage flag
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with mob-damage flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of mobs.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - if <def[flagValue].is[==].to[null]||false> {
      - yaml set 'regions.%region%.flags.%flag%:!' 'id:dRegions_%world%_regions'
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - run s@dRegions_Msg 'def:<&c>Cleared %flag% list for region %region%'
      - queue clear
      }
      else {
      - define mobs '<def[flagValue].split[ ].get[2].to[<def[flagValue].split[ ].size>].parse[to_lowercase].deduplicate||li@>'
      - if <def[mobs].get[1].is[==].to[all]> {
        - if '<def[flagValue].split[ ].get[1].is[==].to[-a]||false>' {
          - yaml set 'regions.%region%.flags.%flag%:all' 'id:dRegions_%world%_regions'
          - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
          - run s@dRegions_Msg 'def:<&f><&o>%region%<&7><&o> set %flag% flag to <&f><&o>%flagValue%'
          - queue clear
          }
        - if '<def[flagValue].split[ ].get[1].is[==].to[-r]||false>' {
          - yaml set 'regions.%region%.flags.%flag%:!' 'id:dRegions_%world%_regions'
          - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
          - run s@dRegions_Msg 'def:<&c>Cleared %flag% list for region %region%'
          - queue clear
          }
        }
      - foreach %mobs% {
        - if <def[value].is[matches].to[entity].not> {
          - define mobs '<def[mobs].exclude[%value%]||li@>'
          - run  s@dRegions_Msg 'def:<&c><&o>%value% is not a valid a mob!'
          }
        }
      - if <def[mobs].is_empty||true> {
        - run  s@dRegions_Msg 'def:<&c><&o>No valid mobs specified!'
        - define lines '<proc[dRegions_LineWrap].context[<s@dRegions_Flag_%Flag%.yaml_key[flag_help]||<&c>%flag% flag requires a %type% value!>|45]>'
        - foreach <def[lines]> {
          - run s@dRegions_Msg 'def:<&c><def[value]>'
          }
        - queue clear
        }

      - define currentMobs '<yaml[dRegions_%world%_regions].read[regions.%region%.flags.%flag%].replace[, ].with[|].as_list||li@>'
      - if '<def[flagValue].split[ ].get[1].is[==].to[-a]||false>' {
        - define flagValue '<def[currentMobs].include[<def[mobs].replace[li@]>].deduplicate||li@>'
        }
      - if '<def[flagValue].split[ ].get[1].is[==].to[-r]||false>' {
        - define flagValue '<def[currentMobs].exclude[<def[mobs].replace[li@]>].deduplicate||li@>'
        }
      - if <def[flagValue].is_empty||true> {
        - yaml set 'regions.%region%.flags.%flag%:!' 'id:dRegions_%world%_regions'
        - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
        - run s@dRegions_Msg 'def:<&c>Cleared %flag% list for region %region%'
        - queue clear
        }
      - define flagValue '<def[flagValue].comma_separated>'
      }




#
