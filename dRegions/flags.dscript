################################################################################
#
#                                d R e g i o n s
#
#                                 Flag Modules
#
#   Authors: |Anthony|
#   Version: 0.2
#   dScript Version: 0.9.6-DEV_b140
#
#
#
#--- About this script
#
#  Adding new flags /can/ be as easy as making a new module!
#
#
#
################################################################################


dRegions_Flag_Entry:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Entry<&4>]"
  lore:
  - <&5>Who can enter a region
  event_hook: regionEnter
  event_priority: 0
  flag_type: state
  flag_takeGroup: true
  flag_defaultValue: none
  flag_globalDefault: none
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - define player <player>
    - define region '<def[orderedRegions].get[1]>'
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|entry]>'
      - if %flagObj% != null {
        - inject s@dRegions_Flags_Processors p:state-withGroup
        }
      }
    - run locally entered delay:1t player:<player> def:%world%|%region%|<def[orderedRegions].escaped>

  event-global:
    - define player <player>
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|entry]>'
      - if %flagObj% != null {
        - inject s@dRegions_Flags_Processors p:state-withGroup-Global
        }
      }
    - run locally entered-global delay:1t player:<player> def:%world%|__global__

  entered:
    - ^define world '%1%'
    - ^define region '%2%'
    - ^define orderedRegions '<def[3].unescaped>'
    - ^define player '<player>'
    - ^inject s@dRegions_Flag_Notify-Enter p:event
    - ^inject s@dRegions_Flag_Greeting p:event
    - ^inject s@dRegions_Flag_Inventory p:event-enter
    - ^inject s@dRegions_Flag_Gamemode p:event-enter
    - ^inject s@dRegions_Flag_Heal-Amount p:event
    - ^inject s@dRegions_Flag_Feed-Amount p:event

  entered-global:
    - ^define world '%1%'
    - ^define region '%2%'
    - ^define player '<player>'
    - ^inject s@dRegions_Flag_Notify-Enter p:event-global
    - ^inject s@dRegions_Flag_Greeting p:event-global
    - ^inject s@dRegions_Flag_Inventory p:event-enter
    - ^inject s@dRegions_Flag_Gamemode p:event-enter
    - ^inject s@dRegions_Flag_Heal-Amount p:event-global
    - ^inject s@dRegions_Flag_Feed-Amount p:event-global

  event-cleanup:
    - if <player.is_inside_vehicle||false> {
      - run locally vehicle 'def:<player.get_vehicle>|<c.from>' delay:1t
      }
    - run locally msg delay:1t

  msg:
    - ^if <player.has_flag[dRegions_Message_Cooldown].not> {
      - flag player dRegions_Message_Cooldown duration:3s
      - run s@dRegions_Msg delay:1t 'def:<&c><&o>You do not have permission to enter this region'
      }

  vehicle:
    - ^if <player.has_flag[dRegions_regionKick]> {
      - queue clear
      }
      else {
      - flag <player> dRegions_regionKick d:5t
      }
    - ^mount cancel <player>|%1%
    - ^teleport '<player>' '<def[2].above>'
    - ^wait 20t
    - ^adjust %1% 'velocity:l@0,0,0,<def[1].world>'
    - ^teleport %1% '<t[<def[1].is_living>]:<player.location>||<def[2].above>>'


dRegions_Flag_Exit:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Exit<&4>]"
  lore:
  - <&5>Who can exit a region
  event_hook: regionExit
  event_priority: 0
  flag_type: state
  flag_takeGroup: true
  flag_defaultValue: none
  flag_globalDefault: none
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - define player <player>
    - define region '<def[orderedRegions].get[1]>'
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|exit]>'
      - if %flagObj% != null {
        - inject s@dRegions_Flags_Processors p:state-withGroup
        }
      }
    - run locally exited delay:1t player:<player> def:%world%|%region%|<def[orderedRegions].escaped>

  event-global:
    - define player <player>
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|exit]>'
      - if %flagObj% != null {
        - inject s@dRegions_Flags_Processors p:state-withGroup-Global
        }
      }
    - run locally exited-global delay:1t player:<player> def:%world%|__global__

  exited:
    - ^define world '%1%'
    - ^define region '%2%'
    - ^define orderedRegions '<def[3].unescaped>'
    - ^define player '<player>'
    - ^inject s@dRegions_Flag_Notify-Exit p:event
    - ^inject s@dRegions_Flag_Farewell p:event
    - ^inject s@dRegions_Flag_Inventory p:event-exit
    - ^inject s@dRegions_Flag_Gamemode p:event-exit

  exited-global:
    - ^define world '%1%'
    - ^define region '%2%'
    - ^define player '<player>'
    - ^inject s@dRegions_Flag_Notify-Exit p:event-global
    - ^inject s@dRegions_Flag_Farewell p:event-global
    - ^inject s@dRegions_Flag_Inventory p:event-Exit
    - ^inject s@dRegions_Flag_Gamemode p:event-Exit


  event-cleanup:
    - if <player.is_inside_vehicle||false> {
      - define vehicle '<player.get_vehicle>'
      - run locally vehicle 'def:%vehicle%|<c.from>' delay:1t
      }
    - run locally msg delay:1t

  msg:
    - ^if <player.has_flag[dRegions_Message_Cooldown].not> {
      - flag player dRegions_Message_Cooldown duration:3s
      - run s@dRegions_Msg delay:1t 'def:<&c><&o>You do not have permission to exit this region'
      }

  vehicle:
    - ^if <player.has_flag[dRegions_regionKick]> {
      - queue clear
      }
      else {
      - flag <player> dRegions_regionKick d:5t
      }
    - ^mount cancel <player>|%1%
    - ^teleport '<player>' '<def[2].above>'
    - ^wait 20t
    - ^adjust %1% 'velocity:l@0,0,0,<def[1].world>'
    - ^teleport %1% '<t[<def[1].is_living>]:<player.location>||<def[2].above>>'


dRegions_Flag_Notify-Enter:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Notify-Enter<&4>]"
  lore:
  - <&5>Send notification to marked players
  event_hook: regionEnter
  event_priority: 5
  flag_type: boolean
  flag_takeGroup: false
  flag_defaultValue: false
  flag_help: Boolean flag controlling whether notifications are sent for entering this region. Set to true or false. Defaults to false.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
  # We only notify for the highest priority region, but we inherit the flag value from parents.
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|notify-enter]>'
    - if %flagVal% == true {
      - foreach <server.list_online_players.filter[has_permission[dregions.notify]].include[<server.list_online_ops>].deduplicate> {
        - run player:%value% s@dRegions_Msg 'def:<&5><&o><def[player].name> entered %region% in %world%'
        }
      }

  event-global:
  # We only notify for the highest priority region, but we inherit the flag value from parents.
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|notify-enter]>'
    - if %flagVal% = true {
      - foreach <server.list_online_players.filter[has_permission[dregions.notify]].include[<server.list_online_ops>].deduplicate> {
        - run player:%value% s@dRegions_Msg 'def:<&5><&o><def[player].name> entered the global region in %world%'
        }
      }


dRegions_Flag_Notify-Exit:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Notify-Exit<&4>]"
  lore:
  - <&5>Send notification to marked players
  event_hook: regionExit
  event_priority: 5
  flag_type: boolean
  flag_takeGroup: false
  flag_defaultValue: false
  flag_help: Boolean flag controlling whether notifications are sent for exiting this region. Set to true or false. Defaults to false.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
  # We only notify for the highest priority region, but we inherit the flag value from parents.
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|notify-exit]>'
    - if %flagVal% == true {
      - foreach <server.list_online_players.filter[has_permission[dregions.notify]].include[<server.list_online_ops>].deduplicate> {
        - run player:%value% s@dRegions_Msg 'def:<&5><&o><def[player].name> left %region% in %world%'
        }
      }

  event-global:
  # We only notify for the highest priority region, but we inherit the flag value from parents.
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|notify-exit]>'
    - if %flagVal% = true {
      - foreach <server.list_online_players.filter[has_permission[dregions.notify]].include[<server.list_online_ops>].deduplicate> {
        - run player:%value% s@dRegions_Msg 'def:<&5><&o><def[player].name> left the global region in %world%'
        }
      }


dRegions_Flag_Greeting:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Greeting<&4>]"
  lore:
  - <&5>Message on enter region
  event_hook: regionEnter
  event_priority: 10
  flag_type: string
  flag_takeGroup: false
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
  # We should only get a message from the highest priority region, but let's inherit from parents.
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|greeting]>'
    - if %flagVal% != null {
#      - narrate "<def[flagVal].replace[regex:&([0-9a-fA-Fk-oK-OrR])].with[<&r.before[r]>$1]>
      - narrate "<parse:%flagVal%>"
      - adjust <player> 'action_bar:<parse:%flagVal%>'
      }

  event-global:
  # We should only get a message from the highest priority region, but let's inherit from parents.
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|greeting]>'
    - if %flagVal% != null {
#      - narrate "<def[flagVal].replace[regex:&([0-9a-fA-Fk-oK-OrR])].with[<&r.before[r]>$1]>
      - narrate "<parse:%flagVal%>"
      - adjust <player> 'action_bar:<parse:%flagVal%>'
      }


dRegions_Flag_Farewell:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Farewell<&4>]"
  lore:
  - <&5>Message on exit region
  event_hook: regionExit
  event_priority: 10
  flag_type: string
  flag_takeGroup: false
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
  # We should only get a message from the highest priority region, but let's inherit from parents.
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|farewell]>'
    - if %flagVal% != null {
#      - narrate "<def[flagVal].replace[regex:&([0-9a-fA-Fk-oK-OrR])].with[<&r.before[r]>$1]>
      - narrate "<parse:%flagVal%>"
      - adjust <player> 'action_bar:<parse:%flagVal%>'
      }

  event-global:
  # We should only get a message from the highest priority region, but let's inherit from parents.
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|farewell]>'
    - if %flagVal% != null {
#      - narrate "<def[flagVal].replace[regex:&([0-9a-fA-Fk-oK-OrR])].with[<&r.before[r]>$1]>
      - narrate "<parse:%flagVal%>"
      - adjust <player> 'action_bar:<parse:%flagVal%>'
      }


dRegions_Flag_Inventory:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Inventory<&4>]"
  lore:
  - <&5>Save inventory before going into a region
  event_hook: regionToggle
  event_priority: 10
  flag_type: custom
  flag_type_customVal: unique|kit
  flag_help: Inventory flag can be set to unique or kit. Unique inventories start empty. Kit inventories use your current inventory.
  flag_takeGroup: true
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - if <def[flagValue].is[==].to[kit]> {
      - yaml set 'inventories.regions.%region%.entry.kit.equip:<player.equipment>' 'id:dRegions_%world%_inventories'
      - yaml set 'inventories.regions.%region%.entry.kit.inv:<player.inventory.list_contents>' 'id:dRegions_%world%_inventories'
      - yaml set 'inventories.regions.%region%.exit.players:|:' 'id:dRegions_%world%_inventories'
      }
    - if <def[flagValue].is[==].to[unique]> {
      - yaml set 'inventories.regions.%region%.entry.players:|:' 'id:dRegions_%world%_inventories'
      - yaml set 'inventories.regions.%region%.exit.players:|:' 'id:dRegions_%world%_inventories'
      }
    - if <def[flagValue].is[==].to[null]> {
      - yaml set 'inventories.regions.%region%:!' 'id:dRegions_%world%_inventories'
      }
    - yaml 'savefile:dRegions/worlds/%world%/inventories.yml' 'id:dRegions_%world%_inventories'

  event-enter:
    - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|inventory]>'
    - if %flagObj% != null {
      - if <proc[dRegions_PlayerMatchRegionGroup].context[<def[flagObj].split[/].get[2]||all>|%region%|%world%|<player>]> {
        - inject locally <def[flagObj].split[/].get[1]>-enter
        }
      }

  event-exit:
    - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|inventory]>'
    - if %flagObj% != null {
      - if <proc[dRegions_PlayerMatchRegionGroup].context[<def[flagObj].split[/].get[2]||all>|%region%|%world%|<player>]> {
        - inject locally <def[flagObj].split[/].get[1]>-exit
        }
      }

  kit-enter:
    - yaml set 'inventories.regions.%region%.exit.players.<player.uuid>.equip:<player.equipment>' 'id:dRegions_%world%_inventories'
    - yaml set 'inventories.regions.%region%.exit.players.<player.uuid>.inv:<player.inventory.list_contents>' 'id:dRegions_%world%_inventories'
    - yaml 'savefile:dRegions/worlds/%world%/inventories.yml' 'id:dRegions_%world%_inventories'
    - inventory clear
    - inventory set 'd:<player.inventory>' 'o:<yaml[dRegions_%world%_inventories].read[inventories.regions.%region%.entry.kit.inv]||li@>'
    - define equipment '<yaml[dRegions_%world%_inventories].read[inventories.regions.%region%.entry.kit.equip]||li@>'
    - equip <player> 'boots:<def[equipment].get[1]||i@air>' 'legs:<def[equipment].get[2]||i@air>' 'chest:<def[equipment].get[3]||i@air>' 'head:<def[equipment].get[4]||i@air>'
    - run s@dRegions_Msg delay:1t 'def:<&7><&o>Your inventory has been updated.'

  kit-exit:
    - define equipment '<yaml[dRegions_%world%_inventories].read[inventories.regions.%region%.exit.players.<player.uuid>.equip]||li@>'
    - inventory clear
    - inventory set 'd:<player.inventory>' 'o:<yaml[dRegions_%world%_inventories].read[inventories.regions.%region%.exit.players.<player.uuid>.inv]||li@>'
    - equip <player> 'boots:<def[equipment].get[1]||i@air>' 'legs:<def[equipment].get[2]||i@air>' 'chest:<def[equipment].get[3]||i@air>' 'head:<def[equipment].get[4]||i@air>'
    - yaml set 'inventories.regions.%region%.exit.players.<player.uuid>:!' 'id:dRegions_%world%_inventories'
    - yaml 'savefile:dRegions/worlds/%world%/inventories.yml' 'id:dRegions_%world%_inventories'
    - run s@dRegions_Msg delay:1t 'def:<&7><&o>Your inventory has been updated.'

  unique-enter:
    - yaml set 'inventories.regions.%region%.exit.players.<player.uuid>.equip:<player.equipment>' 'id:dRegions_%world%_inventories'
    - yaml set 'inventories.regions.%region%.exit.players.<player.uuid>.inv:<player.inventory.list_contents>' 'id:dRegions_%world%_inventories'
    - yaml 'savefile:dRegions/worlds/%world%/inventories.yml' 'id:dRegions_%world%_inventories'
    - inventory clear
    - inventory set 'd:<player.inventory>' 'o:<yaml[dRegions_%world%_inventories].read[inventories.regions.%region%.entry.players.<player.uuid>.inv]||li@>'
    - define equipment '<yaml[dRegions_%world%_inventories].read[inventories.regions.%region%.entry.players.<player.uuid>.equip]||li@>'
    - equip <player> 'boots:<def[equipment].get[1]||i@air>' 'legs:<def[equipment].get[2]||i@air>' 'chest:<def[equipment].get[3]||i@air>' 'head:<def[equipment].get[4]||i@air>'
    - run s@dRegions_Msg delay:1t 'def:<&7><&o>Your inventory has been updated.'

  unique-exit:
    - yaml set 'inventories.regions.%region%.entry.players.<player.uuid>.equip:<player.equipment>' 'id:dRegions_%world%_inventories'
    - yaml set 'inventories.regions.%region%.entry.players.<player.uuid>.inv:<player.inventory.list_contents>' 'id:dRegions_%world%_inventories'
    - define equipment '<yaml[dRegions_%world%_inventories].read[inventories.regions.%region%.exit.players.<player.uuid>.equip]||li@>'
    - inventory clear
    - inventory set 'd:<player.inventory>' 'o:<yaml[dRegions_%world%_inventories].read[inventories.regions.%region%.exit.players.<player.uuid>.inv]||li@>'
    - equip <player> 'boots:<def[equipment].get[1]||i@air>' 'legs:<def[equipment].get[2]||i@air>' 'chest:<def[equipment].get[3]||i@air>' 'head:<def[equipment].get[4]||i@air>'
    - yaml set 'inventories.regions.%region%.exit.players.<player.uuid>:!' 'id:dRegions_%world%_inventories'
    - yaml 'savefile:dRegions/worlds/%world%/inventories.yml' 'id:dRegions_%world%_inventories'
    - run s@dRegions_Msg delay:1t 'def:<&7><&o>Your inventory has been updated.'


dRegions_Flag_Gamemode:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Gamemode<&4>]"
  lore:
  - <&5>Change gamemode inside a region
  event_hook: regionToggle
  event_priority: 20
  flag_type: custom
  flag_type_customVal: creative|survival|adventure
  flag_help: Gamemode flag can be set to creative, survival, or adventure
  flag_takeGroup: true
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event-enter:
    - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|gamemode]>'
    - if %flagObj% != null {
      - if <proc[dRegions_PlayerMatchRegionGroup].context[<def[flagObj].split[/].get[2]||all>|%region%|%world%|<player>]> {
        - define gm '<def[flagObj].split[/].get[1]>'
        - if %gm% != <player.gamemode> {
          - flag <player> 'dRegions_%world%_%region%_PreviousGamemode:<player.gamemode>'
          - adjust <player> 'gamemode:%gm%'
          - run s@dRegions_Msg delay:1t 'def:<&7><&o>Your gamemode has been updated.'
          }
        }
      }

  event-exit:
    - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|gamemode]>'
    - if %flagObj% != null {
      - if <proc[dRegions_PlayerMatchRegionGroup].context[<def[flagObj].split[/].get[2]||all>|%region%|%world%|<player>]> {
        - if <player.flag[dRegions_%world%_%region%_PreviousGamemode]||null> != <player.gamemode> {
          - adjust <player> 'gamemode:<player.flag[dRegions_%world%_%region%_PreviousGamemode]||survival>'
          - run s@dRegions_Msg delay:1t 'def:<&7><&o>Your gamemode has been updated.'
          }
        - flag <player> 'dRegions_%world%_%region%_PreviousGamemode:!'
        }
      }


dRegions_Flag_Build:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Build<&4>]"
  lore:
  - <&5>Override default build perms
  event_hook: build
  event_priority: 0
  flag_type: state
  flag_name: Build
  flag_help: By default, all members and owners can build in their regions. Setting this flag can over ride that behavior. Can be set to allow, deny, or none and accepts the -g group switch.
  flag_takeGroup: true
  flag_defaultValue: deny/nonmembers
  flag_globalDefault: none
  region_highestOnly: true
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event-cleanup:
    - run locally msg delay:1t

  msg:
    - ^if <player.has_flag[dRegions_Message_Cooldown].not> {
      - flag player dRegions_Message_Cooldown duration:3s
      - run s@dRegions_Msg delay:1t 'def:<&c><&o>You do not have permission to build in this region'
      }

  event-global:
  # Build is handled differently than the other flags. It checks only the HIGHEST
  # priority region. It does inherit owners, members, and flags from parent regions.
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|build]>'
      - if %flagObj% != null {
        - define player <player>
        - inject s@dRegions_Flags_Processors p:state-withGroup-global
        }
      }

  event:
  # Build is handled differently than the other flags. It checks only the HIGHEST
  # priority region. It does inherit owners, members, and flags from parent regions.
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - define region '<def[orderedRegions].get[1]>'
      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|build]>'
      - if %flagObj% == null {
        - define flagObj 'deny/nonmembers'
        }
      - define player <player>
      - inject s@dRegions_Flags_Processors p:state-withGroup
      }


dRegions_Flag_Vehicle-Place:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Vehicle-Place<&4>]"
  lore:
  - <&5>Who can place vehicles
  event_hook: placeVehicle
  event_priority: 5
  flag_type: state
  flag_help: Control who can place vehicles in a region. Takes the -g group switch.
  flag_takeGroup: true
  flag_defaultValue: deny/nonmembers
  flag_globalDefault: none
  region_highestOnly: true
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event-cleanup:
    - run locally msg delay:1t 'def:<c.item.material.name.replace[_].with[ ]>'

  msg:
    - ^if <player.has_flag[dRegions_Message_Cooldown].not> {
      - flag player dRegions_Message_Cooldown duration:3s
      - run s@dRegions_Msg delay:1t 'def:<&c><&o>You can not place %1%s here.'
      }

  event:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - foreach %orderedRegions% {
        - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|vehicle-place]>'
        - define region '%value%'
        - if %flagObj% != null {
          - foreach stop
          }
        }
      - if %flagObj% == null {
        - define flagObj 'deny/nonmembers'
        }
      - define player <player>
      - inject s@dRegions_Flags_Processors p:state-withGroup
      }

  event-global:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|vehicle-place]>'
      - if %flagObj% != null {
        - define player <player>
        - inject s@dRegions_Flags_Processors p:state-withGroup-global
        }
      }


dRegions_Flag_Vehicle-Destroy:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Vehicle-Destroy<&4>]"
  lore:
  - <&5>Who can destroy vehicles
  event_hook: destroyVehicle
  event_priority: 10
  flag_type: state
  flag_help: Control who can destroy vehicles in a region. Takes the -g group switch.
  flag_takeGroup: true
  flag_defaultValue: deny/nonmembers
  flag_globalDefault: none
  region_highestOnly: true
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event-cleanup:
    - run locally msg delay:1t 'def:<c.vehicle.entity_type.to_lowercase.replace[_].with[ ]>'

  msg:
    - ^if <player.has_flag[dRegions_Message_Cooldown].not> {
      - flag player dRegions_Message_Cooldown duration:3s
      - run s@dRegions_Msg delay:1t 'def:<&c><&o>You can not break %1%s here.'
      }

  event:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - foreach %orderedRegions% {
        - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|vehicle-destroy]>'
        - define region '%value%'
        - if %flagObj% != null {
          - foreach stop
          }
        }
      - if %flagObj% == null {
        - define flagObj 'deny/nonmembers'
        }
      - define player <player>
      - inject s@dRegions_Flags_Processors p:state-withGroup
      }

  event-global:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|vehicle-destroy]>'
      - if %flagObj% != null {
        - define player <player>
        - inject s@dRegions_Flags_Processors p:state-withGroup-global
        }
      }


dRegions_Flag_Send-Chat:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Send-Chat<&4>]"
  lore:
  - <&5>Who can chat
  event_hook: sendChat
  event_priority: 10
  flag_type: state
  flag_help: Control who can send chat in a region. Takes the -g group switch.
  flag_takeGroup: true
  flag_defaultValue: none
  flag_globalDefault: none
  region_highestOnly: true
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event-cleanup:
    - run locally msg delay:1t

  msg:
    - ^if <player.has_flag[dRegions_Message_Cooldown].not> {
      - flag player dRegions_Message_Cooldown duration:3s
      - run s@dRegions_Msg delay:1t 'def:<&c><&o>You can not chat here.'
      }

  event:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - foreach %orderedRegions% {
        - define region '<def[orderedRegions].get[1]>'
        - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|send-chat]>'
        - if %flagObj% != null {
          - define player <player>
          - inject s@dRegions_Flags_Processors p:state-withGroup
          - foreach stop
          }
        }
      }


  event-global:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|send-chat]>'
      - if %flagObj% != null {
        - define player <player>
        - inject s@dRegions_Flags_Processors p:state-withGroup-global
        }
      }


dRegions_Flag_Hunger:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Hunger<&4>]"
  lore:
  - <&5>Who can get hungry
  event_hook: changeFood
  event_priority: 10
  flag_type: state
  flag_help: Control whether players will loose hunger in this region. Takes the -g group switch.
  flag_takeGroup: true
  flag_defaultValue: none
  flag_globalDefault: none
  region_highestOnly: false
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define region '%value%'
      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|hunger]>'
      - if %flagObj% != null {
        - define player <player>
        - inject s@dRegions_Flags_Processors p:state-withGroup
        - foreach stop
        }
      }

  event-global:
    - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|hunger]>'
    - if %flagObj% != null {
      - define player <player>
      - inject s@dRegions_Flags_Processors p:state-withGroup-global
      }


dRegions_Flag_Mob-Target:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Mob-Targeting<&4>]"
  lore:
  - <&5>Can mobs target players
  event_hook: ENTITY_Target_Player
  event_priority: 0
  flag_type: state
  flag_takeGroup: true
  flag_defaultValue: none
  flag_globalDefault: none
  flag_help: State flag controlling whether mobs will be able to target players in this region. Defaults to allow all. Use mob-target flag to specify mob types. Takes the -g group switch.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|mob-target]>'
      - define region '%value%'
      - if %flagObj% != null {
        - foreach stop
        }
      }
    - if %flagObj% != null {
      - define player '%defender%'
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|mob-targetlist].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget-withGroup
      }

  event-global:
    - define orderedRegions 'li@global'
    - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|mob-target]>'
    - if %flagObj% != null {
      - define player '%defender%'
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|mob-targetlist].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget-withGroup
      }

  event-cleanup:
    - remove <c.projectile||li@>
    - attack %attacker% target:cancel



dRegions_Flag_Mob-TargetList:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Mob-Target<&4>]"
  lore:
  - <&5>List of mobs used by mob-targeting flag
  command_entryType: mob
  command_verifyEntry: <def[value].is[matches].to[entity].not>
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with mob-targeting flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of mobs.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - inject s@dRegions_Flags_CommandProcessors p:command_verifiedList


dRegions_Flag_Mob-Damage:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Mob-Damage<&4>]"
  lore:
  - <&5>Can mobs damage players
  event_hook: ENTITY_Damage_Player
  event_priority: 10
  flag_type: state
  flag_takeGroup: true
  flag_defaultValue: none
  flag_globalDefault: none
  flag_help: State flag controlling whether mobs will be able to damage players in this region. Defaults to allow all. Use mob-damagelist flag to specify mob types. Takes the -g group switch.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|mob-damage]>'
      - define region '%value%'
      - if %flagObj% != null {
        - foreach stop
        }
      }
    - if %flagObj% != null {
      - define player '%defender%'
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|mob-damagelist].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget-withGroup
      }

  event-global:
    - define orderedRegions 'li@global'
    - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|mob-damage]>'
    - if %flagObj% != null {
      - define player '%defender%'
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|mob-damagelist].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget-withGroup
      }

  event-cleanup:
    - remove <c.projectile||li@>
    - attack %attacker% target:cancel


dRegions_Flag_Mob-Damagelist:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Mob-DamageList<&4>]"
  lore:
  - <&5>List of mobs used by mob-damage flag
  command_entryType: mob
  command_verifyEntry: <def[value].is[matches].to[entity].not>
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with mob-damage flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of mobs.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - inject s@dRegions_Flags_CommandProcessors p:command_verifiedList


dRegions_Flag_Mob-Spawn:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Mob-Spawn<&4>]"
  lore:
  - <&5>Can mobs Spawn
  event_hook: ENTITY_Spawn
  event_priority: 10
  flag_type: state
  flag_takeGroup: false
  flag_defaultValue: none
  flag_globalDefault: none
  flag_help: State flag controlling whether mobs will be able to spawn in this region. Defaults to allow all. Use mob-spawnlist flag to specify mob types.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|mob-spawn]>'
      - define region '%value%'
      - if %flagVal% != null {
        - foreach stop
        }
      }
    - if %flagVal% != null {
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|mob-spawnlist].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget
      }

  event-global:
    - define orderedRegions 'li@global'
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|mob-spawn]>'
    - if %flagVal% != null {
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|mob-spawnlist].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget
      }


dRegions_Flag_Mob-SpawnList:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Mob-Spawnlist<&4>]"
  lore:
  - <&5>List of mobs used by mob-spawn flag
  command_entryType: mob
  command_verifyEntry: <def[value].is[matches].to[entity].not>
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with mob-spawn flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of mobs.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - inject s@dRegions_Flags_CommandProcessors p:command_verifiedList


dRegions_Flag_EVE:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>EVE<&4>]"
  lore:
  - <&5>Can mobs be targeted
  event_hook: ENTITY_Target_ENTITY
  event_priority: 20
  flag_type: state
  flag_takeGroup: false
  flag_defaultValue: none
  flag_globalDefault: none
  flag_help: State flag controlling whether mobs can be targeted for attack by other mobs in this region. Defaults to allow. Use eve-moblist flag to specify mob types.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|eve]>'
      - define region '%value%'
      - if %flagVal% != null {
        - foreach stop
        }
      }
    - if %flagVal% != null {
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|eve-moblist].replace[, ].with[|].as_list>'
      - define target '%dtarget%'
      - inject s@dRegions_Flags_Processors p:state-withTarget
      }

  event-global:
    - define orderedRegions 'li@global'
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|eve]>'
    - if %flagVal% != null {
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|eve-moblist].replace[, ].with[|].as_list>'
      - define target '%dtarget%'
      - inject s@dRegions_Flags_Processors p:state-withTarget
      }

  event-cleanup:
    - remove <c.projectile||li@>
    - attack %attacker% target:cancel


dRegions_Flag_EVE-Moblist:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>EVE-Moblist<&4>]"
  lore:
  - <&5>List of mobs used by eve flag
  command_entryType: mob
  command_verifyEntry: <def[value].is[matches].to[entity].not>
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with eve flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of mobs.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - inject s@dRegions_Flags_CommandProcessors p:command_verifiedList


dRegions_Flag_Mob-Attack:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Mob-Attack<&4>]"
  lore:
  - <&5>Can mobs attack other mobs
  event_hook: ENTITY_Target_ENTITY
  event_priority: 10
  flag_type: state
  flag_takeGroup: false
  flag_defaultValue: none
  flag_globalDefault: none
  flag_help: State flag controlling whether mobs can attack other mobs in this region. Defaults to allow. Use mob-attack-moblist flag to specify mob types.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|mob-attack]>'
      - define region '%value%'
      - if %flagVal% != null {
        - foreach stop
        }
      }
    - if %flagVal% != null {
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|mob-attack-moblist].replace[, ].with[|].as_list>'
      - define target '%atarget%'
      - inject s@dRegions_Flags_Processors p:state-withTarget
      }

  event-global:
    - define orderedRegions 'li@global'
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|mob-attack]>'
    - if %flagVal% != null {
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|mob-attack-moblist].replace[, ].with[|].as_list>'
      - define target '%atarget%'
      - inject s@dRegions_Flags_Processors p:state-withTarget
      }

  event-cleanup:
    - remove <c.projectile||li@>
    - attack %attacker% target:cancel


dRegions_Flag_Mob-Attack-Moblist:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Mob-Attack-Moblist<&4>]"
  lore:
  - <&5>List of mobs used by mob-attack flag
  command_entryType: mob
  command_verifyEntry: <def[value].is[matches].to[entity].not>
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with mob-attack flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of mobs.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - inject s@dRegions_Flags_CommandProcessors p:command_verifiedList


dRegions_Flag_PVE:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>PVE<&4>]"
  lore:
  - <&5>Can players damage mobs
  event_hook: PLAYER_Damage_Entity
  event_priority: 10
  flag_type: state
  flag_takeGroup: true
  flag_defaultValue: none
  flag_globalDefault: none
  flag_help: State flag controlling whether players will be able to damage mobs in this region. Defaults to allow all. Use pve-moblist flag to specify mob types. Takes the -g group switch.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|pve]>'
      - define region '%value%'
      - if %flagObj% != null {
        - foreach stop
        }
      }
    - if %flagObj% != null {
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|pve-moblist].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget-withGroup
      }

  event-global:
    - define orderedRegions 'li@global'
    - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|pve]>'
    - if %flagObj% != null {
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|pve-moblist].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget-withGroup
      }

  event-cleanup:
    - remove <c.projectile||li@>
    - run locally msg delay:1t 'def:<def[target].to_lowercase.replace[_].with[ ]>'

  msg:
    - ^if <player.has_flag[dRegions_Message_Cooldown].not> {
      - flag player dRegions_Message_Cooldown duration:3s
      - run s@dRegions_Msg delay:1t 'def:<&c><&o>You can not attack %1%s here!'
      }


dRegions_Flag_PVE-Moblist:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>PVE-Moblist<&4>]"
  lore:
  - <&5>List of mobs used by pve flag
  command_entryType: mob
  command_verifyEntry: <def[value].is[matches].to[entity].not>
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with pve flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of mobs.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - inject s@dRegions_Flags_CommandProcessors p:command_verifiedList


dRegions_Flag_Npc-Interact:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>NPC Interact<&4>]"
  lore:
  - <&5>Can players interact with NPCs
  event_hook: npc-interact
  event_priority: 10
  flag_type: state
  flag_takeGroup: true
  flag_defaultValue: none
  flag_globalDefault: none
  flag_help: State flag controlling whether players will be able to interact with NPCs in this region. Defaults to allow. Takes the -g group switch.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - foreach %orderedRegions% {
        - define region '%value%'
        - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|npc-interact]>'
        - if %flagObj% != null {
          - foreach stop
          }
        }
      - if %flagObj% != null {
        - define player <player>
        - inject s@dRegions_Flags_Processors p:state-withGroup
        }
      }

  event-global:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|npc-interact]>'
      - if %flagObj% != null {
        - define player <player>
        - inject s@dRegions_Flags_Processors p:state-withGroup-global
        }
      }

  event-cleanup:
    - run locally msg delay:1t 'def:<def[target].to_lowercase.replace[_].with[ ]>'

  msg:
    - ^if <player.has_flag[dRegions_Message_Cooldown].not> {
      - flag player dRegions_Message_Cooldown duration:3s
      - run s@dRegions_Msg delay:1t 'def:<&c><&o>You can not interact with NPCs here!'
      }


dRegions_Flag_Entity-Interact:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Entity Interact<&4>]"
  lore:
  - <&5>Can players interact with entities
  event_hook: entity-interact
  event_priority: 10
  flag_type: state
  flag_takeGroup: true
  flag_defaultValue: none
  flag_globalDefault: none
  flag_help: State flag controlling whether players will be able to interact with entities in this region. Defaults to allow all. Use entity-interactlist flag to specify entity types. Takes the -g group switch.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|entity-interact]>'
      - define region '%value%'
      - if %flagObj% != null {
        - foreach stop
        }
      }
    - if %flagObj% != null {
      - define player '<player>'
      - define target '<c.entity.entity_type>'
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|entity-interactlist].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget-withGroup
      }

  event-global:
    - define orderedRegions 'li@global'
    - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|entity-interact]>'
    - if %flagObj% != null {
      - define player '<player>'
      - define target '<c.entity.entity_type>'
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|entity-interactlist].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget-withGroup
      }

  event-cleanup:
    - run locally msg delay:1t 'def:<def[target].to_lowercase.replace[_].with[ ]>'

  msg:
    - ^if <player.has_flag[dRegions_Message_Cooldown].not> {
      - flag player dRegions_Message_Cooldown duration:3s
      - run s@dRegions_Msg delay:1t 'def:<&c><&o>You can not interact with %1%s here!'
      }


dRegions_Flag_Entity-Interactlist:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Entity Interact List<&4>]"
  lore:
  - <&5>List of entities used by entity-interact flag
  command_entryType: mob
  command_verifyEntry: <def[value].is[matches].to[entity].not>
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with entity-interact flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of entities.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - inject s@dRegions_Flags_CommandProcessors p:command_verifiedList


dRegions_Flag_Entity-Explode:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Entity-Explode<&4>]"
  lore:
  - <&5>Can entities explode
  event_hook: entity-explode
  event_priority: 10
  flag_type: state
  flag_takeGroup: false
  flag_defaultValue: none
  flag_globalDefault: none
  flag_help: State flag controlling whether entities will be able to explode in this region. Defaults to allow all. Use entity-explodelist flag to specify entities types.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|entity-explode]>'
      - define region '%value%'
      - if %flagVal% != null {
        - foreach stop
        }
      }
    - if %flagVal% != null {
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|entity-explodelist].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget
      }

  event-global:
    - define orderedRegions 'li@global'
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|entity-explode]>'
    - if %flagVal% != null {
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|entity-explodelist].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget
      }

  event-cleanup:
    - foreach <def[attacker].location.find.entities.within[5].exclude[%attacker%]> {
      - adjust %value% 'velocity:l@0,0,0,%world%'
      }


dRegions_Flag_Entity-ExplodeList:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Entity-Explodelist<&4>]"
  lore:
  - <&5>List of mobs used by entity-explode flag
  command_entryType: entity
  command_verifyEntry: <el@val[creeper|ender_crystal|ender_dragon|primed_tnt|minecart_tnt|fireball|small_fireball|wither|wither_skull].as_list.contains[<def[value]>].not>
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with entity-explode flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of entities. Valid entities<&co> creeper, ender_crystal, ender_dragon, primed_tnt, minecart_tnt, fireball, small_fireball, wither, wither_skull
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - inject s@dRegions_Flags_CommandProcessors p:command_verifiedList


dRegions_Flag_Entity-Grief:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Entity-Grief<&4>]"
  lore:
  - <&5>Can entities alter blocks
  event_hook: entity-changeBlock
  event_priority: 10
  flag_type: state
  flag_takeGroup: false
  flag_defaultValue: none
  flag_globalDefault: none
  flag_help: State flag controlling whether entities will be able to alter blocks in this region. Defaults to allow all. Use entity-grieflist flag to specify entities types.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|entity-grief]>'
      - define region '%value%'
      - if %flagVal% != null {
        - foreach stop
        }
      }
    - if %flagVal% != null {
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|entity-grieflist].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget
      }

  event-global:
    - define orderedRegions 'li@global'
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|entity-grief]>'
    - if %flagVal% != null {
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|entity-grieflist].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget
      }

  event-cleanup:
    - run locally offthread delay:1t def:<c.entity.uuid>

  offthread:
    - ^flag server dRegions.EntityGrief.%1%
    - ^wait 3s
    - ^flag server dRegions.EntityGrief.%1%:!


dRegions_Flag_Entity-GriefList:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Entity-Grieflist<&4>]"
  lore:
  - <&5>List of mobs used by entity-grief flag
  command_entryType: entity
  command_verifyEntry: <el@val[enderman|sheep|zombie|squid].as_list.contains[<def[value]>].not>
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with entity-grief flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of entities. Valid entities<&co> sheep, enderman, zombie, squid
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - inject s@dRegions_Flags_CommandProcessors p:command_verifiedList


dRegions_Flag_Entity-Drops-OnDeath:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Entity-Drops-OnDeath<&4>]"
  lore:
  - <&5>Can mobs drop items
  event_hook: EntityDies
  event_priority: 10
  flag_type: state
  flag_takeGroup: false
  flag_defaultValue: none
  flag_globalDefault: none
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|entity-drops-ondeath]>'
      - define region '%value%'
      - if %flagVal% != null {
        - foreach stop
        }
      }
    - if %flagVal% != null {
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|entity-drops-ondeathlist].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget
      }

  event-global:
    - define orderedRegions 'li@global'
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|entity-drops-ondeath]>'
    - if %flagVal% != null {
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|entity-drops-ondeathlist].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget
      }

  event-cleanup:
    - determine no_drops


dRegions_Flag_Entity-Drops-OnDeathList:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Entity-Drops-OnDeathlist<&4>]"
  lore:
  - <&5>List of mobs used by entity-drops-ondeath flag
  command_entryType: entity
  command_verifyEntry: <def[value].is[matches].to[entity].not>
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with entity-drops-ondeath flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of entities.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - inject s@dRegions_Flags_CommandProcessors p:command_verifiedList


dRegions_Flag_Fire-Spread:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Fire-Spread<&4>]"
  lore:
  - <&5>Can fire spread
  event_hook: fireFrom-Spread
  event_priority: 10
  flag_type: state
  flag_takeGroup: false
  flag_defaultValue: none
  flag_globalDefault: none
  flag_help: State flag controlling whether fire will be able to spread in this region. Defaults to allow all. Use fire-spreadblocks flag to specify blocks to check when spreading.
#  flag_help: This flag is temporarily disabled. Please use the fire-destroyblocks flag.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|fire-spread]>'
      - define region '%value%'
      - if %flagVal% != null {
        - foreach stop
        }
      }
    - if %flagVal% != null {
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|fire-spreadblocks].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget
      }

  event-global:
    - define orderedRegions 'li@global'
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|fire-spread]>'
    - if %flagVal% != null {
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|fire-spreadblocks].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget
      }


dRegions_Flag_Fire-SpreadBlocks:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Fire-Spread-BlockList<&4>]"
  lore:
  - <&5>List of blocks involved in fire spread
  command_entryType: block
  command_verifyEntry: <def[value].as_material.is_block.not||true>
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with fire-spread flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of blocks.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - inject s@dRegions_Flags_CommandProcessors p:command_verifiedList


dRegions_Flag_Fire-Destroy:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Fire-Destroy<&4>]"
  lore:
  - <&5>Can fire destroy blocks
  event_hook: fire-destroyBlocks
  event_priority: 10
  flag_type: state
  flag_takeGroup: false
  flag_defaultValue: none
  flag_globalDefault: none
  flag_help: State flag controlling whether fire will be able to spread to and destroy blocks in this region. Defaults to allow all. Use fire-destroyblocks flag to specify blocks to check when spreading.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|fire-destroy]>'
      - define region '%value%'
      - if %flagVal% != null {
        - foreach stop
        }
      }
    - if %flagVal% != null {
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|fire-destroyblocks].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget
      }

  event-global:
    - define orderedRegions 'li@global'
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|fire-destroy]>'
    - if %flagVal% != null {
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|fire-destroyblocks].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget
      }


dRegions_Flag_Fire-DestroyBlocks:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Fire-Destroy-BlockList<&4>]"
  lore:
  - <&5>List of blocks involved in fire-destroy
  command_entryType: block
  command_verifyEntry: <def[value].as_material.is_block.not||true>
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with fire-destroy flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of blocks.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - inject s@dRegions_Flags_CommandProcessors p:command_verifiedList


dRegions_Flag_Lightning-Strikes:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Lightning-Strikes<&4>]"
  lore:
  - <&5>Can lightning strike
  event_hook: lightning-strikes
  event_priority: 10
  flag_type: state
  flag_takeGroup: false
  flag_defaultValue: none
  flag_globalDefault: none
  flag_help: State flag controlling whether lightning will be able to strike in this region. Defaults to allow all. Use lightning-strikeblocks flag to specify blocks to check when striking.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|lightning-strikes]>'
      - define region '%value%'
      - if %flagVal% != null {
        - foreach stop
        }
      }
    - if %flagVal% != null {
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|lightning-strikesblocks].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget
      }

  event-global:
    - define orderedRegions 'li@global'
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|lightning-strikes]>'
    - if %flagVal% != null {
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|lightning-strikesblocks].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget
      }


dRegions_Flag_Lightning-StrikesBlocks:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Lightning-StrikesBlocks<&4>]"
  lore:
  - <&5>List of blocks involved in lightning strikes
  command_entryType: block
  command_verifyEntry: <def[value].as_material.is_block.not||true>
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with lightning-strike flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of blocks.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - inject s@dRegions_Flags_CommandProcessors p:command_verifiedList


dRegions_Flag_Water-Spread:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Water-Spread<&4>]"
  lore:
  - <&5>Can Water spread
  event_hook: WaterSpread
  event_priority: 10
  flag_type: state
  flag_takeGroup: false
  flag_defaultValue: none
  flag_globalDefault: none
  flag_help: State flag controlling whether water will be able to spread in this region. Defaults to allow all. Use water-spreadblocks flag to specify blocks to check when spreading.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|water-spread]>'
      - define region '%value%'
      - if %flagVal% != null {
        - foreach stop
        }
      }
    - if %flagVal% != null {
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|water-spreadblocks].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget
      }

  event-global:
    - define orderedRegions 'li@global'
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|water-spread]>'
    - if %flagVal% != null {
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|water-spreadblocks].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget
      }


dRegions_Flag_Water-SpreadBlocks:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Water-Spread-BlockList<&4>]"
  lore:
  - <&5>List of blocks involved in water spread
  command_entryType: block
  command_verifyEntry: <def[value].as_material.is_block.not||true>
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with water-spread flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of blocks.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - inject s@dRegions_Flags_CommandProcessors p:command_verifiedList


dRegions_Flag_Lava-Spread:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Lava-Spread<&4>]"
  lore:
  - <&5>Can Lava spread
  event_hook: LavaSpread
  event_priority: 10
  flag_type: state
  flag_takeGroup: false
  flag_defaultValue: none
  flag_globalDefault: none
  flag_help: State flag controlling whether lava will be able to spread in this region. Defaults to allow all. Use lava-spreadblocks flag to specify blocks to check when spreading.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|lava-spread]>'
      - define region '%value%'
      - if %flagVal% != null {
        - foreach stop
        }
      }
    - if %flagVal% != null {
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|lava-spreadblocks].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget
      }

  event-global:
    - define orderedRegions 'li@global'
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|lava-spread]>'
    - if %flagVal% != null {
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|lava-spreadblocks].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget
      }


dRegions_Flag_Lava-SpreadBlocks:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Lava-Spread-BlockList<&4>]"
  lore:
  - <&5>List of blocks involved in lava spread
  command_entryType: block
  command_verifyEntry: <def[value].as_material.is_block.not||true>
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with lava-spread flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of blocks.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - inject s@dRegions_Flags_CommandProcessors p:command_verifiedList


dRegions_Flag_Snow-Fall:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Snow-Fall<&4>]"
  lore:
  - <&5>Can Snow accumulate
  event_hook: blockForm-snow
  event_priority: 10
  flag_type: state
  flag_takeGroup: false
  flag_defaultValue: none
  flag_globalDefault: none
  flag_help: State flag controlling whether snow will be able to accumulate on the ground in this region. Defaults to allow all. Use snow-fallblocks flag to specify blocks below the snow to check when forming.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|snow-fall]>'
      - define region '%value%'
      - if %flagVal% != null {
        - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|snow-fallblocks].replace[, ].with[|].as_list>'
        - inject s@dRegions_Flags_Processors p:state-withTarget
#        - yaml set 'cache.state-withTarget.%region%.snow-fall.%target%:true' 'id:dRegions_%world%_cache'
        }
      }

  event-global:
    - define region '__global__'
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|snow-fall]>'
    - if %flagVal% != null {
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|snow-fallblocks].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget
      }
#    - yaml set 'cache.state-withTarget.__global__.snow-fall.%target%:true' 'id:dRegions_%world%_cache'

#  event-cleanup:
#    - yaml set 'cache.state-withTarget.%region%.snow-fall.%target%:false' 'id:dRegions_%world%_cache'


dRegions_Flag_Snow-FallBlocks:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Snow-Fall-BlockList<&4>]"
  lore:
  - <&5>List of blocks to check under snow
  command_entryType: block
  command_verifyEntry: <def[value].as_material.is_block.not||true>
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with snow-fall flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of blocks.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - inject s@dRegions_Flags_CommandProcessors p:command_verifiedList


dRegions_Flag_Ice-Form:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Ice-Form<&4>]"
  lore:
  - <&5>Can water turn into ice
  event_hook: blockForm-ice
  event_priority: 10
  flag_type: boolean
  flag_defaultValue: true
  flag_globalDefault: true
  flag_help: Boolean flag controlling whether water will be able to turn into ice in this region. Defaults to true.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|ice-form]>'
      - if %flagVal% != null {
        - if %flagVal% {
#          - yaml set 'cache.boolean.%value%.ice-form:true' 'id:dRegions_%world%_cache'
          - foreach stop
          }
#        - yaml set 'cache.boolean.%value%.ice-form:false' 'id:dRegions_%world%_cache'
        - determine cancelled
        }
      }

  event-global:
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|ice-form]>'
    - if %flagVal% != null {
      - if !%flagVal% {
#        - yaml set 'cache.boolean.__global__.ice-form:false' 'id:dRegions_%world%_cache'
        - determine cancelled
        }
      }
#    - yaml set 'cache.boolean.__global__.ice-form:true' 'id:dRegions_%world%_cache'


dRegions_Flag_Ice-Melt:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Ice-Melt<&4>]"
  lore:
  - <&5>Can ice melt
  event_hook: blockFade-ice
  event_priority: 10
  flag_type: boolean
  flag_defaultValue: true
  flag_globalDefault: true
  flag_help: Boolean flag controlling whether ice can melt in this region. Defaults to true.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|ice-melt]>'
      - if %flagVal% != null {
        - if !%flagVal% {
#          - yaml set 'cache.boolean.%value%.ice-melt:false' 'id:dRegions_%world%_cache'
          - determine cancelled
          }
#        - yaml set 'cache.boolean.%value%.ice-melt:true' 'id:dRegions_%world%_cache'
        - foreach stop
        }
      }

  event-global:
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|ice-melt]>'
    - if %flagVal% != null {
      - if !%flagVal% {
#        - yaml set 'cache.boolean.__global__.ice-melt:false' 'id:dRegions_%world%_cache'
        - determine cancelled
        }
      }
#    - yaml set 'cache.boolean.__global__.ice-melt:true' 'id:dRegions_%world%_cache'


dRegions_Flag_Snow-Melt:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Snow-Melt<&4>]"
  lore:
  - <&5>Can snow melt
  event_hook: blockFade-snow
  event_priority: 10
  flag_type: boolean
  flag_defaultValue: true
  flag_globalDefault: true
  flag_help: Boolean flag controlling whether snow can melt in this region. Defaults to true.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|snow-melt]>'
      - if %flagVal% != null {
        - if !%flagVal% {
#          - yaml set 'cache.boolean.%value%.snow-melt:false' 'id:dRegions_%world%_cache'
          - determine cancelled
          }
#        - yaml set 'cache.boolean.%value%.snow-melt:true' 'id:dRegions_%world%_cache'
        - foreach stop
        }
      }

  event-global:
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|snow-melt]>'
    - if %flagVal% != null {
      - if !%flagVal% {
#        - yaml set 'cache.boolean.__global__.snow-melt:false' 'id:dRegions_%world%_cache'
        - determine cancelled
        }
      }
#    - yaml set 'cache.boolean.__global__.snow-melt:true' 'id:dRegions_%world%_cache'


dRegions_Flag_Soil-Dry:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Soil-Dry<&4>]"
  lore:
  - <&5>Can soil dry up
  event_hook: blockFade-soil
  event_priority: 10
  flag_type: boolean
  flag_defaultValue: true
  flag_globalDefault: true
  flag_help: Boolean flag controlling whether soil can dry in this region. Defaults to true.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|soil-dry]>'
      - if %flagVal% != null {
        - if !%flagVal% {
          - determine cancelled
          }
        - foreach stop
        }
      }

  event-global:
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|soil-dry]>'
    - if %flagVal% != null {
      - if !%flagVal% {
        - determine cancelled
        }
      }


dRegions_Flag_Trample-Crops-Player:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Trample-Crops-Player<&4>]"
  lore:
  - <&5>Can players trample crops
  event_hook: trample-crops-player
  event_priority: 10
  flag_type: boolean
  flag_defaultValue: true
  flag_globalDefault: true
  flag_help: Boolean flag controlling whether players can trample crops in this region. Defaults to true.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|trample-crops-player]>'
      - if %flagVal% != null {
        - if !%flagVal% {
          - determine cancelled
          }
        - foreach stop
        }
      }

  event-global:
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|trample-crops-player]>'
    - if %flagVal% != null {
      - if !%flagVal% {
        - determine cancelled
        }
      }


dRegions_Flag_Trample-Crops-Entity:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Trample-Crops-Entity<&4>]"
  lore:
  - <&5>Can entities trample crops
  event_hook: trample-crops-entity
  event_priority: 10
  flag_type: boolean
  flag_defaultValue: true
  flag_globalDefault: true
  flag_help: Boolean flag controlling whether entities can trample crops in this region. Defaults to true.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|trample-crops-entity]>'
      - if %flagVal% != null {
        - if !%flagVal% {
          - determine cancelled
          }
        - foreach stop
        }
      }

  event-global:
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|trample-crops-entity]>'
    - if %flagVal% != null {
      - if !%flagVal% {
        - determine cancelled
        }
      }


dRegions_Flag_Mushroom-Spread:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Mushroom-Spread<&4>]"
  lore:
  - <&5>Can Mushrooms spread
  event_hook: MushroomSpread
  event_priority: 10
  flag_type: boolean
  flag_takeGroup: false
  flag_defaultValue: true
  flag_globalDefault: true
  flag_help: Boolean flag controlling whether mushrooms will be able to spread in this region. Set to true or false. Defaults to true.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|mushroom-spread]>'
      - if %flagVal% != null {
        - if !%flagVal% {
          - determine cancelled
          }
        - foreach stop
        }
      }

  event-Global:
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|mushroom-spread]>'
    - if %flagVal% != null {
      - if !%flagVal% {
        - determine cancelled
        }
      }


dRegions_Flag_Grass-Spread:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Grass-Spread<&4>]"
  lore:
  - <&5>Can Grass spread
  event_hook: GrassSpread
  event_priority: 10
  flag_type: boolean
  flag_takeGroup: false
  flag_defaultValue: true
  flag_globalDefault: true
  flag_help: Boolean flag controlling whether grass will be able to spread in this region. Set to true or false. Defaults to true.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|grass-spread]>'
      - if %flagVal% != null {
        - if !%flagVal% {
          - determine cancelled
          }
        - foreach stop
        }
      }

  event-global:
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|grass-spread]>'
    - if %flagVal% != null {
      - if !%flagVal% {
        - determine cancelled
        }
      }


dRegions_Flag_Mycel-Spread:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Mycel-Spread<&4>]"
  lore:
  - <&5>Can Mycelium spread
  event_hook: MycelSpread
  event_priority: 10
  flag_type: boolean
  flag_takeGroup: false
  flag_defaultValue: true
  flag_globalDefault: true
  flag_help: Boolean flag controlling whether mycelium will be able to spread in this region. Set to true or false. Defaults to true.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|mycel-spread]>'
      - if %flagVal% != null {
        - if !%flagVal% {
          - determine cancelled
          }
        - foreach stop
        }
      }

  event-global:
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|mycel-spread]>'
    - if %flagVal% != null {
      - if !%flagVal% {
        - determine cancelled
        }
      }


dRegions_Flag_Vine-Growth:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Vine-Growth<&4>]"
  lore:
  - <&5>Can Vines grow
  event_hook: VinesSpread
  event_priority: 10
  flag_type: boolean
  flag_takeGroup: false
  flag_defaultValue: true
  flag_globalDefault: true
  flag_help: Boolean flag controlling whether vines will be able to grow in this region. Set to true or false. Defaults to true.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|vine-growth]>'
      - if %flagVal% != null {
        - if !%flagVal% {
          - determine cancelled
          }
        - foreach stop
        }
      }

  event-global:
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|vine-growth]>'
    - if %flagVal% != null {
      - if !%flagVal% {
        - determine cancelled
        }
      }


dRegions_Flag_Leaf-Decay:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Leaf-Decay<&4>]"
  lore:
  - <&5>Can leaves decay
  event_hook: leaf-decay
  event_priority: 10
  flag_type: boolean
  flag_takeGroup: false
  flag_defaultValue: true
  flag_globalDefault: true
  flag_help: Boolean flag controlling whether leaves will be able to decay in this region. Set to true or false. Defaults to true.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|leaf-decay]>'
      - if %flagVal% != null {
        - if !%flagVal% {
#          - yaml set 'cache.boolean.%value%.leaf-decay:false' 'id:dRegions_%world%_cache'
          - determine cancelled
          }
#        - yaml set 'cache.boolean.%value%.leaf-decay:true' 'id:dRegions_%world%_cache'
        - foreach stop
        }
      }

  event-global:
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|leaf-decay]>'
    - if %flagVal% != null {
      - if !%flagVal% {
#        - yaml set 'cache.boolean.__global__.leaf-decay:false' 'id:dRegions_%world%_cache'
        - determine cancelled
        }
      }
#    - yaml set 'cache.boolean.__global__.leaf-decay:true' 'id:dRegions_%world%_cache'


dRegions_Flag_Falling-Sand:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Falling-Sand<&4>]"
  lore:
  - <&5>Can sand fall
  event_hook: physics-sand
  event_priority: 10
  flag_type: boolean
  flag_takeGroup: false
  flag_defaultValue: true
  flag_globalDefault: true
  flag_help: Boolean flag controlling whether sand will be able to fall in this region. Set to true or false. Defaults to true.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|falling-sand]>'
      - if %flagVal% != null {
        - if !%flagVal% {
          - determine cancelled
          }
        - foreach stop
        }
      }

  event-global:
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|falling-sand]>'
    - if %flagVal% != null {
      - if !%flagVal% {
        - determine cancelled
        }
      }


dRegions_Flag_Falling-Gravel:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Falling-Gravel<&4>]"
  lore:
  - <&5>Can gravel fall
  event_hook: physics-gravel
  event_priority: 10
  flag_type: boolean
  flag_takeGroup: false
  flag_defaultValue: true
  flag_globalDefault: true
  flag_help: Boolean flag controlling whether gravel will be able to fall in this region. Set to true or false. Defaults to true.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|falling-gravel]>'
      - if %flagVal% != null {
        - if !%flagVal% {
          - determine cancelled
          }
        - foreach stop
        }
      }

  event-global:
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|falling-gravel]>'
    - if %flagVal% != null {
      - if !%flagVal% {
        - determine cancelled
        }
      }


dRegions_Flag_Pistons:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Pistons<&4>]"
  lore:
  - <&5>Can pistons be activated
  event_hook: pistons
  event_priority: 10
  flag_type: boolean
  flag_takeGroup: false
  flag_defaultValue: true
  flag_globalDefault: true
  flag_help: Boolean flag controlling whether pistons can be activated in this region. Set to true or false. Defaults to true.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|pistons]>'
      - if %flagVal% != null {
        - if !%flagVal% {
          - determine cancelled
          }
        - foreach stop
        }
      }

  event-global:
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|pistons]>'
    - if %flagVal% != null {
      - if !%flagVal% {
        - determine cancelled
        }
      }


dRegions_Flag_Lighter:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Lighter<&4>]"
  lore:
  - <&5>Who can use the flint and steel in a region
  event_hook: fireFrom-Lighter
  event_priority: 10
  flag_type: state
  flag_takeGroup: true
  flag_defaultValue: deny/nonmembers
  flag_globalDefault: none
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event-cleanup:
    - run locally msg delay:1t

  msg:
    - ^if <player.has_flag[dRegions_Message_Cooldown].not> {
      - flag player dRegions_Message_Cooldown duration:3s
      - run s@dRegions_Msg delay:1t 'def:<&c><&o>You can not use a lighter in this region'
      }

  event:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - foreach %orderedRegions% {
        - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|lighter]>'
        - define region '%value%'
        - if %flagObj% != null {
          - foreach stop
          }
        }
      - if %flagObj% == null {
        - define flagObj 'deny/nonmembers'
        }
      - define player <player>
      - inject s@dRegions_Flags_Processors p:state-withGroup
      }

  event-global:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|lighter]>'
      - if %flagObj% != null {
        - define player <player>
        - inject s@dRegions_Flags_Processors p:state-withGroup-global
        }
      }


dRegions_Flag_Bucket-Fill:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Bucket-Fill<&4>]"
  lore:
  - <&5>Who can fill a bucket in a region
  event_hook: fillBucket
  event_priority: 5
  flag_type: state
  flag_takeGroup: true
  flag_defaultValue: deny/nonmembers
  flag_globalDefault: none
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event-cleanup:
    - run locally msg delay:1t

  msg:
    - ^if <player.has_flag[dRegions_Message_Cooldown].not> {
      - flag player dRegions_Message_Cooldown duration:3s
      - run s@dRegions_Msg delay:1t 'def:<&c><&o>You can not fill a bucket in this region'
      }

  event:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - foreach %orderedRegions% {
        - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|bucket-fill]>'
        - define region '%value%'
        - if %flagObj% != null {
          - foreach stop
          }
        }
      - if %flagObj% == null {
        - define flagObj 'deny/nonmembers'
        }
      - define player <player>
      - inject s@dRegions_Flags_Processors p:state-withGroup
      }

  event-global:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|bucket-fill]>'
      - if %flagObj% != null {
        - define player <player>
        - inject s@dRegions_Flags_Processors p:state-withGroup-global
        }
      }


dRegions_Flag_Bucket-Empty:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Bucket-Empty<&4>]"
  lore:
  - <&5>Who can fill a bucket in a region
  event_hook: emptyBucket
  event_priority: 5
  flag_type: state
  flag_takeGroup: true
  flag_defaultValue: deny/nonmembers
  flag_globalDefault: none
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event-cleanup:
    - run locally msg delay:1t

  msg:
    - ^if <player.has_flag[dRegions_Message_Cooldown].not> {
      - flag player dRegions_Message_Cooldown duration:3s
      - run s@dRegions_Msg delay:1t 'def:<&c><&o>You can not empty a bucket in this region'
      }

  event-global:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|bucket-empty]>'
      - if %flagObj% != null {
        - define player <player>
        - inject s@dRegions_Flags_Processors p:state-withGroup-global
        }
      }

  event:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - foreach %orderedRegions% {
        - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|bucket-empty]>'
        - define region '%value%'
        - if %flagObj% != null {
          - foreach stop
          }
        }
      - if %flagObj% == null {
        - define flagObj 'deny/nonmembers'
        }
      - define player <player>
      - inject s@dRegions_Flags_Processors p:state-withGroup
      }


dRegions_Flag_Hanging-Place:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Hanging-Place<&4>]"
  lore:
  - <&5>Who can place item frames and paintings
  event_hook: hangingPlace
  event_priority: 0
  flag_type: state
  flag_takeGroup: true
  flag_defaultValue: deny/nonmembers
  flag_globalDefault: none
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event-cleanup:
    - run locally msg delay:1t

  msg:
    - ^if <player.has_flag[dRegions_Message_Cooldown].not> {
      - flag player dRegions_Message_Cooldown duration:3s
      - run s@dRegions_Msg delay:1t 'def:<&c><&o>You can not hang that in this region'
      }

  event:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - foreach %orderedRegions% {
        - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|hanging-place]>'
        - define region '%value%'
        - if %flagObj% != null {
          - foreach stop
          }
        }
      - if %flagObj% == null {
        - define flagObj 'deny/nonmembers'
        }
      - define player <player>
      - inject s@dRegions_Flags_Processors p:state-withGroup
      }

  event-global:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|hanging-place]>'
      - if %flagObj% != null {
        - define player <player>
        - inject s@dRegions_Flags_Processors p:state-withGroup-global
        }
      }


dRegions_Flag_Hanging-Break:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Hanging-Break<&4>]"
  lore:
  - <&5>Who can break item frames and paintings
  event_hook: hangingBreak
  event_priority: 0
  flag_type: state
  flag_takeGroup: true
  flag_defaultValue: deny/nonmembers
  flag_globalDefault: none
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event-cleanup:
    - run locally msg delay:1t

  msg:
    - ^if <player.has_flag[dRegions_Message_Cooldown].not> {
      - flag player dRegions_Message_Cooldown duration:3s
      - run s@dRegions_Msg delay:1t 'def:<&c><&o>You can not break that in this region'
      }

  event:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - foreach %orderedRegions% {
        - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|hanging-break]>'
        - define region '%value%'
        - if %flagObj% != null {
          - foreach stop
          }
        }
      - if %flagObj% == null {
        - define flagObj 'deny/nonmembers'
        }
      - define player <player>
      - inject s@dRegions_Flags_Processors p:state-withGroup
      }

  event-global:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|hanging-break]>'
      - if %flagObj% != null {
        - define player <player>
        - inject s@dRegions_Flags_Processors p:state-withGroup-global
        }
      }


dRegions_Flag_Sleep:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Sleep<&4>]"
  lore:
  - <&5>Who can Sleep
  event_hook: sleep
  event_priority: 10
  flag_type: state
  flag_takeGroup: true
  flag_defaultValue: deny/nonmembers
  flag_globalDefault: none
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event-cleanup:
    - run locally msg delay:1t

  msg:
    - ^if <player.has_flag[dRegions_Message_Cooldown].not> {
      - flag player dRegions_Message_Cooldown duration:3s
      - run s@dRegions_Msg delay:1t 'def:<&c><&o>You can not sleep here.'
      }

  event:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - foreach %orderedRegions% {
        - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|sleep]>'
        - define region '%value%'
        - if %flagObj% != null {
          - foreach stop
          }
        }
      - if %flagObj% == null {
        - define flagObj 'deny/nonmembers'
        }
      - define player <player>
      - inject s@dRegions_Flags_Processors p:state-withGroup
      }

  event-global:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|sleep]>'
      - if %flagObj% != null {
        - define player <player>
        - inject s@dRegions_Flags_Processors p:state-withGroup-global
        }
      }


dRegions_Flag_Player-Drops:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Player-Drops<&4>]"
  lore:
  - <&5>Who can drop items
  event_hook: player-drop
  event_priority: 10
  flag_type: state
  flag_takeGroup: true
  flag_defaultValue: none
  flag_globalDefault: none
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event-cleanup:
    - run locally msg delay:1t

  msg:
    - ^if <player.has_flag[dRegions_Message_Cooldown].not> {
      - flag player dRegions_Message_Cooldown duration:3s
      - run s@dRegions_Msg delay:1t 'def:<&c><&o>You can not drop items here.'
      }

  event:
    - foreach %orderedRegions% {
      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|player-drops]>'
      - define region '%value%'
      - if %flagObj% != null {
        - define player <player>
        - inject s@dRegions_Flags_Processors p:state-withGroup
        - foreach stop
        }
      }

  event-global:
    - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|player-drops]>'
    - if %flagObj% != null {
      - define player <player>
      - inject s@dRegions_Flags_Processors p:state-withGroup-global
      }


dRegions_Flag_Player-Drops-OnDeath:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Player-Drops-OnDeath<&4>]"
  lore:
  - <&5>Who can drop items when they die
  event_hook: PlayerDies
  event_priority: 20
  flag_type: state
  flag_takeGroup: true
  flag_defaultValue: none
  flag_globalDefault: none
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event-cleanup:
    - determine NO_DROPS

  event:
    - foreach %orderedRegions% {
      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|player-drops-ondeath]>'
      - define region '%value%'
      - if %flagObj% != null {
        - define player <player>
        - inject s@dRegions_Flags_Processors p:state-withGroup
        - foreach stop
        }
      }

  event-global:
    - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|player-drops-ondeath]>'
    - if %flagObj% != null {
      - define player <player>
      - inject s@dRegions_Flags_Processors p:state-withGroup-global
      }


dRegions_Flag_Player-KeepItems:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Player-KeepItems<&4>]"
  lore:
  - <&5>Can players keep items on death
  event_hook: PlayerDies
  event_priority: 10
  flag_type: state
  flag_takeGroup: true
  flag_defaultValue: deny/all
  flag_help: State flag controlling whether players will keep their items when they die in a region. Default is to deny all. Takes the -g group switch.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|player-keepitems]>'
      - if %flagObj% != null {
        - if <def[flagObj].split[/].get[1]> == allow {
          - if <proc[dRegions_PlayerMatchRegionGroup].context[<def[flagObj].split[/].get[2]||all>|%value%|%world%|<player>]> {
            - run locally returnItems 'def:<player.inventory.list_contents.escaped>|<player.equipment.escaped>' delay:2t
            - determine NO_DROPS_NO_XP
            - foreach stop
            }
          }
          else {
          - if !<proc[dRegions_PlayerMatchRegionGroup].context[<def[flagObj].split[/].get[2]||all>|%value%|%world%|<player>]> {
            - run locally returnItems 'def:<player.inventory.list_contents.escaped>|<player.equipment.escaped>' delay:2t
            - determine NO_DROPS_NO_XP
            - foreach stop
            }
          }
        }
      }

  event-global:
    - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|player-keepitems]>'
    - if %flagObj% != null {
      - if <def[flagObj].split[/].get[1]> == allow {
        - if <proc[dRegions_PlayerMatchRegionGroup].context[<def[flagObj].split[/].get[2]||all>|__global__|%world%|<player>]> {
          - run locally returnItems 'def:<player.inventory.list_contents.escaped>|<player.equipment.escaped>' delay:2t
          - determine NO_DROPS_NO_XP
          }
        }
        else {
        - if !<proc[dRegions_PlayerMatchRegionGroup].context[<def[flagObj].split[/].get[2]||all>|__global__|%world%|<player>]> {
          - run locally returnItems 'def:<player.inventory.list_contents.escaped>|<player.equipment.escaped>' delay:2t
          - determine NO_DROPS_NO_XP
          }
        }
      }

  returnItems:
    - inventory clear
    - run s@dRegions_Msg delay:1t 'def:<&9>You died, but your inventory is safe!'
    - inventory set 'd:<player.inventory>' 'o:<def[1].unescaped>'
    - define equipment '<def[2].unescaped>'
    - equip <player> 'boots:<def[equipment].get[1]||i@air>' 'legs:<def[equipment].get[2]||i@air>' 'chest:<def[equipment].get[3]||i@air>' 'head:<def[equipment].get[4]||i@air>'


dRegions_Flag_Spawn:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Spawn<&4>]"
  lore:
  - <&5>Region spawn point.
  event_hook: playerDies
  event_priority: 5
  flag_type: location
  flag_takeGroup: true
  flag_help: Set the location players will respawn at if they die in this region. Default is to have no effect so normal respawn mechanics will apply. Takes the -g group switch. Specify the value as `here` to use your current location, or specify a valid location in the `x,y,z,world` format.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - if !<player.has_permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_RegionOverlaps].context[<def[flagValue]>/<def[flagValue]>|%world%|<player>]> {
        - run s@dRegions_Msg delay:1t 'def:<&c>You can not use that location!'
        - queue clear
        }
      }

  event:
    - ^foreach <def[2].unescaped> {
      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%1%|%value%|spawn]>'
      - if ( %flagObj% != null ) && <proc[dRegions_PlayerMatchRegionGroup].context[<def[flagObj].split[/].get[2]||all>|%value%|%1%|<player>]> {
#        - adjust <player> 'location:<def[flagObj].split[/].get[1].as_location>'
        - flag <player> 'dRegions_Respawn:<def[flagObj].split[/].get[1].as_location>'
        - foreach stop
        }
      }

  event-global:
    - ^define flagObj '<proc[dRegions_GetInheritedFlag].context[%1%|__global__|spawn]>'
    - ^if ( %flagObj% != null ) && <proc[dRegions_PlayerMatchRegionGroup].context[<def[flagObj].split[/].get[2]||all>|__global__|%1%|<player>]> {
#      - adjust <player> 'location:<def[flagObj].split[/].get[1].as_location>'
      - flag <player> 'dRegions_Respawn:<def[flagObj].split[/].get[1].as_location>'
      }


dRegions_Flag_Player-Pickup:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Player-Pickup<&4>]"
  lore:
  - <&5>Who can pickup items
  event_hook: player-pickup
  event_priority: 10
  flag_type: state
  flag_takeGroup: true
  flag_defaultValue: none
  flag_globalDefault: none
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event-cleanup:
    - run locally msg delay:1t

  msg:
    - ^if <player.has_flag[dRegions_Message_Cooldown].not> {
      - flag player dRegions_Message_Cooldown duration:3s
      - run s@dRegions_Msg delay:1t 'def:<&c><&o>You can not pick up items here.'
      }

  event:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - foreach %orderedRegions% {
        - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|player-pickup]>'
        - define region '%value%'
        - if %flagObj% != null {
          - define player <player>
          - inject s@dRegions_Flags_Processors p:state-withGroup
          - foreach stop
          }
        }
      }

  event-global:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|player-pickup]>'
      - if %flagObj% != null {
        - define player <player>
        - inject s@dRegions_Flags_Processors p:state-withGroup-global
        }
      }


dRegions_Flag_Entity-Break-Painting:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Entity-Break-Painting<&4>]"
  lore:
  - <&5>Can Entities break paintings
  event_hook: entity-break-painting
  event_priority: 10
  flag_type: boolean
  flag_takeGroup: false
  flag_defaultValue: true
  flag_globalDefault: true
  flag_help: Boolean flag controlling whether mobs will be able to destroy paintings in this region. Set to true or false. Defaults to true.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
#    - define flag 'entity-break-painting'
#    - inject s@dRegions_Flags_Processors p:boolean
    - foreach %orderedRegions% {
      - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|entity-break-painting]>'
      - if %flagVal% != null {
        - if !%flagVal% {
          - determine cancelled
          }
        - foreach stop
        }
      }

  event-global:
#    - define flag 'entity-break-painting'
#    - inject s@dRegions_Flags_Processors p:boolean-Global
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|entity-break-painting]>'
    - if %flagVal% != null {
      - if !%flagVal% {
        - determine cancelled
        }
      }


dRegions_Flag_Entity-Break-ItemFrame:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Entity-Break-ItemFrame<&4>]"
  lore:
  - <&5>Can Entities break item frames
  event_hook: entity-break-itemframe
  event_priority: 10
  flag_type: boolean
  flag_takeGroup: false
  flag_defaultValue: true
  flag_globalDefault: true
  flag_help: Boolean flag controlling whether mobs will be able to destroy item frames in this region. Set to true or false. Defaults to true.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
#    - define flag 'entity-break-itemframe'
#    - inject s@dRegions_Flags_Processors p:boolean
    - foreach %orderedRegions% {
      - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|entity-break-itemframe]>'
      - if %flagVal% != null {
        - if !%flagVal% {
          - determine cancelled
          }
        - foreach stop
        }
      }

  event-global:
#    - define flag 'entity-break-itemframe'
#    - inject s@dRegions_Flags_Processors p:boolean-Global
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|entity-break-itemframe]>'
    - if %flagVal% != null {
      - if !%flagVal% {
        - determine cancelled
        }
      }


dRegions_Flag_PVP:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>PVP<&4>]"
  lore:
  - <&5>Can players damage each other
  event_hook: player_damage_player
  event_priority: 10
  flag_type: boolean
  flag_takeGroup: false
  flag_defaultValue: true
  flag_globalDefault: true
  flag_help: Boolean flag controlling whether players can attack eachother in this region. Set to true or false. Defaults to true.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|pvp]>'
      - if %flagVal% != null {
        - if !%flagVal% {
          - run locally flags delay:1t def:<def[defender].uuid||null>
          - remove <c.projectile||li@>
          - run locally msg delay:1t
          - determine cancelled
          }
          - foreach stop
        }
      }

  event-global:
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|pvp]>'
    - if %flagVal% != null {
      - if !%flagVal% {
        - run locally flags delay:1t def:<def[defender].uuid||null>
        - remove <c.projectile||li@>
        - run locally msg delay:1t
        - determine cancelled
        }
      }

  event-cleanup:
    - run locally flags delay:1t def:<def[defender].uuid||null>
    - remove <c.projectile||li@>
    - run locally msg delay:1t

  msg:
    - ^if <player.has_flag[dRegions_Message_Cooldown].not> {
      - flag player dRegions_Message_Cooldown duration:3s
      - run s@dRegions_Msg delay:1t 'def:<&c><&o>You are in a no PVP zone.'
      }

  flags:
    - ^if %1% == null {
      - queue clear
      }
    - ^flag server dRegions_NoTarget:->:%1%
    - ^wait 3s
    - ^flag server dRegions_NoTarget:<-:%1%


dRegions_Flag_Potion-Throw:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Potion-Throw<&4>]"
  lore:
  - <&5>Can potions be thrown in this region
  event_hook: throwPotion
  event_priority: 10
  flag_type: boolean
  flag_takeGroup: false
  flag_defaultValue: true
  flag_globalDefault: true
  flag_help: Boolean flag controlling whether potions can be thrown and broken in this region. Set to true or false. Defaults to true.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event-cleanup:
    - if <player.is[!=].to[null]||false> {
      - run locally msg delay:1t
      }

  msg:
    - ^if <player.has_flag[dRegions_Message_Cooldown].not||false> {
      - flag player dRegions_Message_Cooldown duration:3s
      - run s@dRegions_Msg delay:1t 'def:<&c><&o>You can not throw potions here.'
      }

  event:
    - foreach %orderedRegions% {
      - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|potion-throw]>'
      - if %flagVal% != null {
        - if !%flagVal% {
          - if <player.is[!=].to[null]||false> {
            - run locally msg delay:1t
            }
          - determine cancelled
          }
        - foreach stop
        }
      }

  event-global:
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|potion-throw]>'
    - if %flagVal% != null {
      - if !%flagVal% {
        - if <player.is[!=].to[null]||false> {
          - run locally msg delay:1t
          }
        - determine cancelled
        }
      }


dRegions_Flag_Potion-Drink:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Potion-Drink<&4>]"
  lore:
  - <&5>Who can drink potions
  event_hook: drinkPotion
  event_priority: 10
  flag_type: state
  flag_takeGroup: true
  flag_defaultValue: none
  flag_globalDefault: none
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event-cleanup:
    - run locally msg delay:1t

  msg:
    - ^if <player.has_flag[dRegions_Message_Cooldown].not> {
      - flag player dRegions_Message_Cooldown duration:3s
      - run s@dRegions_Msg delay:1t 'def:<&c><&o>You can not drink potions here.'
      }

  event:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - foreach %orderedRegions% {
        - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|potion-drink]>'
        - define region '%value%'
        - if %flagObj% != null {
          - define player <player>
          - inject s@dRegions_Flags_Processors p:state-withGroup
          - foreach stop
          }
        }
      }

  event-global:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|potion-drink]>'
      - if %flagObj% != null {
        - define player <player>
        - inject s@dRegions_Flags_Processors p:state-withGroup-global
        }
      }


dRegions_Flag_Enderpearl:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Enderpearl<&4>]"
  lore:
  - <&5>Who can use enderpearls
  event_hook: enderPearl
  event_priority: 10
  flag_type: state
  flag_takeGroup: true
  flag_defaultValue: none
  flag_globalDefault: none
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event-cleanup:
    - run locally msg delay:1t

  msg:
    - ^if <player.has_flag[dRegions_Message_Cooldown].not> {
      - flag player dRegions_Message_Cooldown duration:3s
      - run s@dRegions_Msg delay:1t 'def:<&c><&o>You can not use enderpearls here.'
      }

  event:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - foreach %orderedRegions% {
        - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|enderpearl]>'
        - define region '%value%'
        - if %flagObj% != null {
          - define player <player>
          - inject s@dRegions_Flags_Processors p:state-withGroup
          - foreach stop
          }
        }
      }

  event-global:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|enderpearl]>'
      - if %flagObj% != null {
        - define player <player>
        - inject s@dRegions_Flags_Processors p:state-withGroup-global
        }
      }


dRegions_Flag_Block-Place:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Block-Place<&4>]"
  lore:
  - <&5>Can players place blocks.
  event_hook: blockPlace
  event_priority: 5
  flag_type: state
  flag_takeGroup: true
  flag_defaultValue: none
  flag_globalDefault: none
  region_highestOnly: true
  flag_help: State flag controlling whether players will be able to place blocks in this region. Defaults to allow all. Use block-placelist flag to specify block types. Takes the -g group switch.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|block-place]>'
      - define region '%value%'
      - if %flagObj% != null {
        - foreach stop
        }
      }
    - if %flagObj% != null {
      - define player <player>
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|block-placelist].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget-withGroup
      }

  event-global:
    - define orderedRegions 'li@global'
    - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|block-place]>'
    - if %flagObj% != null {
      - define player <player>
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|block-placelist].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget-withGroup
      }

  event-cleanup:
    - run locally msg delay:1t 'def:%target%'

  msg:
    - ^if <player.has_flag[dRegions_Message_Cooldown].not> {
      - flag player dRegions_Message_Cooldown duration:3s
      - run s@dRegions_Msg delay:1t 'def:<&c><&o>You can not place %1% in this region!'
      }


dRegions_Flag_Block-PlaceList:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Block-PlaceList<&4>]"
  lore:
  - <&5>List of blocks used by block-place flag
  command_entryType: block
  command_verifyEntry: <def[value].as_material.is_block.not||true>
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with block-place flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of blocks.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - inject s@dRegions_Flags_CommandProcessors p:command_verifiedList


dRegions_Flag_Block-Break:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Block-Break<&4>]"
  lore:
  - <&5>Can players break blocks.
  event_hook: blockBreak
  event_priority: 5
  flag_type: state
  flag_takeGroup: true
  flag_defaultValue: none
  flag_globalDefault: none
  region_highestOnly: true
  flag_help: State flag controlling whether players will be able to break blocks in this region. Defaults to allow all. Use block-breaklist flag to specify block types. Takes the -g group switch.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|block-break]>'
      - define region '%value%'
      - if %flagObj% != null {
        - foreach stop
        }
      }
    - if %flagObj% != null {
      - define player <player>
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|block-breaklist].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget-withGroup
      }

  event-global:
    - define orderedRegions 'li@global'
    - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|block-break]>'
    - if %flagObj% != null {
      - define player <player>
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|block-breaklist].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget-withGroup
      }

  event-cleanup:
    - run locally msg delay:1t 'def:%target%'

  msg:
    - ^if <player.has_flag[dRegions_Message_Cooldown].not> {
      - flag player dRegions_Message_Cooldown duration:3s
      - run s@dRegions_Msg delay:1t 'def:<&c><&o>You can not break %1% in this region!'
      }


dRegions_Flag_Block-BreakList:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Block-BreakList<&4>]"
  lore:
  - <&5>List of blocks used by block-break flag
  command_entryType: block
  command_verifyEntry: <def[value].as_material.is_block.not||true>
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with block-break flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of blocks.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - inject s@dRegions_Flags_CommandProcessors p:command_verifiedList


dRegions_Flag_Chest-Access:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Chest-Access<&4>]"
  lore:
  - <&5>Can players open containers.
  event_hook: openContainer
  event_priority: 10
  flag_type: state
  flag_name: chest-access
  flag_targetList: chest-access-blocks
  flag_takeGroup: true
  flag_defaultValue: deny/nonmembers
  flag_globalDefault: none
  region_highestOnly: true
  flag_help: State flag controlling whether players will be able to open containers in this region. Defaults to deny nonmembers. Use chest-access-blocks flag to specify container blocks types. Takes the -g group switch.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|chest-access]>'
      - define region '%value%'
      - if %flagObj% != null {
        - foreach stop
        }
      }
    - if %flagObj% != null {
      - define player <player>
      - define target <c.location.material.bukkit_enum>
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|chest-access-blocks].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget-withGroup
      }

  event-global:
    - define orderedRegions 'li@global'
    - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|chest-access]>'
    - if %flagObj% != null {
      - define player <player>
      - define target <c.location.material.bukkit_enum>
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|chest-access-blocks].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget-withGroup
      }

  event-cleanup:
    - run locally msg delay:1t 'def:<c.location.material.name.replace[_].with[ ]>'

  msg:
    - ^if <player.has_flag[dRegions_Message_Cooldown].not> {
      - flag player dRegions_Message_Cooldown duration:3s
      - run s@dRegions_Msg delay:1t 'def:<&c><&o>You can not open %1%s in this region!'
      }


dRegions_Flag_Chest-Access-Blocks:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Chest-Access-Blocks<&4>]"
  lore:
  - <&5>List of blocks used by chest-access flag
  command_entryType: container
  command_verifyEntry: <el@val[chest|ender_chest|locked_chest|trapped_chest|dispenser|hopper|dropper].as_list.contains[<def[value]>].not>
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with chest-access flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of blocks. Valid container blocks<&co> chest, ender_chest, locked_chest, trapped_chest, dispenser, hopper, and dropper.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - inject s@dRegions_Flags_CommandProcessors p:command_verifiedList


dRegions_Flag_Door-Access:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Door-Access<&4>]"
  lore:
  - <&5>Can players open doors.
  event_hook: openDoor
  event_priority: 10
  flag_type: state
  flag_name: Door-Access
  flag_targetList: Door-Access-Doors
  flag_takeGroup: true
  flag_defaultValue: none
  flag_globalDefault: none
  flag_help: State flag controlling whether players will be able to open doors in this region. Defaults to allow all. Use door-access-doors flag to specify door blocks types. Takes the -g group switch.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|door-access]>'
      - define region '%value%'
      - if %flagObj% != null {
        - foreach stop
        }
      }
    - if %flagObj% != null {
      - define player <player>
      - define target <c.location.material.bukkit_enum>
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|door-access-doors].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget-withGroup
      }

  event-global:
    - define orderedRegions 'li@global'
    - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|door-access]>'
    - if %flagObj% != null {
      - define player <player>
      - define target <c.location.material.bukkit_enum>
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|door-access-doors].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget-withGroup
      }

  event-cleanup:
    - run locally msg delay:1t 'def:<c.location.material.name.replace[_].with[ ]>'

  msg:
    - ^if <player.has_flag[dRegions_Message_Cooldown].not> {
      - flag player dRegions_Message_Cooldown duration:3s
      - run s@dRegions_Msg delay:1t 'def:<&c><&o>You can not open %1%s in this region!'
      }


dRegions_Flag_Door-Access-Doors:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Door-Access-Doors<&4>]"
  lore:
  - <&5>List of doors used by doors-access flag
  command_entryType: door
  command_verifyEntry: <el@val[trap_door|iron_trapdoor|wooden_door|iron_door_block|spruce_door|birch_door|jungle_door|dark_oak_door|acacia_door|fence_gate|spruce_fence_gate|birch_fence_gate|jungle_fence_gate|dark_oak_fence_gate|acacia_fence_gate].as_list.contains[<def[value]>].not>
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with door-access flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of blocks. Valid door blocks<&co> trap_door, iron_trapdoor, wooden_door, iron_door_block, spruce_door, birch_door, jungle_door, dark_oak_door, acacia_door, fence_gate, spruce_fence_gate, birch_fence_gate, jungle_fence_gate, dark_oak_fence_gate, and acacia_fence_gate.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - inject s@dRegions_Flags_CommandProcessors p:command_verifiedList


dRegions_Flag_Use-Switches:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Use-Switches<&4>]"
  lore:
  - <&5>Can players interact with switches.
  event_hook: useSwitch
  event_priority: 10
  flag_type: state
  flag_name: Use-Switches
  flag_targetList: Use-Switches-List
  flag_takeGroup: true
  flag_defaultValue: deny/nonmembers
  flag_globalDefault: none
  region_highestOnly: true
  flag_help: State flag controlling whether players will be able to use switches in this region. Defaults to deny nonmembers. Use use-switches-list flag to specify switch block types. Takes the -g group switch.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|use-switches]>'
      - define region '%value%'
      - if %flagObj% != null {
        - foreach stop
        }
      }
    - if %flagObj% != null {
      - define player <player>
      - define target <c.location.material.bukkit_enum>
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|use-switches-list].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget-withGroup
      }

  event-global:
    - define orderedRegions 'li@global'
    - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|use-switches]>'
    - if %flagObj% != null {
      - define player <player>
      - define target <c.location.material.bukkit_enum>
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|use-switches-list].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget-withGroup
      }

  event-cleanup:
    - run locally msg delay:1t 'def:<c.location.material.name.replace[_].with[ ]>'

  msg:
    - ^flag <player> dRegions_UseSwitch
    - ^if <player.has_flag[dRegions_Message_Cooldown].not> {
      - flag player dRegions_Message_Cooldown duration:3s
      - run s@dRegions_Msg delay:1t 'def:<&c><&o>You can not use %1%s in this region!'
      }
    - ^wait 2s
    - ^flag <player> dRegions_UseSwitch:!


dRegions_Flag_Use-Switches-List:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Use-Switches-List<&4>]"
  lore:
  - <&5>List of switches used by use-switches flag
  command_entryType: switch
  command_verifyEntry: <el@val[lever|wood_button|stone_button|wood_plate|stone_plate|iron_plate|gold_plate].as_list.contains[<def[value]>].not>
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with use-switches flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of blocks. Valid switch blocks<&co> lever, wood_button, stone_button, wood_plate, stone_plate, iron_plate, and gold_plate.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - inject s@dRegions_Flags_CommandProcessors p:command_verifiedList


dRegions_Flag_Use-Utilities:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Use-Utilities<&4>]"
  lore:
  - <&5>Can players use utility blocks.
  event_hook: useUtility
  event_priority: 10
  flag_type: state
  flag_name: Use-Utilities
  flag_targetList: Use-Utilities-Blocks
  flag_takeGroup: true
  flag_defaultValue: deny/nonmembers
  flag_globalDefault: none
  region_highestOnly: true
  flag_help: State flag controlling whether players will be able to use utility blocks in this region. Defaults to deny nonmembers. Use use-utilities-blocks flag to specify utility blocks. Takes the -g group switch.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|use-utilities]>'
      - define region '%value%'
      - if %flagObj% != null {
        - foreach stop
        }
      }
    - if %flagObj% != null {
      - define player <player>
      - define target <c.location.material.bukkit_enum>
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|use-utilities-blocks].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget-withGroup
      }

  event-global:
    - define orderedRegions 'li@global'
    - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|use-utilities]>'
    - if %flagObj% != null {
      - define player <player>
      - define target <c.location.material.bukkit_enum>
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|use-utilities-blocks].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget-withGroup
      }

  event-cleanup:
    - run locally msg delay:1t 'def:<c.location.material.name.replace[_].with[ ]>'

  msg:
    - ^if <player.has_flag[dRegions_Message_Cooldown].not> {
      - flag player dRegions_Message_Cooldown duration:3s
      - run s@dRegions_Msg delay:1t 'def:<&c><&o>You can not use %1%s in this region!'
      }


dRegions_Flag_Use-Utilities-Blocks:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Use-Utilities-Blocks<&4>]"
  lore:
  - <&5>List of blocks used by use-utilities flag
  command_entryType: utility
  command_verifyEntry: <el@val[workbench|furnace|burning_furnace|anvil|cauldron|brewing_stand|enchantment_table|note_block|jukebox|beacon].as_list.contains[<def[value]>].not>
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with use-utilities flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of blocks. Valid utility blocks<&co> workbench, furnace, burning_furnace, anvil, brewing_stand, cauldron, enchantment_table, note_block, jukebox, and beacon.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - inject s@dRegions_Flags_CommandProcessors p:command_verifiedList


dRegions_Flag_Player-Damage:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Player-Damage<&4>]"
  lore:
  - <&5>Can players take damage.
  event_hook: playerDamaged
  event_priority: 10
  flag_type: state
  flag_takeGroup: true
  flag_defaultValue: none
  flag_globalDefault: none
  region_highestOnly: false
  flag_help: State flag controlling whether players will take damage in this region. Defaults to allow all. Use player-damage-types flag to specify damage types. Takes the -g group switch.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - foreach %orderedRegions% {
      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|player-damage]>'
      - define region '%value%'
      - if %flagObj% != null {
        - define player <player>
        - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|player-damage-types].replace[, ].with[|].as_list>'
        - foreach stop
        }
      }
    - if %flagObj% != null {
      - inject s@dRegions_Flags_Processors p:state-withTarget-withGroup
      }

  event-global:
    - define orderedRegions 'li@global'
    - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|player-damage]>'
    - if %flagObj% != null {
      - define player '<player>'
      - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|player-damage-types].replace[, ].with[|].as_list>'
      - inject s@dRegions_Flags_Processors p:state-withTarget-withGroup
      }
#    - yaml set 'cache.state-withTarget-withGroup.__global__.player-damage.%puuid%.%target%:true' 'id:dRegions_%world%_cache'

  event-cleanup:
#    - yaml set 'cache.state-withTarget-withGroup.%region%.player-damage.%puuid%.%target%:false' 'id:dRegions_%world%_cache'
    - flag player dRegions_cancelDamage_%target% d:2s
    - adjust <player> 'fire_time:0'


dRegions_Flag_Player-Damage-Types:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Player-Damage-Types<&4>]"
  lore:
  - <&5>List of damage types used by player-damage flag
  command_entryType: cause
  command_verifyEntry: <el@val[BLOCK_EXPLOSION|CONTACT|CUSTOM|DROWNING|ENTITY_ATTACK|ENTITY_EXPLOSION|FALL|FALLING_BLOCK|FIRE|FIRE_TICK|LAVA|LIGHTNING|MAGIC|MELTING|POISON|PROJECTILE|STARVATION|SUFFOCATION|SUICIDE|THORNS|VOID|WITHER].as_list.contains[<def[value]>].not>
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with player-damage flag. To add to the list, use the -a switch. To remove from list use the -r switch. Provide a space separated list of damage types. Valid damage types<&co> block_explosion, contact, custom, drowning, entity_attack, entity_explosion, fall, falling_block, fire, fire_tick, lava, lightning, magic, melting, poison, projectile, starvation, suffocation, suicide, thorns, void, and wither.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - inject s@dRegions_Flags_CommandProcessors p:command_verifiedList


dRegions_Flag_Commands:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Commands<&4>]"
  lore:
  - <&5>Can players use commands.
  event_hook: playerCommand
  event_priority: 10
  flag_type: state
  flag_takeGroup: true
  flag_defaultValue: none
  flag_globalDefault: none
  region_highestOnly: false
  flag_help: State flag controlling whether players can use commands in this region. Defaults to allow all. Use commands-list flag to specify commands. Takes the -g group switch.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - define player <player>
      - define flag 'commands'
      - define flag-targetList 'commands-list'
      - define delimiter ' ; '
      - inject s@dRegions_Flags_Processors p:state-withTargetString-withGroup
      }

  event-global:
    - if !<player.has_permission[dRegions.admin]||<player.is_op||false>> {
      - define player <player>
      - define flag 'commands'
      - define flag-targetList 'commands-list'
      - define delimiter ' ; '
      - inject s@dRegions_Flags_Processors p:state-withTargetString-withGroup-Global
      }

  event-cleanup:
    - run locally msg delay:1t 'def:<def[target].split[ ].parse[replace[regex:^].with[<&e>]].as_string>'

  msg:
    - ^if <player.has_flag[dRegions_Message_Cooldown].not> {
      - flag player dRegions_Message_Cooldown duration:3s
      - define lines '<proc[dRegions_LineWrap].context[You can not use the %1% <&c>command in this region!|45]>'
      - foreach %lines% {
        - run s@dRegions_Msg delay:1t 'def:<&c>%value%'
        }
      }


dRegions_Flag_Commands-List:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Commands-List<&4>]"
  lore:
  - <&5>List of commands used by commands flag
  command_entryType: cause
  flag_type: list
  flag_takeGroup: false
  flag_help: List flag used with commands flag. To add to the list, use the -a switch. To remove from list use the -r switch. Add/remove one command at a time!
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - inject s@dRegions_Flags_CommandProcessors p:command_stringList


dRegions_Flag_Heal-Amount:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Heal-Amount<&4>]"
  lore:
  - <&5>The amount to heal or harm.
  event_hook: regionEnter
  event_priority: 10
  flag_type: number
  flag_help: Set the amount to heal or hurt a player while inside a region. Defaults to no effect. Positive number will heal players, negative numbers will damage players.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - define healAmount '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|heal-amount]>'
    - if %healAmount% != null {
      - define healDelay '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|heal-delay]>'
      - if %healDelay% == null {
        - define healDelay '5'
        }
      - define healMax '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|heal-max]>'
      - if %healMax% == null {
        - define healMax '20'
        }
      - define healMax '<tern[<def[healMax].is[MORE].than[<player.health.max>]>]:<player.health.max>||%healMax%>'
      - define healMin '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|heal-min]>'
      - if %healMin% == null {
        - define healMin '0'
        }
      - if <queue.exists[dRegions_Heal_<player.name>]> {
        - queue q@dRegions_Heal_<player.name> clear
        }
      - run locally healTask delay:1t 'def:%world%|%region%|%healAmount%|%healDelay%|%healMax%|%healMin%' id:dRegions_Heal_<player.name>
      }

  event-global:
    - define healAmount '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|heal-amount]>'
    - if %healAmount% != null {
      - define healDelay '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|heal-delay]>'
      - if %healDelay% == null {
        - define healDelay '5'
        }
      - define healMax '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|heal-max]>'
      - if %healMax% == null {
        - define healMax '20'
        }
      - define healMax '<tern[<def[healMax].is[MORE].than[<player.health.max>]>]:<player.health.max>||%healMax%>'
      - define healMin '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|heal-min]>'
      - if %healMin% == null {
        - define healMin '0'
        }
      - if <queue.exists[dRegions_Heal_<player.name>]> {
        - queue q@dRegions_Heal_<player.name> clear
        }
      - run locally healTask delay:1t 'def:%world%|__global__|%healAmount%|%healDelay%|%healMax%|%healMin%' id:dRegions_Heal_<player.name>
      }

  healTask:
    - while <player.is_online> {
      - define world '<player.world.name>'
      - if %world% != %1% {
        - while stop
        }
      - define regionPri 'li@'
      - foreach <player.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
        - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
        }
      - if <def[regionPri].alphanumeric.reverse.parse[split[/].get[2]].get[1]> != %2% {
        - while stop
        }
      - if <player.gamemode.id> == 1 {
        - wait 1s
        - while next
        }
      - if %4% OR_LESS 0 {
        - if %3% MORE 0 {
          - if <player.health> LESS %5% {
            - adjust <player> 'health:%5%'
            }
          }
          else {
          - if <player.health> MORE %6% {
            - animate <player> animation:hurt
            - adjust <player> 'health:%6%'
            }
          }
        - wait 1s
        - while next
        }
      - if %3% MORE 0 {
        - if <player.health> LESS %5% {
          - define newHealth '<player.health.add[%3%]>'
          - adjust <player> 'health:<tern[<def[newHealth].is[MORE].than[%5%]>]:%5%||%newHealth%>'
          }
        }
        else {
        - if <player.health> MORE %6% {
          - animate <player> animation:hurt
          - define newHealth '<player.health.add[%3%]>'
          - adjust <player> 'health:<tern[<def[newHealth].is[LESS].than[%6%]>]:%6%||%newHealth%>'
          }
        }
      - wait <def[4].as_duration>
      }


dRegions_Flag_Heal-Delay:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Heal-Delay<&4>]"
  lore:
  - <&5>The duration between heal intervals
  flag_type: number
  flag_takeGroup: false
  flag_help: Set the time in seconds between heal intervals. Defaults to 5 seconds.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - if <def[flagValue].is[LESS].than[0]> {
      - run s@dRegions_Msg delay:1t 'def:<&c>Can not specify negative time!'
      - queue clear
      }


dRegions_Flag_Heal-Max:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Heal-Max<&4>]"
  lore:
  - <&5>Max health for heal flag.
  flag_type: number
  flag_takeGroup: false
  flag_help: Set the max health that the heal flag will heal a player to. Defaults to 20.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - if !<def[flagValue].is[MORE].than[0]> {
      - run s@dRegions_Msg delay:1t 'def:<&c>Must be a value greater than 0!'
      - queue clear
      }


dRegions_Flag_Heal-Min:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Heal-Min<&4>]"
  lore:
  - <&5>Minimum health for heal flag
  flag_type: number
  flag_takeGroup: false
  flag_help: Set the min health that the heal flag will heal a player to. Defaults to 0.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - if <def[flagValue].is[LESS].than[0]> {
      - run s@dRegions_Msg delay:1t 'def:<&c>Can not set to a negative number!'
      - queue clear
      }


dRegions_Flag_Feed-Amount:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Feed-Amount<&4>]"
  lore:
  - <&5>The amount to feed or starve.
  event_hook: regionEnter
  event_priority: 10
  flag_type: number
  flag_help: Set the amount to feed or starve a player while inside a region. Defaults to no effect. Positive numbers will feed players, negative numbers will starve players.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  event:
    - define feedAmount '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|feed-amount]>'
    - if %feedAmount% != null {
      - define feedDelay '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|feed-delay]>'
      - if %feedDelay% == null {
        - define feedDelay '5'
        }
      - define feedMax '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|feed-max]>'
      - if %feedMax% == null {
        - define feedMax '20'
        }
      - define feedMin '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|feed-min]>'
      - if %feedMin% == null {
        - define feedMin '0'
        }
      - if <queue.exists[dRegions_Feed_<player.name>]> {
        - queue q@dRegions_Feed_<player.name> clear
        }
      - run locally feedTask delay:1t 'def:%world%|%region%|%feedAmount%|%feedDelay%|%feedMax%|%feedMin%' id:dRegions_Feed_<player.name>
      }

  event-global:
    - define feedAmount '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|feed-amount]>'
    - if %feedAmount% != null {
      - define feedDelay '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|feed-delay]>'
      - if %feedDelay% == null {
        - define feedDelay '5'
        }
      - define feedMax '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|feed-max]>'
      - if %feedMax% == null {
        - define feedMax '20'
        }
      - define feedMin '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|feed-min]>'
      - if %feedMin% == null {
        - define feedMin '0'
        }
      - if <queue.exists[dRegions_Feed_<player.name>]> {
        - queue q@dRegions_Feed_<player.name> clear
        }
      - run locally feedTask delay:1t 'def:%world%|__global__|%feedAmount%|%feedDelay%|%feedMax%|%feedMin%' id:dRegions_Feed_<player.name>
      }

  feedTask:
    - while <player.is_online> {
      - define world '<player.world.name>'
      - if %world% != %1% {
        - while stop
        }
      - define regionPri 'li@'
      - foreach <player.location.cuboids.parse[notable_name].filter[starts_with[dRegions_]].parse[after[dregions_%world%_]].include[__global__]> {
        - define regionPri '%regionPri%<yaml[dRegions_%world%_regions].read[regions.%value%.priority]||0>/%value%|'
        }
      - define region '<def[regionPri].alphanumeric.reverse.parse[split[/].get[2]].get[1]>'
      - if <def[regionPri].alphanumeric.reverse.parse[split[/].get[2]].get[1]> != %2% {
        - while stop
        }

      - if <player.gamemode.id> == 1 {
        - wait 1s
        - while next
        }
      - if %4% OR_LESS 0 {
        - if %3% MORE 0 {
          - if <player.food_level> LESS %5% {
            - adjust <player> 'food_level:%5%'
            - adjust <player> 'saturation:<player.food_level>'
            }
          }
          else {
          - if <player.food_level> MORE %6% {
            - animate <player> animation:hurt
            - adjust <player> 'food_level:%6%'
            - adjust <player> 'saturation:<player.food_level>'
            }
          }
        - wait 1s
        - while next
        }
      - if %3% MORE 0 {
        - if <player.food_level> LESS %5% {
          - define newFood '<player.food_level.add[%2%]>'
          - adjust <player> 'food_level:<tern[<def[newFood].is[MORE].than[%5%]>]:%5%||%newFood%>'
          - adjust <player> 'saturation:<player.food_level>'
          }
        }
        else {
        - if <player.food_level> MORE %6% {
          - define newFood '<player.food_level.add[%3%]>'
          - adjust <player> 'food_level:<tern[<def[newFood].is[LESS].than[%6%]>]:%6%||%newFood%>'
          - adjust <player> 'saturation:<player.food_level>'
          - animate <player> animation:hurt
          }
        }
      - wait <def[4].as_duration>
      }


dRegions_Flag_Feed-Delay:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Feed-Delay<&4>]"
  lore:
  - <&5>The duration between feed intervals
  flag_type: number
  flag_takeGroup: false
  flag_help: Set the time in seconds between feed intervals. Defaults to 5 seconds.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - if <def[flagValue].is[LESS].than[0]> {
      - run s@dRegions_Msg delay:1t 'def:<&c>Can not specify negative time!'
      - queue clear
      }


dRegions_Flag_Feed-Max:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Feed-Max<&4>]"
  lore:
  - <&5>Max health for feed flag.
  flag_type: number
  flag_takeGroup: false
  flag_help: Set the max food level that the feed-amount flag will bring a player to. Defaults to 20.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - if !<def[flagValue].is[MORE].than[0]> {
      - run s@dRegions_Msg delay:1t 'def:<&c>Must be a value greater than 0!'
      - queue clear
      }


dRegions_Flag_Feed-Min:
  type: item
  speed: 0
  debug: false
  material: i@paper
  display name: "<&4>[<&6>Feed-Min<&4>]"
  lore:
  - <&5>Minimum food level for feed-amount flag
  flag_type: number
  flag_takeGroup: false
  flag_help: Set the min food level that the feed-amount flag will bring a player to. Defaults to 0.
  script:
    - narrate "A handy container for region flags."
    - narrate "We<&sq>ll have subscripts for various tasks."

  button_click:
    - narrate "This will be useful when it comes time to make the GUI for region management."

  command_handler:
    - if <def[flagValue].is[LESS].than[0]> {
      - run s@dRegions_Msg delay:1t 'def:<&c>Can not set to a negative number!'
      - queue clear
      }






################################################################################

dRegions_Flags_Processors:
  type: task
  speed: 0
  debug: false

#---------------------------------------
# Region flag pre-processors
#

  state-withGroup:
  # Requires each flag to build the flag object.
  # Allows for iterating over %orderedRegions% from within the flag
  # Membership is checked against the highest priority region while flag value
  # can be set in any region in %orderedRegions%
    - if <def[flagObj].split[/].get[1]> == allow {
      - if !<proc[dRegions_PlayerMatchRegionGroup].context[<def[flagObj].split[/].get[2]||all>|<def[orderedRegions].get[1]>|%world%|%player%]> {
        - inject %FlagScript% p:event-cleanup
        - determine cancelled
        }
      }
      else {
      - if <proc[dRegions_PlayerMatchRegionGroup].context[<def[flagObj].split[/].get[2]||all>|<def[orderedRegions].get[1]>|%world%|%player%]> {
        - inject %FlagScript% p:event-cleanup
        - determine cancelled
        }
      }


  state-withTarget:
    - if %flagVal% == allow {
      - if %targetList% != li@null && %targetList% != li@all && %targetList% !contains %target% {
        - inject %FlagScript% p:event-cleanup
        - determine cancelled
        }
      }
      else {
      - if %targetList% == li@null || %targetList% == li@all || %targetList% contains %target% {
        - inject %FlagScript% p:event-cleanup
        - determine cancelled
        }
      }


  state-withTarget-withGroup:
    - if <def[flagObj].split[/].get[1]> == allow {
      - if !<proc[dRegions_PlayerMatchRegionGroup].context[<def[flagObj].split[/].get[2]||all>|<def[orderedRegions].get[1]>|%world%|%player%]> {
        - inject %FlagScript% p:event-cleanup
        - determine cancelled
        }
      - if %targetList% != li@null && %targetList% != li@all && %targetList% !contains %target% {
        - inject %FlagScript% p:event-cleanup
        - determine cancelled
        }
      }
      else {
      - if <proc[dRegions_PlayerMatchRegionGroup].context[<def[flagObj].split[/].get[2]||all>|<def[orderedRegions].get[1]>|%world%|%player%]> {
        - if %targetList% == li@null || %targetList% == li@all || %targetList% contains %target% {
          - inject %FlagScript% p:event-cleanup
          - determine cancelled
          }
        }
      }


  state-withTargetString-withGroup:
    - if <def[FlagScript].yaml_key[region_highestOnly]||false> {
      - define region '<def[orderedRegions].get[1]>'
      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|%flag%]>'
      }
      else {
      - foreach %orderedRegions% {
        - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|%flag%]>'
        - define region '%value%'
        - if %flagObj% != null {
          - foreach stop
          }
        }
      }
    - if %flagObj% == null {
      - define flagObj '<def[FlagScript].yaml_key[flag_defaultValue]||none>'
      }
    - if %flagObj% != none {
      - if <def[flagObj].split[/].get[1]> == allow {
        - if !<proc[dRegions_PlayerMatchRegionGroup].context[<def[flagObj].split[/].get[2]||all>|<def[orderedRegions].get[1]>|%world%|%player%]> {
          - inject %FlagScript% p:event-cleanup
          - determine cancelled
          }
        - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|%flag-targetList%].replace[<def[delimiter]||, >].with[|].as_list>'
        - if ( %targetList% != li@null ) && ( %targetList% != li@all ) {
          - foreach %targetList% {
            - if <def[target].starts_with[%value%]> {
              - inject %FlagScript% p:event-cleanup
              - determine cancelled
              }
            }
          }
        }
        else {
        - if <proc[dRegions_PlayerMatchRegionGroup].context[<def[flagObj].split[/].get[2]||all>|<def[orderedRegions].get[1]>|%world%|%player%]> {
          - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|%flag-targetList%].replace[<def[delimiter]||, >].with[|].as_list>'
          - if ( %targetList% == li@null ) || ( %targetList% == li@all ) {
            - inject %FlagScript% p:event-cleanup
            - determine cancelled
            }
          - foreach %targetList% {
            - if <def[target].starts_with[%value%]> {
              - inject %FlagScript% p:event-cleanup
              - determine cancelled
              }
            }
          }
        }
      }



##############################
# Abstract methods
#
#  state-withTarget:
#    - if <def[FlagScript].yaml_key[region_highestOnly]||false> {
#      - define orderedRegions '<def[orderedRegions].get[1].as_list>'
#      }
#    - foreach %orderedRegions% {
#      - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|%flag%]>'
#      - if %flagVal% == null {
#        - foreach next
#        }
#      - define region '%value%'
#      - foreach stop
#      }
#    - inject locally state-process-WithTargetNoGroup_%flagVal%
#    - queue clear


#  state-withGroup:
#    - if <def[FlagScript].yaml_key[region_highestOnly]||false> {
#      - define orderedRegions '<def[orderedRegions].get[1].as_list>'
#      }
#    - foreach %orderedRegions% {
#      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|%flag%]>'
#      - if %flagObj% == null {
#        - foreach next
#        }
#      - define region '%value%'
#      - foreach stop
#      }
#    - inject locally state-process-WithGroup_<def[flagObj].split[/].get[1]>
#    - queue clear


#  state-withTarget-withGroup:
#    - if <def[FlagScript].yaml_key[region_highestOnly]||false> {
#      - define orderedRegions '<def[orderedRegions].get[1].as_list>'
#      }
#    - foreach %orderedRegions% {
#      - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|%value%|%flag%]>'
#      - if %flagObj% == null {
#        - foreach next
#        }
#      - define region '%value%'
#      - foreach stop
#      }
#    - inject locally state-process-WithTargetWithGroup_<def[flagObj].split[/].get[1]>
#    - queue clear


#---------------------------------------
# Global flag pre-processors
#
  boolean-Global:
    - define flagVal '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|%flag%]||null>'
    - if %flagVal% == null {
      - define flagVal '<def[FlagScript].yaml_key[flag_globalDefault]||true>'
      }
    - if !%flagVal% {
      - inject %FlagScript% p:event-cleanup
      - determine cancelled
      }

  state-withGroup-Global:
    - if <def[flagObj].split[/].get[1]> == allow {
      - if !<proc[dRegions_PlayerMatchRegionGroup].context[<def[flagObj].split[/].get[2]||all>|__global__|%world%|%player%]> {
        - inject %FlagScript% p:event-cleanup
        - determine cancelled
        }
      }
      else {
      - if <proc[dRegions_PlayerMatchRegionGroup].context[<def[flagObj].split[/].get[2]||all>|__global__|%world%|%player%]> {
        - inject %FlagScript% p:event-cleanup
        - determine cancelled
        }
      }


  state-withTargetString-withGroup-Global:
    - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|%flag%]>'
    - if %flagObj% == null {
      - define flagObj '<def[FlagScript].yaml_key[flag_defaultValue]||none>'
      }
    - if %flagObj% != none {
      - if <def[flagObj].split[/].get[1]> == allow {
        - if !<proc[dRegions_PlayerMatchRegionGroup].context[<def[flagObj].split[/].get[2]||all>|__global__|%world%|%player%]> {
          - inject %FlagScript% p:event-cleanup
          - determine cancelled
          }
        - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|%flag-targetList%].replace[<def[delimiter]||, >].with[|].as_list>'
        - if ( %targetList% != li@null ) && ( %targetList% != li@all ) {
          - foreach %targetList% {
            - if <def[target].starts_with[%value%]> {
              - inject %FlagScript% p:event-cleanup
              - determine cancelled
              }
            }
          }
        }
        else {
        - if <proc[dRegions_PlayerMatchRegionGroup].context[<def[flagObj].split[/].get[2]||all>|__global__|%world%|%player%]> {
          - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|%flag-targetList%].replace[<def[delimiter]||, >].with[|].as_list>'
          - if ( %targetList% == li@null ) || ( %targetList% == li@all ) {
            - inject %FlagScript% p:event-cleanup
            - determine cancelled
            }
          - foreach %targetList% {
            - if <def[target].starts_with[%value%]> {
              - inject %FlagScript% p:event-cleanup
              - determine cancelled
              }
            }
          }
        }
      }


##############################
# Abstract methods
#
#  state-withGroup-Global:
#    - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|%flag%]>'
#    - inject locally state-process-Global-WithGroup_<def[flagObj].split[/].get[1]>
#    - queue clear


#  state-withTarget-Global:
#    - inject locally state-process-Global-WithTargetNoGroup_<proc[dRegions_GetInheritedFlag].context[%world%|__global__|%flag%]>
#    - queue clear


#  state-withTarget-withGroup-Global:
#    - define flagObj '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|%flag%]>'
#    - inject locally state-process-Global-WithTargetWithGroup_<def[flagObj].split[/].get[1]>
#    - queue clear

#-------------------
# Global WithGroup Flag Processors
#
#  state-process-Global-WithGroup_null:
#    - define flagObj '<def[FlagScript].yaml_key[flag_globalDefault]||none>'
#    - inject locally state-process-Global-WithGroup_<def[flagObj].split[/].get[1]>

#  state-process-Global-WithGroup_none:
#    - foreach next
#    - queue clear

#  state-process-Global-WithGroup_allow:
#    - define group '<def[flagObj].split[/].get[2]||all>'
#    - inject locally state-process-Global-WithGroup_deny-<proc[dRegions_PlayerMatchRegionGroup].context[%group%|__global__|%world%|%player%].not>

#  state-process-Global-WithGroup_deny:
#    - define group '<def[flagObj].split[/].get[2]||all>'
#    - inject locally state-process-Global-WithGroup_deny-<proc[dRegions_PlayerMatchRegionGroup].context[%group%|__global__|%world%|%player%]>

#  state-process-Global-WithGroup_deny-true:
#    - inject %FlagScript% p:event-cleanup
#    - determine cancelled


#-------------------
# Global WithTargetWithGroup Flag Processors
#
#  state-process-Global-WithTargetWithGroup_null:
#    - define flagObj '<def[FlagScript].yaml_key[flag_globalDefault]||none>'
#    - inject locally state-process-Global-WithTargetWithGroup_<def[flagObj].split[/].get[1]>

#  state-process-Global-WithTargetWithGroup_none:
#    - foreach next
#    - queue clear

#  state-process-Global-WithTargetWithGroup_allow:
#    - define group '<def[flagObj].split[/].get[2]||all>'
#    - inject locally state-process-Global-WithTargetWithGroup_allow-<proc[dRegions_PlayerMatchRegionGroup].context[%group%|__global__|%world%|%player%]>

#  state-process-Global-WithTargetWithGroup_allow-true:
#    - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|%flag-targetList%].replace[, ].with[|].as_list>'
#    - if %targetList% == li@null {
#      - queue clear
#      }
#    - if %targetList% != li@all {
#      - if %targetList% !contains %target% {
#        - inject %FlagScript% p:event-cleanup
#        - determine cancelled
#        }
#      }

#  state-process-Global-WithTargetWithGroup_allow-false:
#    - inject %FlagScript% p:event-cleanup
#    - determine cancelled

#  state-process-Global-WithTargetWithGroup_deny:
#    - define group '<def[flagObj].split[/].get[2]||all>'
#    - inject locally state-process-Global-WithTargetWithGroup_deny-<proc[dRegions_PlayerMatchRegionGroup].context[%group%|__global__|%world%|%player%]>

#  state-process-Global-WithTargetWithGroup_deny-true:
#    - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|%flag-targetList%].replace[, ].with[|].as_list>'
#    - if %targetList% == li@null {
#      - inject %FlagScript% p:event-cleanup
#      - determine cancelled
#      }
#    - if %targetList% == li@all {
#      - inject %FlagScript% p:event-cleanup
#      - determine cancelled
#      }
#    - if %targetList% contains %target% {
#      - inject %FlagScript% p:event-cleanup
#      - determine cancelled
#      }

#-------------------
# Global WithTargetNoGroup Flag Processors
#
#  state-process-Global-WithTargetNoGroup_null:
#    - inject locally state-process-Global-WithTargetNoGroup_<def[FlagScript].yaml_key[flag_globalDefalut]||none>

#  state-process-Global-WithTargetNoGroup_none:
#    - foreach next
#    - queue clear

#  state-process-Global-WithTargetNoGroup_allow:
#    - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|%flag-targetList%].replace[, ].with[|].as_list>'
#    - if %targetList% == 'li@null' {
#      - queue clear
#      }
#    - if %targetList% != li@all {
#      - if %targetList% !contains %target% {
#        - inject %FlagScript% p:event-cleanup
#        - determine cancelled
#        }
#      }

#  state-process-Global-WithTargetNoGroup_deny:
#    - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|__global__|%flag-targetList%].replace[, ].with[|].as_list>'
#    - if %targetList% == li@null {
#      - inject %FlagScript% p:event-cleanup
#      - determine cancelled
#      }
#    - if %targetList% == li@all {
#      - inject %FlagScript% p:event-cleanup
#      - determine cancelled
#      }
#    - if %targetList% contains %target% {
#      - inject %FlagScript% p:event-cleanup
#      - determine cancelled
#      }


#-------------------
# Region WithGroup Flag Processors
#
#  state-process-WithGroup_null:
#    - define flagObj '<def[FlagScript].yaml_key[flag_defaultValue]||none>'
#    - inject locally state-process-WithGroup_<def[flagObj].split[/].get[1]>

#  state-process-WithGroup_none:
#    - foreach next
#    - queue clear

#  state-process-WithGroup_allow:
#    - define group '<def[flagObj].split[/].get[2]||all>'
#    - inject locally state-process-WithGroup_deny-<proc[dRegions_PlayerMatchRegionGroup].context[%group%|<def[orderedRegions].get[1]>|%world%|%player%].not>

#  state-process-WithGroup_deny:
#    - define group '<def[flagObj].split[/].get[2]||all>'
#    - inject locally state-process-WithGroup_deny-<proc[dRegions_PlayerMatchRegionGroup].context[%group%|<def[orderedRegions].get[1]>|%world%|%player%]>

#  state-process-WithGroup_deny-true:
#    - inject %FlagScript% p:event-cleanup
#    - determine cancelled


#-------------------
# Region WithTargetWithGroup Flag Processors
#
#  state-process-WithTargetWithGroup_null:
#    - define flagObj '<def[FlagScript].yaml_key[flag_defaultValue]||none>'
#    - inject locally state-process-WithTargetWithGroup_<def[flagObj].split[/].get[1]>

#  state-process-WithTargetWithGroup_none:
#    - foreach next
#    - queue clear

#  state-process-WithTargetWithGroup_allow:
#    - define group '<def[flagObj].split[/].get[2]||all>'
#    - inject locally state-process-WithTargetWithGroup_allow-<proc[dRegions_PlayerMatchRegionGroup].context[%group%|<def[orderedRegions].get[1]>|%world%|%player%]>

#  state-process-WithTargetWithGroup_allow-true:
#    - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|%flag-targetList%].replace[, ].with[|].as_list>'
#    - if %targetList% == li@null {
#      - queue clear
#      }
#    - if %targetList% != li@all {
#      - if %targetList% !contains %target% {
#        - inject %FlagScript% p:event-cleanup
#        - determine cancelled
#        }
#      }

#  state-process-WithTargetWithGroup_allow-false:
#    - inject %FlagScript% p:event-cleanup
#    - determine cancelled

#  state-process-WithTargetWithGroup_deny:
#    - define group '<def[flagObj].split[/].get[2]||all>'
#    - inject locally state-process-WithTargetWithGroup_deny-<proc[dRegions_PlayerMatchRegionGroup].context[%group%|<def[orderedRegions].get[1]>|%world%|%player%]>

#  state-process-WithTargetWithGroup_deny-true:
#    - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|%flag-targetList%].replace[, ].with[|].as_list>'
#    - if %targetList% == li@null {
#      - inject %FlagScript% p:event-cleanup
#      - determine cancelled
#      }
#    - if %targetList% == li@all {
#      - inject %FlagScript% p:event-cleanup
#      - determine cancelled
#      }
#    - if %targetList% contains %target% {
#      - inject %FlagScript% p:event-cleanup
#      - determine cancelled
#      }

#-------------------
# Region WithTargetNoGroup Flag Processors
#
#  state-process-WithTargetNoGroup_null:
#    - inject locally state-process-WithTargetNoGroup_<def[FlagScript].yaml_key[flag_defaultValue]||none>

#  state-process-WithTargetNoGroup_none:
#    - foreach next
#    - queue clear

#  state-process-WithTargetNoGroup_allow:
#    - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|%flag-targetList%].replace[, ].with[|].as_list>'
#    - if %targetList% == 'li@null' {
#      - queue clear
#      }
#    - if %targetList% != li@all {
#      - if %targetList% !contains %target% {
#        - inject %FlagScript% p:event-cleanup
#        - determine cancelled
#        }
#      }

#  state-process-WithTargetNoGroup_deny:
#    - define targetList '<proc[dRegions_GetInheritedFlag].context[%world%|%region%|%flag-targetList%].replace[, ].with[|].as_list>'
#    - if %targetList% == li@null {
#      - inject %FlagScript% p:event-cleanup
#      - determine cancelled
#      }
#    - if %targetList% == li@all {
#      - inject %FlagScript% p:event-cleanup
#      - determine cancelled
#      }
#    - if %targetList% contains %target% {
#      - inject %FlagScript% p:event-cleanup
#      - determine cancelled
#      }



#-------------------------------------------------------------------------------


dRegions_Flags_CommandProcessors:
  type: task
  speed: 0
  debug: false

  command_verifiedList:
    - if <def[flagValue].is[==].to[null]||false> {
      - yaml set 'regions.%region%.flags.%flag%:!' 'id:dRegions_%world%_regions'
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - run s@dRegions_Msg delay:1t 'def:<&c>Cleared %flag% list for region %region%'
      - queue clear
      }
      else {
      - define entries '<def[flagValue].split[ ].get[2].to[<def[flagValue].split[ ].size>].parse[to_lowercase].deduplicate||li@>'
      - if <def[entries].get[1].is[==].to[all]> {
        - if '<def[flagValue].split[ ].get[1].is[==].to[-a]||false>' {
          - yaml set 'regions.%region%.flags.%flag%:all' 'id:dRegions_%world%_regions'
          - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
          - run s@dRegions_Msg delay:1t 'def:<&f><&o>%region%<&7><&o> set %flag% flag to <&f><&o>%flagValue%'
          - queue clear
          }
        - if '<def[flagValue].split[ ].get[1].is[==].to[-r]||false>' {
          - yaml set 'regions.%region%.flags.%flag%:!' 'id:dRegions_%world%_regions'
          - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
          - run s@dRegions_Msg delay:1t 'def:<&c>Cleared %flag% list for region %region%'
          - queue clear
          }
        }
      - foreach %entries% {
        - if <parse:<s@dRegions_Flag_%Flag%.yaml_key[command_verifyEntry]||false>> {
          - define entries '<def[entries].exclude[%value%]||li@>'
          - run  s@dRegions_Msg 'def:<&c><&o>%value% is not a valid <s@dRegions_Flag_%Flag%.yaml_key[command_entryType]>!'
          }
        }
      - if <def[entries].is_empty||true> {
        - run  s@dRegions_Msg 'def:<&c><&o>No valid <s@dRegions_Flag_%Flag%.yaml_key[command_entryType]>s specified!'
        - define lines '<proc[dRegions_LineWrap].context[<s@dRegions_Flag_%Flag%.yaml_key[flag_help]||<&c>%flag% flag requires a %type% value!>|45]>'
        - foreach <def[lines]> {
          - run s@dRegions_Msg delay:1t 'def:<&c><def[value]>'
          }
        - queue clear
        }

      - define currentEntries '<yaml[dRegions_%world%_regions].read[regions.%region%.flags.%flag%].replace[, ].with[|].as_list||li@>'
      - if '<def[flagValue].split[ ].get[1].is[==].to[-a]||false>' {
        - define flagValue '<def[currentEntries].include[<def[entries].replace[li@]>].deduplicate||li@>'
        }
      - if '<def[flagValue].split[ ].get[1].is[==].to[-r]||false>' {
        - define flagValue '<def[currentEntries].exclude[<def[entries].replace[li@]>].deduplicate||li@>'
        }
      - if <def[flagValue].is_empty||true> {
        - yaml set 'regions.%region%.flags.%flag%:!' 'id:dRegions_%world%_regions'
        - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
        - run s@dRegions_Msg delay:1t 'def:<&c>Cleared %flag% list for region %region%'
        - queue clear
        }
      - define flagValue '<def[flagValue].comma_separated>'
      }


  command_stringList:
    - if <def[flagValue].is[==].to[null]||false> {
      - yaml set 'regions.%region%.flags.%flag%:!' 'id:dRegions_%world%_regions'
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - run s@dRegions_Msg delay:1t 'def:<&c>Cleared %flag% list for region %region%'
      - queue clear
      }
    - define action '<def[flagValue].split[ ].get[1]>'
    - define string '<def[flagValue].after[<def[action]>]>'

    - if '<def[string].is[==].to[all]>' {
      - if <def[action].is[==].to[-a]||false> {
        - yaml set 'regions.%region%.flags.%flag%:all' 'id:dRegions_%world%_regions'
        - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
        - run s@dRegions_Msg delay:1t 'def:<&f><&o>%region%<&7><&o> set %flag% flag to <&f><&o>%flagValue%'
        - queue clear
        }
      - if <def[action].is[==].to[-r]||false> {
        - yaml set 'regions.%region%.flags.%flag%:!' 'id:dRegions_%world%_regions'
        - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
        - run s@dRegions_Msg delay:1t 'def:<&c>Cleared %flag% list for region %region%'
        - queue clear
        }
      }
    - if <def[string].length.is[==].to[0]||true> {
      - run  s@dRegions_Msg 'def:<&c><&o>No valid <s@dRegions_Flag_%Flag%.yaml_key[command_entryType]>s specified!'
      - define lines '<proc[dRegions_LineWrap].context[<s@dRegions_Flag_%Flag%.yaml_key[flag_help]||<&c>%flag% flag requires a %type% value!>|45]>'
      - foreach <def[lines]> {
        - run s@dRegions_Msg delay:1t 'def:<&c><def[value]>'
        }
      - queue clear
      }

    - define currentEntries '<yaml[dRegions_%world%_regions].read[regions.%region%.flags.%flag%].replace[ ; ].with[|].as_list||li@>'
    - if '<def[action].is[==].to[-a]||false>' {
      - define flagValue '<def[currentEntries].include[<def[string]>].deduplicate||li@>'
      }
    - if '<def[action].is[==].to[-r]||false>' {
      - define flagValue '<def[currentEntries].exclude[<def[string]>].deduplicate||li@>'
      }
    - if <def[flagValue].is_empty||true> {
      - yaml set 'regions.%region%.flags.%flag%:!' 'id:dRegions_%world%_regions'
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - run s@dRegions_Msg delay:1t 'def:<&c>Cleared %flag% list for region %region%'
      - queue clear
      }
    - define flagValue '<def[flagValue].replace[|].with[ ; ].replace[li@]>'


#
