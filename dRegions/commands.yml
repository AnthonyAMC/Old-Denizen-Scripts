
################################################################################
#
#  dRegions Command Script Container
#
# This script covers all dRegions commands
#
# I haven't examined this in great detail since dRegions 0.2x. It's probably
# due for some revisions
#
#--------------------------------------
#
#  dRegions Command Script Basics
#
# The basic stuff required in a command script container
#
dRegions_Commands:
  type: command
  speed: 0
  debug: false
  name: dregions
  description: Denizen Regions Manager
  usage: /dregions
  aliases:
  - drg
  allowed help:
  - determine true

  commandArgs:
    help:
      usage: '/drg help <&lt>arg/<&ns><&gt>'
      permissions: []
    about:
      usage: '/drg about'
      permissions: []
    reload:
      usage: '/drg reload'
      permissions:
        - dregions.reload
    restart:
      usage: '/drg restart'
      permissions:
        - dregions.restart
    define:
      usage: '/drg define [ID] (g:group) (player)'
      permissions:
        - dregions.define
    redefine:
      usage: '/drg redefine [ID]'
      permissions:
        - dregions.redefine
        - dregions.redefine.own.*
        - dregions.redefine.own.%region%
        - dregions.redefine.member.*
        - dregions.redefine.member.%region%
    claim:
      usage: '/drg claim [ID]'
      permissions: []
    select:
      usage: '/drg select [ID] -w world'
      permissions: []
    info:
      usage: '/drg info [ID] -w world'
      permissions:
        - dregions.info
        - dregions.info.own.*
        - dregions.info.own.%region%
        - dregions.info.member.*
        - dregions.info.member.%region%
    addowner:
      usage: '/drg addowner [ID] g:group player -w world'
      permissions:
        - dregions.addowner
        - dregions.addowner.own.*
        - dregions.addowner.own.%region%
        - dregions.addowner.member.*
        - dregions.addowner.member.%region%
    removeowner:
      usage: '/drg removeowner [ID] g:group player -w world'
      permissions:
        - dregions.removeowner
        - dregions.removeowner.own.*
        - dregions.removeowner.own.%region%
        - dregions.removeowner.member.*
        - dregions.removeowner.member.%region%
    addmember:
      usage: '/drg addmember [ID] g:group player -w world'
      permissions:
        - dregions.addmember
        - dregions.addmember.own.*
        - dregions.addmember.own.%region%
        - dregions.addmember.member.*
        - dregions.addmember.member.%region%
    removemember:
      usage: '/drg removemember [ID] g:group player -w world'
      permissions:
        - dregions.removemember
        - dregions.removemember.own.*
        - dregions.removemember.own.%region%
        - dregions.removemember.member.*
        - dregions.removemember.member.%region%
    list:
      usage: '/drg list (page<&ns>) -h -r region -w world -p player'
      permissions:
        - dregions.list
        - dregions.list.own.*
        - dregions.list.own.%region%
        - dregions.list.member.*
        - dregions.list.member.%region%
    flag:
      usage: '/drg flag [ID] [flag] [value] -g group -w world'
      permissions:
        - dregions.flags.*
        - dregions.flags.<def[flag]>
        - dregions.flag
        - dregions.flag.flags.*
        - dregions.flag.flags.<def[flag]>
        - dregions.flag.own.*
        - dregions.flag.own.<def[region]>
        - dregions.flag.member.*
        - dregions.flag.member.<def[region]>
    setpriority:
      usage: '/drg setpriority [ID] [<&ns>]'
      permissions:
        - dregions.setpriority
        - dregions.setpriority.own.*
        - dregions.setpriority.own.%region%
        - dregions.setpriority.member.*
        - dregions.setpriority.member.%region%
    setparent:
      usage: '/drg setparent [ID] [parent]'
      permissions:
        - dregions.setparent
        - dregions.setparent.own.*
        - dregions.setparent.own.%region%
        - dregions.setparent.member.*
        - dregions.setparent.member.%region%
    teleport:
      usage: '/drg teleport [ID] -w world'
      permissions:
        - dregions.teleport
        - dregions.teleport.own.*
        - dregions.teleport.own.%region%
        - dregions.teleport.member.*
        - dregions.teleport.member.%region%
    remove:
      usage: '/drg remove [ID] -w world'
      permissions:
        - dregions.remove
        - dregions.remove.own.*
        - dregions.remove.own.%region%
        - dregions.remove.member.*
        - dregions.remove.member.%region%

  tab complete:
    - define args '<script.list_keys[commandArgs].alphanumeric.to_lowercase||li@>'
    - define arg '<c.args.get[1]||null>'
    - if <def[arg].is[==].to[null]>
      || !<def[args].contains[%arg%]> {
      - inject locally tab_arg_1
      }
      else {
      - inject locally tab_%arg%
      }
    - determine '<def[result]||li@>'

  script:
    - define command '<c.args.get[1].escaped||help>'
    - define args '<script.list_keys[commandArgs].alphanumeric.to_lowercase||li@>'
    - if !<def[args].contains[%command%]> {
      - inject locally help
      }
      else {
      - inject locally %command%
      }


#
#  END dRegions Command Script Basics
#--------------------------------------
#
#  dRegions Command TAB Completion
#
# Each of these subscripts handles TAB completion for the positional argument.
#
#
  tab_arg_1:
    # This Excludes args from the original args
    - foreach %args% {
      - if !<player.permission[dregions.%value%]||<player.is_op||false>> {
        - define args '<def[args].exclude[%value%]||%args%>'
        }
      }
    - if <def[args].is_empty||true> {
      - define result 'li@'
      }
      else {
      - define result '<def[args].filter[starts_with[%arg%]]||li@>'
      - if <def[result].is_empty||true> {
        - define result '%args%'
        }
      }

  tab_help:
    - define spaces '<c.raw_args.to_list.count[ ]||0>'
    - if <def[spaces].is[==].to[0]> {
      - define result 'help [command]'
      }
      else if <def[spaces].is[==].to[1]> {
      - define result 'li@'
      - foreach %args% {
        - if <player.permission[dregions.%value%]||<player.is_op||false>> {
          - define result '<def[result].include[%value%]||%result%>'
          }
          else {
          - foreach next
          }
        }
      - if <c.args.get[2].is[!=].to[null]||false> {
        - define result '<def[args].filter[starts_with[<c.args.get[2]>]]||li@>'
        - if <def[result].is_empty> {
          - foreach %args% {
            - if <player.permission[dregions.%value%]||<player.is_op||false>> {
              - define result '<def[result].include[%value%]||%result%>'
              }
              else {
              - foreach next
              }
            }
          }
        }
      }

  tab_about:
    - define result 'li@'

  tab_reload:
    - define result 'li@'

  tab_restart:
    - define result 'li@'

  tab_define:
  # /drg define [ID] (g:group) (player)
    - if <player.permission[dregions.define]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - if <def[spaces].is[==].to[0]> {
        - define result 'define [ID]'
        }

        else if <def[spaces].is[==].to[1]> {
        - if <c.args.get[2].is[==].to[null]||true> {
          - define result '[ID] (g:group) (player)'
          }
          else {
          - define result '<c.args.get[2]> (g:group) (player)'
          }
        }

        else if <def[spaces].is[OR_MORE].than[2]> {
        - define owners '<c.args.remove[1|2]||li@>'
        - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
          - define owners '<def[owners].remove[<def[owners].find[-w]>|<def[owners].find[-w].add[1].as_int>]||li@>'
          }
        - define owner '<def[owners].last||li@>'
        - if <def[owner].starts_with[g:]||false> {
          - define group '<def[owner].replace[g:]>'
          - define groups '<server.list_permission_groups.filter[starts_with[%group%]]||li@>'
          - if <def[groups].is_empty> {
            - define groups '<server.list_permission_groups||li@>'
            }
          - define result '<def[groups].parse[replace[regex:^].with[g:]]>'
          }
          else {
          - define result '<server.match_player[%owner%].name||null>'
          - if <def[result].is[==].to[null]||true> {
            - define result '<server.list_online_players.parse[name]>'
            }
          }
        }
        else {
        - define result 'li@'
        }
      }
      else {
      - define result 'li@'
      }

  tab_redefine:
  # /drg redefine [ID]
    - if <player.permission[dregions.redefine]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
      - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
      - if !<player.permission[dregions.admin]||<player.is_op||true>> {
        - foreach %regions% {
          - if <proc[dRegions_IsOwner].context[%value%|%world%|<player>].not> {
            - define regions '<def[regions].exclude[%value%]||%regions%>'
            }
          }
        }
      - if <def[spaces].is[==].to[0]> {
        - define result '<def[regions].parse[replace[regex:^].with[redefine ]]>'
        }
        else if <def[spaces].is[==].to[1]> {
        - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||li@>'
        - if <def[result].is_empty||true> {
          - define result '%regions%'
          }
        }
        else {
        - define result 'li@'
        }
      }
      else {
      - define result 'li@'
      }

  tab_claim:
    - if <player.permission[dregions.claim]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
      - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
      - if !<player.permission[dregions.admin]||<player.is_op||false>> {
        - foreach %regions% {
          - if <proc[dRegions_IsOwner].context[%value%|%world%|<player>].not> {
            - define regions '<def[regions].exclude[%value%]||%regions%>'
            }
          }
        }
      - if <def[spaces].is[==].to[0]> {
        - define result '<def[regions].parse[replace[regex:^].with[claim ]]>'
        }
        else if <def[spaces].is[==].to[1]> {
        - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||li@>'
        - if <def[result].is_empty||true> {
          - define result '%regions%'
          }
        }
        else {
        - define result 'li@'
        }
      }
      else {
      - define result 'li@'
      }

  tab_select:
  # /drg select [ID] -w world
    - if <player.permission[dregions.select]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
      - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
      - if !<player.permission[dregions.admin]||<player.is_op||false>> {
        - foreach %regions% {
          - if <proc[dRegions_IsOwner].context[%value%|%world%|<player>].not> {
            - define regions '<def[regions].exclude[%value%]||%regions%>'
            }
          }
        }
      - if <def[spaces].is[==].to[0]> {
        - define result '<def[regions].parse[replace[regex:^].with[select ]]>'
        }
        else if <def[spaces].is[==].to[1]> {
        - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped||null>]]||li@>'
        - if <def[result].is_empty||true> {
          - define result '%regions%'
          }
        }
        else {
        - define result 'li@'
        }
      }
      else {
      - define result 'li@'
      }

  tab_info:
  # /drg info [ID] -w world
    - if <player.permission[dregions.info]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
      - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
      - if !<player.permission[dregions.admin]||<player.is_op||false>> {
        - foreach %regions% {
          - if <proc[dRegions_IsOwner].context[%value%|%world%|<player>].not> {
            - define regions '<def[regions].exclude[%value%]||%regions%>'
            }
          }
        }
      - if <def[spaces].is[==].to[0]> {
        - define result '<def[regions].parse[replace[regex:^].with[info ]]>'
        }
        else if <def[spaces].is[==].to[1]> {
        - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped||null>]]||li@>'
        - if <def[result].is_empty||true> {
          - define result '%regions%'
          }
        }
        else {
        - define result 'li@'
        }
      }
      else {
      - define result 'li@'
      }

  tab_addowner:
  # /drg addowner [ID] g:group player -w world
    - if <player.permission[dregions.addowner]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
      - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
      - if !<player.permission[dregions.admin]||<player.is_op||false>> {
        - foreach %regions% {
          - if <proc[dRegions_IsOwner].context[%value%|%world%|<player>].not> {
            - define regions '<def[regions].exclude[%value%]||%regions%>'
            }
          }
        }
      - if <def[spaces].is[==].to[0]> {
        - define result '<def[regions].parse[replace[regex:^].with[addowner ]]>'
        }
        else if <def[spaces].is[==].to[1]> {
        - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped||null>]]||li@>'
        - if <def[result].is_empty||true> {
          - define result '%regions%'
          }
        }
        else if <def[spaces].is[OR_MORE].than[2]> {
        - define owners '<c.args.remove[1|2]||li@>'
        - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
          - define owners '<def[owners].remove[<def[owners].find[-w]>|<def[owners].find[-w].add[1].as_int>]||li@>'
          }
        - define owner '<def[owners].last||li@>'
        - if <def[owner].starts_with[g:]||false> {
          - define group '<def[owner].replace[g:]>'
          - define groups '<server.list_permission_groups.filter[starts_with[%group%]]||li@>'
          - if <def[groups].is_empty> {
            - define groups '<server.list_permission_groups.alphanumeric||li@>'
            }
          - define result '<def[groups].parse[replace[regex:^].with[g:]]>'
          }
          else {
          - define result '<server.match_player[%owner%].name||null>'
          - if <def[result].is[==].to[null]||true> {
            - define result '<server.list_online_players.parse[name].alphanumeric>'
            }
          }
        }
        else {
        - define result 'li@'
        }
      }
      else {
      - define result 'li@'
      }

  tab_removeowner:
  # /drg removeowner [ID] g:group player -w world
    - if <player.permission[dregions.removeowner]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
      - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
      - if !<player.permission[dregions.admin]||<player.is_op||false>> {
        - foreach %regions% {
          - if <proc[dRegions_IsOwner].context[%value%|%world%|<player>].not> {
            - define regions '<def[regions].exclude[%value%]||%regions%>'
            }
          }
        }
      - if <def[spaces].is[==].to[0]> {
        - define result '<def[regions].parse[replace[regex:^].with[removeowner ]]>'
        }
        else if <def[spaces].is[==].to[1]> {
        - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||li@>'
        - if <def[result].is_empty||true> {
          - define result '%regions%'
          }
        }
        else if <def[spaces].is[OR_MORE].than[2]> {
        - define owners '<c.args.remove[1|2]||li@>'
        - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
          - define owners '<def[owners].remove[<def[owners].find[-w]>|<def[owners].find[-w].add[1].as_int>]||li@>'
          }
        - define owner '<def[owners].last||li@>'
        - if <def[owner].starts_with[g:]||false> {
          - define group '<def[owner].replace[g:]>'
          - define groups '<server.list_permission_groups.filter[starts_with[%group%]]||li@>'
          - if <def[groups].is_empty> {
            - define groups '<server.list_permission_groups.alphanumeric||li@>'
            }
          - define result '<def[groups].parse[replace[regex:^].with[g:]]>'
          }
          else {
          - define result '<server.match_player[%owner%].name||null>'
          - if <def[result].is[==].to[null]||true> {
            - define result '<server.list_online_players.parse[name].alphanumeric>'
            }
          }
        }
        else {
        - define result 'li@'
        }
      }
      else {
      - define result 'li@'
      }

  tab_addmember:
  # /drg addmember [ID] g:group player -w world
    - if <player.permission[dregions.addmember]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
      - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
      - if !<player.permission[dregions.admin]||<player.is_op||false>> {
        - foreach %regions% {
          - if <proc[dRegions_IsOwner].context[%value%|%world%|<player>].not> {
            - define regions '<def[regions].exclude[%value%]||%regions%>'
            }
          }
        }
      - if <def[spaces].is[==].to[0]> {
        - define result '<def[regions].parse[replace[regex:^].with[addmember ]]>'
        }
        else if <def[spaces].is[==].to[1]> {
        - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||li@>'
        - if <def[result].is_empty||true> {
          - define result '%regions%'
          }
        }
        else if <def[spaces].is[OR_MORE].than[2]> {
        - define members '<c.args.remove[1|2]||li@>'
        - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
          - define members '<def[members].remove[<def[members].find[-w]>|<def[members].find[-w].add[1].as_int>]||li@>'
          }
        - define member '<def[members].last||li@>'
        - if <def[member].starts_with[g:]||false> {
          - define group '<def[member].replace[g:]>'
          - define groups '<server.list_permission_groups.filter[starts_with[%group%]]||li@>'
          - if <def[groups].is_empty> {
            - define groups '<server.list_permission_groups.alphanumeric||li@>'
            }
          - define result '<def[groups].parse[replace[regex:^].with[g:]]>'
          }
          else {
          - define result '<server.match_player[%member%].name||null>'
          - if <def[result].is[==].to[null]||true> {
            - define result '<server.list_online_players.parse[name].alphanumeric>'
            }
          }
        }
        else {
        - define result 'li@'
        }
      }
      else {
      - define result 'li@'
      }

  tab_removemember:
  # /drg removemember [ID] g:group player -w world
    - if <player.permission[dregions.removemember]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
      - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
      - if !<player.permission[dregions.admin]||<player.is_op||false>> {
        - foreach %regions% {
          - if <proc[dRegions_IsOwner].context[%value%|%world%|<player>].not> {
            - define regions '<def[regions].exclude[%value%]||%regions%>'
            }
          }
        }
      - if <def[spaces].is[==].to[0]> {
        - define result '<def[regions].parse[replace[regex:^].with[removemember ]]>'
        }
        else if <def[spaces].is[==].to[1]> {
        - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||li@>'
        - if <def[result].is_empty||true> {
          - define result '%regions%'
          }
        }
        else if <def[spaces].is[OR_MORE].than[2]> {
        - define members '<c.args.remove[1|2]||li@>'
        - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
          - define members '<def[members].remove[<def[members].find[-w]>|<def[members].find[-w].add[1].as_int>]||li@>'
          }
        - define member '<def[members].last||li@>'
        - if <def[member].starts_with[g:]||false> {
          - define group '<def[member].replace[g:]>'
          - define groups '<server.list_permission_groups.filter[starts_with[%group%]]||li@>'
          - if <def[groups].is_empty> {
            - define groups '<server.list_permission_groups.alphanumeric||li@>'
            }
          - define result '<def[groups].parse[replace[regex:^].with[g:]]>'
          }
          else {
          - define result '<server.match_player[%member%].name||null>'
          - if <def[result].is[==].to[null]||true> {
            - define result '<server.list_online_players.parse[name].alphanumeric>'
            }
          }
        }
        else {
        - define result 'li@'
        }
      }
      else {
      - define result 'li@'
      }

  tab_list:
    - define result 'li@'

  tab_flag:
  # TODO
  # /drg flag [ID] [flag] [value] -g group -w world
    - if <player.permission[dregions.flag]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - if <def[spaces].is[==].to[0]> {
        - define result 'flag [ID]'
        }
        else if <def[spaces].is[==].to[1]> {
        - if <c.args.get[2].is[==].to[null]||true> {
          - define result '[ID]'
          }
          else if <c.args.get[2].is[==].to[-w]||false> {
          - define result '<server.list_worlds.parse[name.to_lowercase].parse[replace[regex:^].with[-w ]]>'
          }
          else if <context.server.not> {
          - define regions '<yaml[dRegions_<player.world.name.to_lowercase>_regions].list_keys[regions].alphanumeric||li@>'
          - if !<player.permission[dregions.admin]||<player.is_op||false>> {
            - foreach %regions% {
              - if <proc[dRegions_IsOwner].context[%value%|<player.world.name.to_lowercase>|<player>].not> {
                - define regions '<def[regions].exclude[%value%]||%regions%>'
                }
              }
            }
          - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||li@>'
          - if <def[result].is_empty||true> {
            - define result '%regions%'
            }
          }
          else {
          - define result 'li@'
          }
        }
        else if <def[spaces].is[==].to[2]> {
        - if <c.args.get[2].is[==].to[-w]||false> {
          - if <c.args.get[3].is[!=].to[null]||false> {
            - define result '<server.list_worlds.parse[name.to_lowercase].filter[starts_with[<c.args.get[3].escaped>]]||li@>'
            }
          - if <def[result].is_empty||true> {
            - define result '<server.list_worlds.parse[name.to_lowercase]||li@>'
            }
          }
          else if <c.args.get[2].is[!=].to[null]||false> {
          - define allFlags '<server.flag[dRegions.Flags].as_list||li@>'
          - if <c.args.get[3].is[==].to[-w]||false> {
            - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
            - if <c.args.get[3].is[!=].to[null]||false> {
              - define result '<server.list_worlds.parse[name.to_lowercase].filter[starts_with[<c.args.get[3].escaped>]]||li@>'
              }
            - if <def[result].is_empty||true> {
              - define result '<server.list_worlds.parse[name.to_lowercase].parse[replace[regex:^].with[-w ]]||li@>'
              }
            }
            else if <c.args.get[3].is[!=].to[null]||false> {
            - define result '<def[allFlags].filter[starts_with[<c.args.get[3].escaped>]]||li@>'
            - if <def[result].is_empty||true> {
              - define result '<def[allFlags]||li@>'
              }
            }
            else {
            - if <def[result].is_empty||true> {
              - define result '<def[allFlags]||li@>'
              }
            }
          }
        }
        else if <def[spaces].is[==].to[3]> {
        - if <c.args.get[2].is[==].to[-w]||false> {
          - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
          - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].alphanumeric||li@>'
          - if <c.args.get[4].is[!=].to[null]||false> {
            - define result '<def[regions].filter[starts_with[<c.args.get[4].escaped>]]||li@>'
            }
          - if <def[result].is_empty||true> {
            - define result '<def[regions]||li@>'
            }
          }
          else if <c.args.get[3].is[==].to[-w]||false> {
          - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
          - if <c.args.get[4].is[!=].to[null]||false> {
            - define result '<server.list_worlds.parse[name.to_lowercase].filter[starts_with[<c.args.get[3].escaped>]].parse[replace[regex:^].with[-w ]]||li@>'
            }
          - if <def[result].is_empty||true> {
            - define result '<server.list_worlds.parse[name.to_lowercase]||li@>'
            }
          }
          else if <c.args.get[4].is[==].to[-w]||false> {
          - define result '<server.list_worlds.parse[name.to_lowercase].parse[replace[regex:^].with[-w ]]||li@>'
          }
        }
        else if <def[spaces].is[==].to[4]> {
        - if <c.args.get[4].is[==].to[-w]||false> {
          - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
          - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].alphanumeric||li@>'
          - if <c.args.get[5].is[!=].to[null]||false> {
            - define result '<server.list_worlds.parse[name.to_lowercase].filter[starts_with[<c.args.get[5].escaped>]]||li@>'
            }
          - if <def[result].is_empty||true> {
            - define result '<server.list_worlds.parse[name.to_lowercase]||li@>'
            }
          }
          else {
          - define allFlags '<server.flag[dRegions.Flags].as_list||li@>'
          - if <c.args.get[5].is[!=].to[null]||false> {
            - define result '<def[allFlags].filter[starts_with[<c.args.get[5].escaped>]]||li@>'
            }
          - if <def[result].is_empty||true> {
            - define result '<def[allFlags]||li@>'
            }
          }
        }
      }
      else {
      - define result 'li@'
      }

  tab_setpriority:
  # /drg remove [ID] -w world
    - if <player.permission[dregions.setpriority]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - if <def[spaces].is[==].to[0]> {
        - define result 'setpriority [ID]'
        }
        else if <def[spaces].is[==].to[1]> {
        - if <c.args.get[2].is[==].to[null]||true> {
          - define result '[ID]'
          }
          else if <c.args.get[2].is[==].to[-w]||false> {
          - define result '<server.list_worlds.parse[name.to_lowercase].parse[replace[regex:^].with[-w ]]>'
          }
          else if <context.server.not> {
          - define regions '<yaml[dRegions_<player.world.name.to_lowercase>_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
          - if !<player.permission[dregions.admin]||<player.is_op||false>> {
            - foreach %regions% {
              - if <proc[dRegions_IsOwner].context[%value%|<player.world.name.to_lowercase>|<player>].not> {
                - define regions '<def[regions].exclude[%value%]||%regions%>'
                }
              }
            - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||li@>'
            }
            else {
            - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||%regions%>'
            - if <def[result].is_empty> {
              - define result '%regions%'
              }
            }
          }
          else {
          - define result 'li@'
          }
        }
        else if <def[spaces].is[==].to[2]> {
        - if <c.args.get[2].is[==].to[-w]||false> {
          - if <c.args.get[3].is[!=].to[null]||false> {
            - define result '<server.list_worlds.parse[name.to_lowercase].filter[starts_with[<c.args.get[3].escaped>]]||li@>'
            }
          - if <def[result].is_empty||true> {
            - define result '<server.list_worlds.parse[name.to_lowercase]||li@>'
            }
          }
          else {
          - if <c.args.get[3].is[MATCHES].to[number]> {
            - define result '<c.args.get[3]>'
            }
            else if <c.args.get[3].is[==].to[-w]||false> {
            - define result '<server.list_worlds.parse[name.to_lowercase].parse[replace[regex:^].with[-w ]]||li@>'
            }
            else {
            - define result '<&ns>'
            }
          }
        }
        else if <def[spaces].is[==].to[3]> {
        - if <c.args.get[2].is[==].to[-w]||false> {
          - if <c.args.get[4].is[!=].to[null]||false> {
            - define regions '<yaml[dRegions_<c.args.get[3].escaped>_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
            - define result '<def[regions].filter[starts_with[<c.args.get[4].escaped>]]||li@>'
            - if <def[result].is_empty||true> {
              - define result '%regions%'
              }
            }
            else {
            - define result '<yaml[dRegions_<c.args.get[3].escaped>_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
            }
          }
          else if <c.args.get[3].is[==].to[-w]||false> {
          - define result '<server.list_worlds.parse[name.to_lowercase]||li@>'
          }
          else {
          - if <c.args.get[4].is[!=].to[null]||false> {
            - define result '<server.list_worlds.parse[name.to_lowercase].filter[starts_with[<c.args.get[4].escaped>]]||li@>'
            }
            else {
            - define result '<server.list_worlds.parse[name].parse[replace[regex:^].with[-w ]]||li@>'
            }
          - if <def[result].is_empty||true> {
            - define result '<server.list_worlds.parse[name.to_lowercase].parse[replace[regex:^].with[-w ]]||li@>'
            }
          }
        }
        else if <def[spaces].is[==].to[4]> {
        - if <c.args.get[2].is[==].to[-w]||false>
          || <c.args.get[3].is[==].to[-w]||false> {
          - if <c.args.get[5].is[MATCHES].to[number]> {
            - define result '<c.args.get[5]>'
            }
            else {
            - define result '<&ns>'
            }
          }
          else if <c.args.get[4].is[==].to[-w]> {
          - define result '<server.list_worlds.parse[name.to_lowercase]||li@>'
          }
        }
        else {
        - define result 'li@'
        }
      }
      else {
      - define result 'li@'
      }

  tab_setparent:
  # TODO
    - define result 'li@'

  tab_teleport:
  # TODO
  # /drg teleport [ID] -w world
    - define result 'li@'

  tab_remove:
  # /drg remove [ID] -w world
    - if <player.permission[dregions.remove]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - if <def[spaces].is[==].to[0]> {
        - define result 'remove [ID] -w world'
        }
        else if <def[spaces].is[==].to[1]> {
        - if <c.args.get[2].is[==].to[null]||true> {
          - define result '[ID]'
          }
          else if <c.args.get[2].is[==].to[-w]||false> {
          - define result '<server.list_worlds.parse[name.to_lowercase].parse[replace[regex:^].with[-w ]]>'
          }
          else if <context.server.not> {
          - define regions '<yaml[dRegions_<player.world.name.to_lowercase>_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
          - if !<player.permission[dregions.admin]||<player.is_op||false>> {
            - foreach %regions% {
              - if <proc[dRegions_IsOwner].context[%value%|<player.world.name.to_lowercase>|<player>].not> {
                - define regions '<def[regions].exclude[%value%]||%regions%>'
                }
              }
            }
          - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||li@>'
          - if <def[result].is_empty||true> {
            - define result '%regions%'
            }
          }
          else {
          - define result 'li@'
          }
        }
        else if <def[spaces].is[==].to[2]> {
        - if <c.args.get[2].is[==].to[-w]||false> {
          - if <c.args.get[3].is[!=].to[null]||false> {
            - define result '<server.list_worlds.parse[name.to_lowercase].filter[starts_with[<c.args.get[3].escaped>]]||li@>'
            }
          - if <def[result].is_empty||true> {
            - define result '<server.list_worlds.parse[name.to_lowercase]||li@>'
            }
          }
          else {
          - define result '<server.list_worlds.parse[name.to_lowercase].parse[replace[regex:^].with[-w ]]>'
          }
        }
        else if <def[spaces].is[==].to[3]> {
        - if <c.args.get[2].is[==].to[-w]||false> {
          - if <c.args.get[4].is[!=].to[null]||false> {
            - define regions '<yaml[dRegions_<c.args.get[3].escaped>_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
            - define result '<def[regions].filter[starts_with[<c.args.get[4].escaped>]]||li@>'
            - if <def[result].is_empty||true> {
              - define result '%regions%'
              }
            }
            else {
            - define result '<yaml[dRegions_<c.args.get[3].escaped>_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
            }
          }
          else {
          - if <c.args.get[4].is[!=].to[null]||false> {
            - define result '<server.list_worlds.parse[name.to_lowercase].filter[starts_with[<c.args.get[4].escaped>]]||li@>'
            }
            else {
            - define result '<server.list_worlds.parse[name.to_lowercase]||li@>'
            }
          - if <def[result].is_empty||true> {
            - define result '<server.list_worlds.parse[name.to_lowercase]||li@>'
            }
          }
        }
        else {
        - define result 'li@'
        }
      }
      else {
      - define result 'li@'
      }


#
#  END dRegions Command TAB Completion
#--------------------------------------
#
#  dRegions Command Arguments
#
# Each of these subscripts is an argument for the root command.
#
  help:
    - define arg '<c.args.get[2].escaped||null>'
    - if <def[args].contains[%arg%]||false> {
      - run s@msgPrefixed delay:1t 'def:dRegions|<parse:<script.yaml_key[commandArgs.%arg%.usage]||No help for you!>>'
      - queue clear
      }
    - if <player.permission[dRegions.admin]||<player.is_op||<context.server||false>>> {
      - inject locally msgsHelpAdmin
      }
      else {
      - inject locally msgsHelpUser
      }
    - inject locally msgsFooter
    - queue clear

  about:
    - inject locally msgsHelpUser
    - inject locally msgsFooter
    - queue clear

  reload:
    - if !<player.permission[dRegions.reload]||<player.is_op||<context.server||false>>> {
      - inject locally help
      - queue clear
      }
    - inject s@dRegions p:reloadYaml instantly
#    - run s@msgPrefixed delay:1t 'def:dRegions|<&7><&o>System files loaded!'

  restart:
    - if !<player.permission[dRegions.restart]||<player.is_op||<context.server||false>>> {
      - inject locally help
      - queue clear
      }
    - run s@dRegions p:start instantly


  define:
  # /drg define [ID] (g:group) (player)
    - inject locally prerun instantly
    # Check for existing region
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]||true>'
    - if <def[exists].is[==].to[orphan]> {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>There is an orphaned region by this name!'
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists]> {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>There is already a region by this name!'
      - queue clear
      }
    # Check for overlapping regions
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_RegionOverlaps].context[<def[selectedCuboid].separated_by[/].replace[cu@]>|%world%|<player>]> {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Region selection contains unowned regions!'
        - queue clear
        }
      }
    # Parse any declared owners
    - define owners '<c.args.remove[1|2].replace[:].with[;]||li@>'
    - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
      - define owners '<def[owners].remove[<def[owners].find[-w]>|<def[owners].find[-w].add[1].as_int>]||li@>'
      }
    - define ownerGroups li@
    - define ownerPlayers li@
    - foreach %owners% {
      - if <def[value].starts_with[g;]||false> {
        - define ownerGroups '<def[ownerGroups].include[<def[value].replace[g;]>]||%ownerGroups%>'
        }
        else {
        - if !<def[value].as_player.is[!=].to[null]||false> {
          - foreach next
          }
        - define ownerPlayers '<def[ownerPlayers].include[<def[value].as_player.uuid>]||%ownerPlayers%>'
        }
      }
    # Automatically add the player that defined the region as the owner
    - if <yaml[dregions_global_config].read[config.regions.ownerOnDefine].is[==].to[true]||false> {
      - if <def[ownerPlayers].contains[<player.uuid>].not||false> {
        - define ownerPlayers '<def[ownerPlayers].include[<player.uuid>]||%ownerPlayers%>'
        }
      }
    # Create the region
    - inject s@dRegions p:createRegionEntry instantly
    - run s@msgPrefixed delay:1t 'def:dRegions|<&7><&o>Created %name% in %world%'

  redefine:
  # /drg redefine [ID]
    - inject locally prerun instantly
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>There is an orphaned region by this name!'
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists].not> {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>There is no region by this name!'
      - queue clear
      }
    # Don't redefine global type regions
    - if <yaml[dRegions_%world%_regions].read[regions.%name%.type].is[==].to[global]||false> {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>You can not redefine global regions!'
      - queue clear
      }
    # Check if is owner
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>You are not an owner of this region!'
        - queue clear
        }
      }
    # Check for overlapping regions
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_RegionOverlaps].context[<def[selectedCuboid].separated_by[/].replace[cu@]>|%world%|<player>]> {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Region selection contains unowned regions!'
        - queue clear
        }
      }
    # Update the region
    - yaml set 'regions.%name%.min:<def[selectedCuboid].min.simple>' 'id:dRegions_%world%_regions'
    - yaml set 'regions.%name%.max:<def[selectedCuboid].max.simple>' 'id:dRegions_%world%_regions'
    - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
    - note cu@<def[selectedCuboid].min.simple>|<def[selectedCuboid].max.simple> 'as:dregions_%world%_%name%'
    - run s@msgPrefixed delay:1t 'def:dRegions|<&f><&o>%name%<&7><&o> updated to selection'

  claim:
  # /drg claim [ID]
    - inject locally prerun instantly
    # Check Global region limits
    - define globalRegionLimit '<yaml[dregions_global_config].read[config.regions.claim.max-region-count-per-player.default]||0>'
    - if <def[globalRegionLimit].is[MORE].than[0]> {
      - define playerGlobalRegions 'li@'
      - foreach <server.list_worlds.parse[name.to_lowercase]> {
        - define thisWorld '%value%'
        - foreach '<yaml[dRegions_%thisWorld%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>' {
          - define region '%value%'
          - if <proc[dRegions_IsOwner].context[<def[region]>|<def[thisWorld]>|<player>]||false> {
            - define playerGlobalRegions '<def[playerGlobalRegions].include[<def[region]>]||<def[playerGlobalRegions]>>'
            }
          }
        }
      - if <def[playerGlobalRegions].size.is[OR_MORE].than[%globalRegionLimit%]> {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>You already have <def[playerGlobalRegions].size> total regions!'
        - if !<player.permission[dRegions.admin]||<player.is_op||false>> {
          - queue clear
          }
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>But you are an admin so it is ok!'
        }
      }
    # Check World region limits
    - define worldRegionLimit '<yaml[dregions_%world%_config].read[config.regions.claim.max-region-count-per-player.default]||0>'
    - if <def[worldRegionLimit].is[MORE].than[0]> {
      - define playerWorldRegions 'li@'
      - foreach '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>' {
        - define region '%value%'
        - if <proc[dRegions_IsOwner].context[<def[region]>|<def[world]>|<player>]||false> {
          - define playerWorldRegions '<def[playerWorldRegions].include[<def[region]>]||<def[playerWorldRegions]>>'
          }
        }
      - if <def[playerWorldRegions].size.is[OR_MORE].than[%worldRegionLimit%]> {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>You already have <def[playerWorldRegions].size> regions in this world!'
        - if !<player.permission[dRegions.admin]||<player.is_op||false>> {
          - queue clear
          }
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>But you are an admin so it is ok!'
        }
      }
    # Check selection volume
    - define globalClaimVol '<yaml[dregions_global_config].read[config.regions.claim.max-volume]||0>'
    - inject s@dWE_Commands p:selection_Size instantly
    - if <def[globalClaimVol].is[MORE].than[0]> {
      - if <def[size].is[MORE].than[%globalClaimVol%]> {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Your selection exceeds the global limit!'
        - run s@msgPrefixed delay:1t 'def:dRegions|<&7><&o>Selected <&8>(<&7><&o>%size%<&8>) <&7><&o>Limit <&8>(<&7><&o>%globalClaimVol%<&8>) <&7><&o>Over <&8>(<&7><&o><def[size].sub[%globalClaimVol%].as_int><&8>)'
        - if !<player.permission[dRegions.admin]||<player.is_op||false>> {
          - queue clear
          }
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>But you are an admin so it is ok!'
        }
      }
    - define worldClaimVol '<yaml[dregions_%world%_config].read[config.regions.claim.max-volume]||0>'
    - if <def[worldClaimVol].is[MORE].than[0]> {
      - if <def[size].is[MORE].than[%worldClaimVol%]> {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Your selection exceeds the world limit!'
        - run s@msgPrefixed delay:1t 'def:dRegions|<&7><&o>Selected <&8>(<&7><&o>%size%<&8>) <&7><&o>Limit <&8>(<&7><&o>%worldClaimVol%<&8>) <&7><&o>Over <&8>(<&7><&o><def[size].sub[%worldClaimVol%].as_int><&8>)'
        - if !<player.permission[dRegions.admin]||<player.is_op||false>> {
          - queue clear
          }
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>But you are an admin so it is ok!'
        }
      }
    # Check inside existing/owned region
    - if '<yaml[dregions_global_config].read[config.regions.claim.only-inside-existing-regions]||false>' {
      - if <def[playerWorldRegions].exists.not> {
        - define playerWorldRegions 'li@'
        - foreach '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>' {
          - define region '%value%'
          - if <proc[dRegions_IsOwner].context[<def[region]>|<def[world]>|<player>]||false> {
            - define playerWorldRegions '<def[playerWorldRegions].include[<def[region]>]||<def[playerWorldRegions]>>'
            }
          }
        }
      - define cuboids '<def[playerWorldRegions].parse[replace[regex:^].with[cu@dregions_%world%_]].filter[as_cuboid.is[!=].to[null]||false]||li@>'
      - foreach %cuboids% {
        - if <def[pos1].as_location.is_within[%value%]> && <def[pos2].as_location.is_within[%value%]> {
          - define isWithin ''
          - foreach stop
          }
        }
      - if <def[isWithin].exists.not> {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>You may only claim regions within land you own'
        - if !<player.permission[dRegions.admin]||<player.is_op||false>> {
          - queue clear
          }
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>But you are an admin so it is ok!'
        }
      }
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>There is an orphaned region by this name!'
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists]> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>You are not an owner of this region!'
        - queue clear
        }
      - if <yaml[dRegions_%world%_regions].read[regions.%name%.type].is[==].to[global]||false> {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>You can not redefine global regions!'
        - queue clear
        }
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Region already exists!'
      - run s@msgPrefixed delay:1t 'def:dRegions|<&7>You must want to update the region'
      - define update ''
      }
    # Check for overlapping regions
    # The perm check here is redundant
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_RegionOverlaps].context[<def[selectedCuboid].separated_by[/].replace[cu@]>|%world%|<player>]> {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Region selection contains unowned regions!'
        - if !<player.permission[dRegions.admin]||<player.is_op||false>> {
          - queue clear
          }
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>But you are an admin so it is ok!'
        }
      }
    # Update the region
    - if <def[update].exists||false> {
      - yaml set 'regions.%name%.min:<def[selectedCuboid].min.simple>' 'id:dRegions_%world%_regions'
      - yaml set 'regions.%name%.max:<def[selectedCuboid].max.simple>' 'id:dRegions_%world%_regions'
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - note cu@<def[selectedCuboid].min.simple>|<def[selectedCuboid].max.simple> 'as:dregions_%world%_%name%'
      - run s@msgPrefixed delay:1t 'def:dRegions|<&f><&o>%name%<&7><&o> updated to selection'
      }
      else {
      - define ownerPlayers 'li@<player.uuid>'
      - inject s@dRegions p:createRegionEntry instantly
      - run s@msgPrefixed delay:1t 'def:dRegions|<&7><&o>Created %name% in %world%'
      }

  select:
  # /drg select [ID]
    - inject locally prerun instantly
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>There is an orphaned region by this name!'
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists].not> {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>There is no region by this name!'
      - queue clear
      }
    # Don't select global type regions
    - if <yaml[dRegions_%world%_regions].read[regions.%name%.type].is[==].to[global]||false> {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>You can not select global regions!'
      - queue clear
      }
    # Check if is owner
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>You are not an owner of this region!'
        - queue clear
        }
      }
    - define min '<yaml[dRegions_%world%_regions].read[regions.%name%.min].as_location.simple||null>'
    - define max '<yaml[dRegions_%world%_regions].read[regions.%name%.max].as_location.simple||null>'
    - flag <player> 'dWEWand_Type:cuboid'
    - flag <player> dWEWand:!
    - flag <player> dWEWand:|:%min%|%max%
    - run s@msgPrefixed delay:1t 'def:dRegions|<&7><&o>Selected <&f><&o>%name%'

  info:
  # /drg info [ID] -w world
    - inject locally prerun instantly
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>There is an orphaned region named %name%!'
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists].not> {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>There is no region by this name!'
      - queue clear
      }
    # Check if is owner
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>You are not an owner of this region!'
        - queue clear
        }
      }
    - inject locally regionInfo instantly

    - define title '<proc[msgCommand].context[<&6>dRegions|drg help|<&a>Go back to main help]>'
    - define subTitle '<&e>Region Info'
    - define command 'drg info %name%'
    - define entries 'li@<&7>Region<&co> <&e><proc[msgTrim].context[15|%name%]>  <&7>World<&co> <&e><proc[msgTrim].context[15|%world%]>'
    - define entries '<def[entries].include[<&7>Type<&co> <&f>%type%  <&7>Volume<&co> <&8><&lb><&f><&o>%size%<&8><&rb>]>'
    - define entries '<def[entries].include[<&7>Area<&co> <&8><&lb><&f><&o><def[pos1].split[,].remove[4].separated_by[,]> <&f><&o><def[pos2].split[,].remove[4].separated_by[,]><&8><&rb>]>'
    - define entries '<def[entries].include[<&7>Priority<&co> <&f><el@val[%priority%].pad_right[3]><&7>  Parent<&co> <&f>%parent%]>'
    - if <def[ownerPlayers].is_empty||true> && <def[ownerGroups].is_empty||true> {
      - define entries '<def[entries].include[<&7>Owners<&co> <&c>none]>'
      }
      else {
      - define entries '<def[entries].include[<&7>Owners<&co> <&f><def[ownerPlayers].parse[as_player.name].include[<def[ownerGroups].parse[replace[regex:^].with[<&b>]]||>].comma_separated>]>'
      }
    - if <def[memberPlayers].is_empty||true> && <def[memberGroups].is_empty||true> {
      - define entries '<def[entries].include[<&7>Members<&co> <&c>none]>'
      }
      else {
      - define entries '<def[entries].include[<&7>Members<&co> <&f><def[memberPlayers].parse[as_player.name].include[<def[memberGroups].parse[replace[regex:^].with[<&b>]]||>].comma_separated>]>'
      }
    - if <def[flags].is_empty> {
      - define entries '<def[entries].include[<&7>Flags<&co> <&c>none]>'
      }
      else {
      - define entries '<def[entries].include[<&7>Flags<&co>]>'
      - foreach '<def[flags].alphanumeric>' {
        - define flag '<def[value].split[/].get[1]>'
        - define flagVal '<def[value].after[/].strip_color>'
        - define entries '<def[entries].include[<&e.pad_left[3]>%flag%<&co> <&f><parse:%flagVal%>]>'
        }
      }

    - run s@msgBoxed 'def:dRegions|%title%|%subTitle%|%command%|%page%|52|14|<def[entries].separated_by[|]>'

  addowner:
  # /drg addowner [ID] g:group player
    - inject locally prerun instantly
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>There is an orphaned region by this name!'
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists].not> {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>There is no region by this name!'
      - queue clear
      }
    # Check if is owner
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>You are not an owner of this region!'
        - queue clear
        }
      }
    # Parse specified owners
    - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
      - define args '<c.args.remove[<c.args.find[-w].add[1].as_int>].exclude[-w]>'
      - define owners '<def[args].get[3].to[<def[args].size>].replace[:].with[;]||null>'
      }
      else {
      - define owners '<c.args.get[3].to[<c.args.size>].replace[:].with[;]||null>'
      }
    - if <def[owners].is_empty||true> {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Must specify at least one owner'
      - queue clear
      }
    - foreach %owners% {
      - if <def[value].starts_with[g;]||false> {
        - define group '<def[value].replace[g;]>'
        - if <server.list_permission_groups> !contains %group% {
          - run s@msgPrefixed delay:1t 'def:dRegions|<&c>%group% is not a valid group'
          - foreach next
          }
        - define groups '<yaml[dRegions_%world%_regions].read[regions.%name%.owners.groups]||li@>'
        - if <def[groups].contains[%group%]||false> {
          - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Group %group% is already an owner'
          - foreach next
          }
        - define pass true
        - yaml set 'regions.%name%.owners.groups:->:%group%' 'id:dRegions_%world%_regions'
        }
        else {
        - if !<def[value].as_player.is[!=].to[null]||false> {
          - foreach next
          }
        - define players '<yaml[dRegions_%world%_regions].read[regions.%name%.owners.players]||li@>'
        - if <def[players].contains[<def[value].as_player.uuid>]||false> {
          - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Player %value% is already an owner'
          - foreach next
          }
        - define pass true
        - yaml set 'regions.%name%.owners.players:->:<def[value].as_player.uuid>' 'id:dRegions_%world%_regions'
        - flag <def[value].as_player> 'dRegions.cache.%world%.%name%:!'
        }
      }
    - if <def[pass].exists||false> {
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - run s@msgPrefixed delay:1t 'def:dRegions|<&f><&o>%name%<&7><&o> owners updated'
      }

  removeowner:
  # /drg removeowner [ID] g:group player
    - inject locally prerun instantly
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>There is an orphaned region by this name!'
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists].not> {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>There is no region by this name!'
      - queue clear
      }
    # Check if is owner
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>You are not an owner of this region!'
        - queue clear
        }
      }
    # Parse specified owners
    - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
      - define args '<c.args.remove[<c.args.find[-w].add[1].as_int>].exclude[-w]>'
      - define owners '<def[args].get[3].to[<def[args].size>].replace[:].with[;]||null>'
      }
      else {
      - define owners '<c.args.get[3].to[<c.args.size>].replace[:].with[;]||null>'
      }
    - if <def[owners].is_empty||true> {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Must specify at least one owner'
      - queue clear
      }
    - foreach %owners% {
      - if <def[value].starts_with[g;]||false> {
        - define group '<def[value].replace[g;]>'
        - if <server.list_permission_groups> !contains %group% {
          - run s@msgPrefixed delay:1t 'def:dRegions|<&c>%group% is not a valid group'
          - foreach next
          }
        - define groups '<yaml[dRegions_%world%_regions].read[regions.%name%.owners.groups]||li@>'
        - if <def[groups].contains[%group%].not||true> {
          - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Group %group% is not an owner'
          - foreach next
          }
        - define pass true
        - yaml set 'regions.%name%.owners.groups:<-:%group%' 'id:dRegions_%world%_regions'
        }
        else {
        - if !<def[value].as_player.is[!=].to[null]||false> {
          - foreach next
          }
        - define players '<yaml[dRegions_%world%_regions].read[regions.%name%.owners.players]||li@>'
        - if <def[players].contains[<def[value].as_player.uuid>].not||true> {
          - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Player %value% is not an owner'
          - foreach next
          }
        - define pass true
        - yaml set 'regions.%name%.owners.players:<-:<def[value].as_player.uuid>' 'id:dRegions_%world%_regions'
        - flag <def[value].as_player> 'dRegions.cache.%world%.%name%:!'
        }
      }
    - if <def[pass].exists||false> {
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - run s@msgPrefixed delay:1t 'def:dRegions|<&f><&o>%name%<&7><&o> owners updated'
      }
      else {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&6><&o>%name%<&c><&o> owners not updated!'
      }

  addmember:
  # /drg addmember [ID] g:group player
    - inject locally prerun instantly
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>There is an orphaned region by this name!'
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists].not> {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>There is no region by this name!'
      - queue clear
      }
    # Check if is owner
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>You are not an owner of this region!'
        - queue clear
        }
      }
    # Parse specified members
    - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
      - define args '<c.args.remove[<c.args.find[-w].add[1].as_int>].exclude[-w]>'
      - define members '<def[args].get[3].to[<def[args].size>].replace[:].with[;]||null>'
      }
      else {
      - define members '<c.args.get[3].to[<c.args.size>].replace[:].with[;]||null>'
      }
    - if <def[members].is_empty||true> {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Must specify at least one member'
      - queue clear
      }
    - foreach %members% {
      - if <def[value].starts_with[g;]||false> {
        - define group '<def[value].replace[g;]>'
        - if <server.list_permission_groups> !contains %group% {
          - run s@msgPrefixed delay:1t 'def:dRegions|<&c>%group% is not a valid group'
          - foreach next
          }
        - define groups '<yaml[dRegions_%world%_regions].read[regions.%name%.members.groups]||li@>'
        - if <def[groups].contains[%group%]||false> {
          - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Group %group% is already a member'
          - foreach next
          }
        - define pass true
        - yaml set 'regions.%name%.members.groups:->:%group%' 'id:dRegions_%world%_regions'
        }
        else {
        - if !<def[value].as_player.is[!=].to[null]||false> {
          - foreach next
          }
        - define players '<yaml[dRegions_%world%_regions].read[regions.%name%.members.players]||li@>'
        - if <def[players].contains[<def[value].as_player.uuid>]||false> {
          - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Player %value% is already a member'
          - foreach next
          }
        - define pass true
        - yaml set 'regions.%name%.members.players:->:<def[value].as_player.uuid>' 'id:dRegions_%world%_regions'
        - flag <def[value].as_player> 'dRegions.cache.%world%.%name%:!'
        }
      }
    - if <def[pass].exists||false> {
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - run s@msgPrefixed delay:1t 'def:dRegions|<&f><&o>%name%<&7><&o> members updated'
      }
      else {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&6><&o>%name%<&c><&o> members not updated!'
      }

  removemember:
  # /drg reomvemember [ID] g:group player
    - inject locally prerun instantly
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>There is an orphaned region by this name!'
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists].not> {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>There is no region by this name!'
      - queue clear
      }
    # Check if is owner
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>You are not an owner of this region!'
        - queue clear
        }
      }
    # Parse specified members
    - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
      - define args '<c.args.remove[<c.args.find[-w].add[1].as_int>].exclude[-w]>'
      - define members '<def[args].get[3].to[<def[args].size>].replace[:].with[;]||null>'
      }
      else {
      - define members '<c.args.get[3].to[<c.args.size>].replace[:].with[;]||null>'
      }
    - if <def[members].is_empty||true> {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Must specify at least one member'
      - queue clear
      }
    - foreach %members% {
      - if <def[value].starts_with[g;]||false> {
        - define group '<def[value].replace[g;]>'
        - if <server.list_permission_groups> !contains %group% {
          - run s@msgPrefixed delay:1t 'def:dRegions|<&c>%group% is not a valid group'
          - foreach next
          }
        - define groups '<yaml[dRegions_%world%_regions].read[regions.%name%.members.groups]||li@>'
        - if <def[groups].contains[%group%].not||true> {
          - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Group %group% is not a member'
          - foreach next
          }
        - define pass true
        - yaml set 'regions.%name%.members.groups:<-:%group%' 'id:dRegions_%world%_regions'
        }
        else {
        - if !<def[value].as_player.is[!=].to[null]||false> {
          - foreach next
          }
        - define players '<yaml[dRegions_%world%_regions].read[regions.%name%.members.players]||li@>'
        - if <def[players].contains[<def[value].as_player.uuid>].not||true> {
          - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Player %value% is not a member'
          - foreach next
          }
        - define pass true
        - yaml set 'regions.%name%.members.players:<-:<def[value].as_player.uuid>' 'id:dRegions_%world%_regions'
        - flag <def[value].as_player> 'dRegions.cache.%world%.%name%:!'
        }
      }
    - if <def[pass].exists||false> {
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - run s@msgPrefixed delay:1t 'def:dRegions|<&f><&o>%name%<&7><&o> members updated'
      }
      else {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&6><&o>%name%<&c><&o> members not updated!'
      }

  list:
  # /drg list (page#) -r region -w world -p player

    - define args '<c.args.remove[1]>'
    # Check the specified player
    - if <def[args].find[-p].is[OR_MORE].than[0]||false> {
      - if !<player.permission[dregions.admin]||<player.is_op||false>> {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>You may not list other players regions!'
        - queue clear
        }
      - define player '<def[args].get[<def[args].find[-p].add[1].as_int>].escaped||null>'
      - if !<def[player].as_player.is[!=].to[null]||false> {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Invalid player specfied!'
        - queue clear
        }
      - define filterPlayer ''
      - define args '<def[args].remove[<def[args].find[-p].add[1].as_int>].exclude[-p]||li@>'
      }
      else {
      - if <context.server.not> {
        - define player '<player.name>'
        }
        else {
        - define player 'null'
        }
      }

    # Check the specified world
    - if <def[args].find[-w].is[OR_MORE].than[0]||false> {
      - define world '<def[args].get[<def[args].find[-w].add[1].as_int>].as_world.name.to_lowercase.escaped||null>'
      - if <def[world].is[==].to[null]||true> {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Invalid world specfied!'
        - queue clear
        }
      - define filterWorld ''
      - define args '<def[args].remove[<def[args].find[-w].add[1].as_int>].exclude[-w]||li@>'
      }
      else {
      - if <context.server.not> {
        - define world '<player.world.name.to_lowercase>'
        }
        else {
        - define world 'null'
        }
      }

    # Does the player want to list the regions where he stands?
    - if <def[args].find[-h].is[OR_MORE].than[0]||false> {
      - define filterHere ''
      - define args '<def[args].remove[<def[args].find[-h]>]||li@>'
      }

    # Do we want to show results for ALL worlds?
    - if <def[args].find[-a].is[OR_MORE].than[0]||false> {
      - define worlds '<server.list_worlds.parse[name.to_lowercase]>'
      - define getAll ''
      - define args '<def[args].remove[<def[args].find[-a]>]||li@>'
      }

    # Check the specified region name
    - if <def[args].find[-r].is[OR_MORE].than[0]||false> {
      - define region '<def[args].get[<def[args].find[-r].add[1].as_int>].escaped||null>'
      - if <def[region].is[!=].to[null]||true> {
        - define exists '<proc[dRegions_RegionExists].context[<def[region]>|<def[world]>]>'
        - if <def[exists].is[==].to[orphan]> {
          - run s@msgPrefixed delay:1t 'def:dRegions|<&c>There is an orphaned region by this name!'
          - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Please notify an admin!'
          - queue clear
          }
          else if <def[exists].not> {
          - run s@msgPrefixed delay:1t 'def:dRegions|<&c>There is no region by this name!'
          - queue clear
          }
        - if !<player.permission[dregions.admin]||<player.is_op||false>> {
          - if <proc[dRegions_IsOwner].context[<def[region]>|<def[world]>|<player>].not> {
            - run s@msgPrefixed delay:1t 'def:dRegions|<&c>You are not an owner of this region!'
            - queue clear
            }
          }
        }
        else {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>You must specify a valid region ID!'
        - queue clear
        }
      - define filterRegion ''
      - define args '<def[args].remove[<def[args].find[-r].add[1].as_int>].exclude[-r]||li@>'
      }

    # OK, we've validated all the user input, let's get the regions and apply filters
    - define regions li@
    - if <def[filterHere].exists> {
      - define standingIn '<player.location.cuboids.parse[notable_name].filter[split[_].get[1].is[==].to[dRegions]].parse[after[dregions_%world%_]].separated_by[,]>'
      - define worldRegions '<proc[dRegions_HighestPriority].context[%world%|%standingIn%]||li@>'
      - if <def[worldRegions].is_empty||true> {
        - define worldRegions 'li@__global__'
        }
      - inject locally filterRegionList
      }
      else if <def[getAll].exists> {
      - foreach %worlds% {
        - define world %value%
        - define worldRegions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
        - inject locally filterRegionList
        }
      }
      else {
      - define worldRegions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
      - inject locally filterRegionList
      }

    # Display the list
    - define page '<def[args].get[1].replace[-].escaped||1>'
    - define entries 'li@'
    - foreach '<def[regions]>':
      - define color '<t[<def[value].split[.].get[3].is[==].to[owner]>]:&6||<t[<def[value].split[.].get[3].is[==].to[member]>]:&e||&f>>'
      - define entry '<def[loop_index].pad_left[3].with[<&sp>]><&dot.pad_right[2].with[<&sp>]> <proc[msgCommand].context[<%color%><def[value].split[.].get[2]>|drg info <def[value].split[.].get[2]>|<&d>Click for region info]>'
      - define entries '<def[entries].include[%entry%]>'
    - run s@msgBoxed 'def:dRegions|<proc[msgCommand].context[<&6>dRegions|drg help|<&a>Go back to main help]>|<&e>Region List|drg list|%page%|52|10|<def[entries].separated_by[|]>'

#    - if <def[page].is[MATCHES].to[number].not> {
#      - define page '1'
#      }
#    - define pages '<def[regions].size.div[14].round_up||1>'
#    - if <def[page].is[MORE].than[%pages%]> {
#      - define page '%pages%'
#      }
#    - define highNumber '<def[page].mul[14].as_int>'
#    - define lowNumber '<def[highNumber].sub[13].as_int>'
#    - define msgsHeaderTitle '<&e>Region List   <el@val[<&7><&o>Page <&f><&o>%page% <&7><&o>of %pages%].pad_left[30]>'
#    - inject locally msgsHeader instantly
#    - foreach <def[regions].get[%lowNumber%].to[%highNumber%]||li@> {
#      - define color '<t[<def[value].split[/].get[3].is[==].to[owner]>]:&6||<t[<def[value].split[/].get[3].is[==].to[member]>]:&e||&f>>'
#      - narrate "<&5>|<&sp><&7><el@val[<el@val[<def[lowNumber].add[<def[loop_index].sub[1]>].as_int>.].pad_left[4].with[<&sp>]>].pad_right[5].with[<&sp>]> <%color%><def[value].split[/].get[2]>"
#      }
#    - narrate "<&5>|"
#    - inject locally msgsFooter instantly

  flag:
  # /drg flag [ID] [flag] [value] -g group -w world

    - define args '<c.args.remove[1]>'

    # Check the specified world
    - if <def[args].find[-w].is[OR_MORE].than[0]||false> {
      - define world '<def[args].get[<def[args].find[-w].add[1].as_int>].as_world.name.escaped.to_lowercase||null>'
      - if <def[world].is[==].to[null]||true> {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Invalid world specfied!'
        - queue clear
        }
      - define args '<def[args].remove[<def[args].find_all[-w].parse[add[1].as_int]>].exclude[-w]||li@>'
      }
      else {
      - if <context.server.not> {
        - define world '<player.world.name.to_lowercase>'
        }
        else {
        - define world 'null'
        }
      }

    # Check the specified group
    - if <def[args].find[-g].is[OR_MORE].than[0]||false> {
      - define group '<def[args].get[<def[args].find[-g].add[1].as_int>].escaped.to_lowercase||null>'
      - if !<el@val[members|nonmembers|owners|nonowners|all].as_list.contains[%group%]||false> {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c><def[group].unescaped> is an invalid group!'
        - queue clear
        }
      - define args '<def[args].remove[<def[args].find_all[-g].parse[add[1].as_int]>].exclude[-g]||li@>'
      }

    # Check the specified region name
    - define region '<def[args].get[1].escaped.to_lowercase||null>'
    - if <def[region].is[!=].to[null]||true> {
      - define exists '<proc[dRegions_RegionExists].context[<def[region]>|<def[world]>]>'
      - if <def[exists].is[==].to[orphan]> {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>There is an orphaned region by this name!'
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Please notify an admin!'
        - queue clear
        }
        else if <def[exists].not> {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>There is no region by this name!'
        - queue clear
        }
      - if !<player.permission[dregions.admin]||<player.is_op||false>> {
        - if <proc[dRegions_IsOwner].context[<def[region]>|<def[world]>|<player>].not> {
          - run s@msgPrefixed delay:1t 'def:dRegions|<&c>You are not an owner of this region!'
          - queue clear
          }
        }
      }
      else {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>You must specify a valid region ID!'
      - queue clear
      }

    # Check the specified flag name
    - define flag '<def[args].get[2].escaped.to_lowercase||null>'
    - if <def[flag].is[!=].to[null]||true> {
      - define flags '<server.list_scripts.filter[starts_with[s@dRegions_Flag_]].parse[name.split[_].get[3]]||li@>'
      - if !<def[flags].contains[%flag%]||false> {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>You must specify a valid region flag!'
        - queue clear
        }
      }
      else {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>You must specify a valid region flag!'
      - queue clear
      }

    # By this point, we know the flag is being set or cleared, so let's clear the flag
    # cache for this region, any child regions, and any overlapping regions including __global__
    - run s@dRegions p:clearCache delay:1t 'def:%region%|%world%|%flag%'

    # Check the specified flag value and set or clear it.
    - define flagValue '<def[args].get[3].to[<def[args].size>].space_separated.escaped||null>'
    - if <def[flagValue].is[!=].to[null]||true> {
      - define type '<s@dRegions_Flag_%flag%.yaml_key[flag_type]>'
      - if <def[type].is[==].to[location]> {
        - if <def[flagValue].is[==].to[here]||true> {
          - define flagValue '<player.location.simple>'
          }
        }
      - define typeMatch '<proc[dRegion_FlagTypeMatch].context[%flagValue%|%flag%]>'
      - if !<def[TypeMatch]> {
        - define lines '<proc[dRegions_LineWrap].context[<s@dRegions_Flag_%Flag%.yaml_key[flag_help]||<&c>%flag% flag requires a %type% value!>|45]>'
        - foreach <def[lines]> {
          - run s@msgPrefixed delay:1t 'def:dRegions|<&c><def[value]>'
          }
        - queue clear
        }
      - if <def[type].starts_with[state]||false>
        && <def[flagValue].is[==].to[none]||false> {
        - inject s@dRegions_Flag_%flag% p:command_handler
        - yaml set 'regions.%region%.flags.%flag%:!' 'id:dRegions_%world%_regions'
        - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
        - yaml 'savefile:dRegions/worlds/%world%/cache.yml' 'id:dRegions_%world%_cache'
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Cleared %flag% flag for region %region%'
        - queue clear
        }
      - inject s@dRegions_Flag_%flag% p:command_handler
      - if <s@dRegions_Flag_%flag%.yaml_key[flag_takeGroup]||false> {
        - if <def[group].exists> {
          - yaml set 'regions.%region%.flags.%flag%:<def[flagValue].unescaped>/%group%' 'id:dRegions_%world%_regions'
          }
          else {
          - yaml set 'regions.%region%.flags.%flag%:<def[flagValue].unescaped>' 'id:dRegions_%world%_regions'
          }
        }
        else {
        - yaml set 'regions.%region%.flags.%flag%:<def[flagValue].unescaped>' 'id:dRegions_%world%_regions'
        }
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - define string "<&f><&o>%region%<&7><&o> set %flag% flag to <&f><&o>%flagValue%"
      - define lines '<proc[dRegions_LineWrap].context[<def[string]>|45]>'
      - foreach <def[lines]> {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&f><&o><def[value].unescaped>'
        }
      }
      else {
      - inject s@dRegions_Flag_%flag% p:command_handler
      - yaml set 'regions.%region%.flags.%flag%:!' 'id:dRegions_%world%_regions'
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Cleared %flag% flag for region %region%'
      - queue clear
      }

  setpriority:
  # /drg setpriority [ID] [#]
    - inject locally prerun instantly
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>There is an orphaned region by this name!'
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists].not> {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>There is no region by this name!'
      - queue clear
      }
    # Check if is owner
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>You are not an owner of this region!'
        - queue clear
        }
      }
    # Verify specified priority
    - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
      - define args '<c.args.remove[<c.args.find[-w].add[1].as_int>].exclude[-w]>'
      - define priority '<def[args].get[3].escaped||null>'
      }
      else {
      - define priority '<c.args.get[3].escaped||null>'
      }
    - if <def[priority].is[matches].to[number].not||true> {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Must specify a numeric value for priority'
      - queue clear
      }
    # Update region
    - yaml set 'regions.%name%.priority:%priority%' 'id:dRegions_%world%_regions'
    - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
    - run s@msgPrefixed delay:1t 'def:dRegions|<&f><&o>%name%<&7><&o> set priority to <&f><&o>%priority%'

  setparent:
  # /drg setparent [ID] [parent]
    - inject locally prerun instantly
    # Check if child region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>There is an orphaned region by this name!'
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists].not> {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>There is no region by this name!'
      - queue clear
      }
    # Check if is owner
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>You are not an owner of this region!'
        - queue clear
        }
      }
    # Check if parent region exists
    - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
      - define args '<c.args.remove[<c.args.find[-w].add[1].as_int>].exclude[-w]>'
      - define parent '<def[args].get[3].escaped||null>'
      }
      else {
      - define parent '<c.args.get[3].escaped||null>'
      }
    - if %parent% == null {
      - define parent <yaml[dRegions_%world%_regions].read[regions.%name%.parent]||null>
      - if %parent% != null {
        - yaml set 'regions.%parent%.children:<-:%name%' 'id:dRegions_%world%_regions'
        }
      - yaml set 'regions.%name%.parent:!' 'id:dRegions_%world%_regions'
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - run s@msgPrefixed delay:1t 'def:dRegions|<&7><&o>Unset parent for <&f><&o>%name%'
      - queue clear
      }
    # Check if parent region exists
    - define exists '<proc[dRegions_RegionExists].context[%parent%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>There is an orphaned region by this name!'
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists].not> {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>There is no region by this name!'
      - queue clear
      }
    # Check if player owns parent
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%parent%|%world%|<player>].not> {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>You are not an owner of this region!'
        - queue clear
        }
      }
    # Update the region
    - yaml set 'regions.%name%.parent:%parent%' 'id:dRegions_%world%_regions'
    - if <yaml[dRegions_%world%_regions].read[regions.%parent%.children]||li@> contains %name% {
      - yaml set 'regions.%parent%.children:<-:%name%' 'id:dRegions_%world%_regions'
      }
      else {
      - yaml set 'regions.%parent%.children:->:%name%' 'id:dRegions_%world%_regions'
      }
    - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
    - run s@msgPrefixed delay:1t 'def:dRegions|<&f><&o>%name%<&7><&o> set parent to <&f><&o>%parent%'

  teleport:
  # /drg teleport [ID] -w world
    - narrate "Stub"
    - inject locally prerun instantly
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists]> == orphan {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>There is an orphaned region by this name!'
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Please notify an admin!'
      - queue clear
      }
      else if !%exists% {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>There is no region by this name!'
      - queue clear
      }
    # Check if is owner
    - if !<player.permission[dregions.admin]||false> && !<player.is_op> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>You are not an owner of this region!'
        - queue clear
        }
      }
    # Check for teleport perms
    - if !<player.permission[dregions.teleport]||false> && !<player.permission[dregions.teleport.own]||false> && !<player.permission[dregions.teleport.own.%name%]||false> {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>You do not have permission!'
      - queue clear
      }

  remove:
  # /drg remove [ID] -w world
    - inject locally prerun instantly
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>There is an orphaned region by this name!'
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Please notify an admin!'
      - queue clear
      }
      else if <def[exists].not> {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>There is no region by this name!'
      - queue clear
      }
    # Don't remove the __global__ region
    - if <def[name].is[==].to[__global__]> {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>You can not remove the __global__ region!'
      - queue clear
      }
    # Check if is owner
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>You are not an owner of this region!'
        - queue clear
        }
      }
    # Remove region from ancestry
    # This should be done smarterer now since regions know both children and parents.
    - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__]||li@>'
    - foreach %regions% {
      - if <yaml[dRegions_%world%_regions].read[regions.%value%.parent]||null> == %name% {
        - yaml set 'regions.%value%.parent:<-:%name%' 'id:dRegions_%world%_regions'
        }
      - if <yaml[dRegions_%world%_regions].read[regions.%value%.children]||li@> contains %name% {
        - yaml set 'regions.%value%.children:<-:%name%' 'id:dRegions_%world%_regions'
        }
      }
    # Remove the region
    - yaml set 'regions.%name%:!' 'id:dRegions_%world%_regions'
    - note remove 'as:dregions_%world%_%name%'
    - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
    - run s@msgPrefixed delay:1t 'def:dRegions|<&f><&o>%name%<&7><&o> has been removed from <&f><&o>%world%'

#
#  END dRegions Command Arguments
#--------------------------------------
#
#  dRegions Command Utilities
#
# Just some commonly used code blocks
#
  prerun:
  # Block of checks run before /most/ commands
    - if !<player.permission[dRegions.%command%]||false> && !<player.is_op> {
      - inject locally help
      - queue clear
      }
    - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
      - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||null>'
      - if <def[world].is[==].to[null]||true> {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Invalid world specfied!'
        - run s@msgPrefixed delay:1t 'def:dRegions|<script.yaml_key[commandArgs.%command%.usage]>'
        - queue clear
        }
      - define args '<c.args.remove[<c.args.find[-w].add[1].as_int>].exclude[-w]>'
      - define name '<def[args].get[2].escaped.to_lowercase||null>'
      }
      else {
      - define world '<player.world.name.to_lowercase>'
      }
    - if <li@define|redefine|claim.contains[%command%]> {
      - define wandType '<player.flag[dWEWand_Type]||cuboid>'
      - if <li@cuboid|extender.contains[%wandType%].not||true> {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>You must select a cuboid type region!'
        - run s@msgPrefixed delay:1t 'def:dRegions|<script.yaml_key[commandArgs.%command%.usage]>'
        - queue clear
        }
      - define pos1 '<player.flag[dWEWand].get[1].as_location||null>'
      - define pos2 '<player.flag[dWEWand].get[2].as_location||null>'
      - if <def[pos1].is[==].to[null]>
        || <def[pos2].is[==].to[null]> {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>No region selected!'
        - run s@msgPrefixed delay:1t 'def:dRegions|<script.yaml_key[commandArgs.%command%.usage]>'
        - queue clear
        }
      - if <def[pos1].world.name.is[!=].to[%world%]>
        || <def[pos2].world.name.is[!=].to[%world%]> {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Selected region not within specified world!'
        - run s@msgPrefixed delay:1t 'def:dRegions|<script.yaml_key[commandArgs.%command%.usage]>'
        - queue clear
        }
      - define selectedCuboid '<cu@%pos1%|%pos2%>'
      }
    - define name '<def[name]||<c.args.get[2].escaped.to_lowercase||null>>'
    - if '<def[name].is[==].to[null]||true>' {
      - if <li@info|select.contains[%command%]> {
        - define dRegions '<player.location.cuboids.parse[notable_name].filter[split[_].get[1].is[==].to[dRegions]].parse[after[dregions_%world%_]].separated_by[,]>'
        - define orderedRegions '<proc[dRegions_HighestPriority].context[%world%|%dRegions%]>'
        - if <def[orderedRegions].is_empty||true> {
          - define name '__global__'
          }
          else {
          - define name '<def[orderedRegions].get[1]>'
          - if <def[orderedRegions].size.is[MORE].than[1]> {
            - run s@msgPrefixed delay:1t 'def:dRegions|<&c><&o>There are multiple regions at this location!'
            - run s@msgPrefixed delay:1t 'def:dRegions|<&7><&o>Getting highest priority region info.'
            }
          }
        }
        else {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>You must specify a region ID!'
        - run s@msgPrefixed delay:1t 'def:dRegions|<script.yaml_key[commandArgs.%command%.usage]>'
        - queue stop
        }
      }
    - if '<def[name].matches[^[a-z0-9-_]+$].not>' {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Region ID may only contain letters, numbers,'
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>hyphen, and underscore!'
      - run s@msgPrefixed delay:1t 'def:dRegions|<script.yaml_key[commandArgs.%command%.usage]>'
      - queue stop
      }
    - define page "<t[<c.args.filter[is[matches].to[number]].is_empty.not>]:<c.args.filter[is[matches].to[number]].get[1]>||1>"
#    - inject s@dRegions_Commands p:selection_Size instantly
#    - define oldSize '%size%'


  filterRegionList:
  # Used in /drg list to apply various filters
    - if <def[filterRegion].exists||false> {
      - define filteredRegions 'li@'
      - foreach %worldRegions% {
        - define worldRegion '%value%'
        - if <yaml[dRegions_%world%_regions].read[regions.%worldRegion%.parent].is[==].to[<def[region]>]||false> {
          - define filteredRegions '<def[filteredRegions].include[%worldRegion%]||<def[filteredRegions]>>'
          }
        }
      }
    - if <def[filteredRegions].exists> {
      - define worldRegions '<def[filteredRegions]>'
      }
    - foreach %worldRegions% {
      - define worldRegion '%value%'
      - if <proc[dRegions_IsOwner].context[<def[worldRegion]>|<def[world]>|<def[player].as_player>]||false> {
        - define regions '<def[regions].include[<def[world]>.<def[worldRegion]>.owner]||<def[regions]>>'
        }
        else if <proc[dRegions_IsMember].context[<def[worldRegion]>|<def[world]>|<def[player].as_player>]||false> {
        - define regions '<def[regions].include[<def[world]>.<def[worldRegion]>.member]||<def[regions]>>'
        }
        else if <def[filterPlayer].exists.not||true> {
        - define regions '<def[regions].include[<def[world]>.<def[worldRegion]>.nonmember]||<def[regions]>>'
        }
      }

  regionInfo:
  # Build the data set for region info
    - define type '<yaml[dRegions_%world%_regions].read[regions.%name%.type]||null>'
    - if <def[type].is[==].to[cuboid]||false> {
      - define POS1 '<yaml[dRegions_%world%_regions].read[regions.%name%.min]||null>'
      - define POS2 '<yaml[dRegions_%world%_regions].read[regions.%name%.max]||null>'
      - define size '<proc[selectionSize].context[%pos1%|%pos2%]>'
      }
      else if <def[type].is[==].to[global]||false> {
      - define POS1 '0,0,0,%world%'
      - define POS2 '0,0,0,%world%'
      - define size 'infinite'
      }
      else {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>This region is misconfigured!'
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Notify an Admin!'
      - queue clear
      }
    - define priority '<yaml[dRegions_%world%_regions].read[regions.%name%.priority]||0>'
    - define parent '<yaml[dRegions_%world%_regions].read[regions.%name%.parent]||<&c>none>'
    - define ownerGroups '<yaml[dRegions_%world%_regions].read[regions.%name%.owners.groups]||li@>'
    - define ownerPlayers '<yaml[dRegions_%world%_regions].read[regions.%name%.owners.players]||li@>'
    - define memberGroups '<yaml[dRegions_%world%_regions].read[regions.%name%.members.groups]||li@>'
    - define memberPlayers '<yaml[dRegions_%world%_regions].read[regions.%name%.members.players]||li@>'
    - define flagList '<yaml[dRegions_%world%_regions].list_keys[regions.%name%.flags]||li@>'
    - define flags 'li@'
    - foreach %flagList% {
      - define flags '<def[flags].include[%value%/<yaml[dRegions_%world%_regions].read[regions.%name%.flags.%value%].as_list.comma_separated||null>]||%flags%>'
      }

#
#  END dRegions dRegions Command Utilities
#--------------------------------------
#
#  dRegions Command Messages
#
# Some messages used by commands. Should probably move to s@dRegions_Msg
#
  msgsHeader:
    - narrate "<&5>|----------------------------------------|"
    - narrate "<&5>|<&sp><&sp><&sp><&6>dRegions   <&7><def[msgsHeaderTitle]||>"
    - narrate "<&5>|<&f>"

  msgsFooter:
#    - define anthony "text<&co>'<&7>|Anthony|',clickEvent<&co><&chr[007B]>action<&co>open_url,value<&co>'http<&co>//mineconomy.org'<&chr[007D]>,hoverEvent<&co><&chr[007B]>action<&co>show_item,value<&co>'<&chr[007B]><i@dRegions_Author_Anthony.json><&chr[007D]>'<&chr[007D]>"
#    - define spacer "text<&co>'  '"
#    - define prefix "text<&co>'<&5>|  <&f>Authors<&co>  '"
    - if <player.is_player||false> {
# JSON is broken in denizen. Just narrate for now.
      - narrate "<&5>|  <&f>Authors<&co>  <&7>|Anthony|"
#      - execute as_server "tellraw <player.name> <&chr[007B]>text<&co>'',extra<&co>[<&chr[007B]>%prefix%<&chr[007D]>,<&chr[007B]>%anthony%<&chr[007D]>]<&chr[007D]>"
      }
      else {
      - announce to_console "<&5>|  <&f>Authors<&co>    <&7>|Anthony|"
      }
    - narrate "<&5>|-----------<&d>S<&5>-<&d>c<&5>-<&d>r<&5>-<&d>o<&5>-<&d>l<&5>-<&d>l<&5>---<&d>U<&5>-<&d>p<&5>-------------|"

  msgsHelpAdmin:
    # Filter the list of commands this player can use
    - define commands '<script.list_keys[commandArgs].alphanumeric.to_lowercase||li@>'
    - foreach %commands% {
      - if !<player.permission[dregions.%value%]||<player.is_op||<c.server||false>>> {
        - define commands '<def[commands].exclude[%value%]>'
        }
        else {
        - foreach next
        }
      }

    # Display the list
    - define page '<def[arg].replace[-].escaped||1>'
    - if <def[page].is[MATCHES].to[number].not> {
      - define page '1'
      }
    - define pages '<def[commands].size.div[5].round_up||1>'
    - if <def[page].is[MORE].than[%pages%]> {
      - define page '%pages%'
      }
    - define highNumber '<def[page].mul[5].as_int>'
    - define lowNumber '<def[highNumber].sub[4].as_int>'
    - define msgsHeaderTitle '<&e>Admin Help   <el@val[<&7><&o>Page <&f><&o>%page% <&7><&o>of %pages%].pad_left[30]>'
    - inject locally msgsHeader instantly
    - foreach <def[commands].get[%lowNumber%].to[%highNumber%]||li@> {
      - narrate "<&5>|<&sp><&sp><&f><def[value].to_titlecase><&co>"
      - narrate "<&5>|<&sp><&sp><&sp><&sp><&7><parse:<script.yaml_key[commandArgs.%value%.usage]||No usage info available!>>"
      }
    - narrate "<&5>|"

  msgsHelpUser:
    - define msgsHeaderTitle 'User Help'
    - inject locally msgsHeader instantly
    - define par1 "dRegions is an advanced region management and world protection system written with the Denizen Scripting Engine."
    - define par2 "Heavily inspired by WorldGuard, the goal is to have an extremely efficient events system supporting an exhaustive set of region flags and configuration options."
    - define par3 "dRegions offers an intuitive command interface and provides thorough TAB completion."
    - define strings "<el@val[%par1%|%par2%|%par3%].as_list>"
    - foreach <def[strings]> {
      - define string "<&f><&sp><def[value]>"
      - define lines '<proc[dRegions_LineWrap].context[<def[string]>|44]>'
      - foreach <def[lines]> {
        - narrate "<&5>|<&f><&sp><&sp><def[value].unescaped>"
        }
      - narrate "<&5>|"
      }

#
#  END dRegions Command Messages
#
#--------------------------------------
#
# Used to process input for some flags
#
dRegions_Flags_CommandProcessors:
  type: task
  speed: 0
  debug: false

  command_verifiedList:
    - if <def[flagValue].is[==].to[null]||false> {
      - yaml set 'regions.%region%.flags.%flag%:!' 'id:dRegions_%world%_regions'
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Cleared %flag% list for region %region%'
      - queue clear
      }
      else {
      - define entries '<def[flagValue].split[ ].get[2].to[<def[flagValue].split[ ].size>].parse[to_lowercase].deduplicate||li@>'
      - if <def[entries].get[1].is[==].to[all]> {
        - if '<def[flagValue].split[ ].get[1].is[==].to[-a]||false>' {
          - yaml set 'regions.%region%.flags.%flag%:all' 'id:dRegions_%world%_regions'
          - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
          - run s@msgPrefixed delay:1t 'def:dRegions|<&f><&o>%region%<&7><&o> set %flag% flag to <&f><&o>%flagValue%'
          - queue clear
          }
        - if '<def[flagValue].split[ ].get[1].is[==].to[-r]||false>' {
          - yaml set 'regions.%region%.flags.%flag%:!' 'id:dRegions_%world%_regions'
          - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
          - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Cleared %flag% list for region %region%'
          - queue clear
          }
        }
      - foreach %entries% {
        - if <parse:<s@dRegions_Flag_%Flag%.yaml_key[command_verifyEntry]||false>> {
          - define entries '<def[entries].exclude[%value%]||li@>'
          - run s@msgPrefixed delay:1t 'def:dRegions|<&c><&o>%value% is not a valid <s@dRegions_Flag_%Flag%.yaml_key[command_entryType]>!'
          }
        }
      - if <def[entries].is_empty||true> {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c><&o>No valid <s@dRegions_Flag_%Flag%.yaml_key[command_entryType]>s specified!'
        - define lines '<proc[dRegions_LineWrap].context[<s@dRegions_Flag_%Flag%.yaml_key[flag_help]||<&c>%flag% flag requires a %type% value!>|45]>'
        - foreach <def[lines]> {
          - run s@msgPrefixed delay:1t 'def:dRegions|<&c><def[value]>'
          }
        - queue clear
        }

      - define currentEntries '<yaml[dRegions_%world%_regions].read[regions.%region%.flags.%flag%].replace[, ].with[|].as_list||li@>'
      - if '<def[flagValue].split[ ].get[1].is[==].to[-a]||false>' {
        - define flagValue '<def[currentEntries].include[<def[entries].replace[li@]>].deduplicate||li@>'
        }
      - if '<def[flagValue].split[ ].get[1].is[==].to[-r]||false>' {
        - define flagValue '<def[currentEntries].exclude[<def[entries].replace[li@]>].deduplicate||li@>'
        }
      - if <def[flagValue].is_empty||true> {
        - yaml set 'regions.%region%.flags.%flag%:!' 'id:dRegions_%world%_regions'
        - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Cleared %flag% list for region %region%'
        - queue clear
        }
      - define flagValue '<def[flagValue].comma_separated>'
      }


  command_stringList:
    - if <def[flagValue].is[==].to[null]||false> {
      - yaml set 'regions.%region%.flags.%flag%:!' 'id:dRegions_%world%_regions'
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Cleared %flag% list for region %region%'
      - queue clear
      }
    - define action '<def[flagValue].split[ ].get[1]>'
    - define string '<def[flagValue].after[<def[action]>]>'

    - if '<def[string].is[==].to[all]>' {
      - if <def[action].is[==].to[-a]||false> {
        - yaml set 'regions.%region%.flags.%flag%:all' 'id:dRegions_%world%_regions'
        - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
        - run s@msgPrefixed delay:1t 'def:dRegions|<&f><&o>%region%<&7><&o> set %flag% flag to <&f><&o>%flagValue%'
        - queue clear
        }
      - if <def[action].is[==].to[-r]||false> {
        - yaml set 'regions.%region%.flags.%flag%:!' 'id:dRegions_%world%_regions'
        - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Cleared %flag% list for region %region%'
        - queue clear
        }
      }
    - if <def[string].length.is[==].to[0]||true> {
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c><&o>No valid <s@dRegions_Flag_%Flag%.yaml_key[command_entryType]>s specified!'
      - define lines '<proc[dRegions_LineWrap].context[<s@dRegions_Flag_%Flag%.yaml_key[flag_help]||<&c>%flag% flag requires a %type% value!>|45]>'
      - foreach <def[lines]> {
        - run s@msgPrefixed delay:1t 'def:dRegions|<&c><def[value]>'
        }
      - queue clear
      }

    - define currentEntries '<yaml[dRegions_%world%_regions].read[regions.%region%.flags.%flag%].replace[ ; ].with[|].as_list||li@>'
    - if '<def[action].is[==].to[-a]||false>' {
      - define flagValue '<def[currentEntries].include[<def[string]>].deduplicate||li@>'
      }
    - if '<def[action].is[==].to[-r]||false>' {
      - define flagValue '<def[currentEntries].exclude[<def[string]>].deduplicate||li@>'
      }
    - if <def[flagValue].is_empty||true> {
      - yaml set 'regions.%region%.flags.%flag%:!' 'id:dRegions_%world%_regions'
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - run s@msgPrefixed delay:1t 'def:dRegions|<&c>Cleared %flag% list for region %region%'
      - queue clear
      }
    - define flagValue '<def[flagValue].replace[|].with[ ; ].replace[li@]>'


################################################################################
#
#  FlagTypeMatch Procedure script
#
#    Used to check that the player specified value matches the type required
#   by the flag.
#
#    Use this to compare 2 values. Check if they are one of NUMBER, DECIMAL,
#   LOCATION, BOOLEAN, STATE, GROUP, LIST or any other STRING.
#
#   usage:
#     - define YourValue "Some string"
#     - define Type "<s@dRegions_Flag_%flag%.yaml_key[flag_type]||null>"
#     - define TypeMatch '<proc[dRegion_FlagTypeMatch].context[%YourValue%|%flag%]>'
#     - if <def[TypeMatch]> {
#       - narrate "%YourValue% matches %type%."
#       }
#       else {
#       - narrate "%YourValue% is not a %type%"
#       }
#
dRegion_FlagTypeMatch:
# Used to check if the value supplied when setting a flag is valid for the flag type.
  type: procedure
  debug: false
  definitions: YourValue|Flag

  script:
    - choose '<s@dRegions_Flag_%Flag%.yaml_key[flag_type]||null>':
      - case 'number':
        - determine '<def[YourValue].is[MATCHES].to[number]>'
      - case 'decimal':
        - determine '<def[YourValue].is[MATCHES].to[number]>.and[<def[YourValue].as_int.is[==].to[%YourValue%]>]>'
      - case 'b':
        - determine '<def[YourValue].is[MATCHES].to[boolean]>'
      - case 'location':
        - determine '<def[YourValue].as_location.world.is[!=].to[null]||false>'
      - case 'stg':
        - determine '<li@allow|deny|none.contains[%YourValue%]||false>'
      - case 'st':
        - determine '<li@allow|deny|none.contains[%YourValue%]||false>'
      - case 'sg':
        - determine '<li@allow|deny|none.contains[%YourValue%]||false>'
      - case 'stsg':
        - determine '<li@allow|deny|none.contains[%YourValue%]||false>'
      - case 'group':
        - determine '<li@members|nonmembers|owners|nonowners|all.as_list.contains[%YourValue%]||false>'
      - case 'list':
        - determine '<def[YourValue].split[ ].get[1].contains_any_text[-a|-r]||false>'
      - case 'custom':
        - determine '<s@dRegions_Flag_%flag%.yaml_key[flag_type_customVal].as_list.contains[%YourValue%]||false>'
      - case 'string':
        - determine '<def[YourValue].is[!=].to[null]||false>'
      - default:
        - determine 'false'

#
