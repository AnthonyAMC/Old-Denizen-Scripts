################################################################################
#
#  dRegions Command Script Container
#
# This script covers all dRegions commands
#
# I haven't examined this in great detail since dRegions 0.2x. It's probably
# due for some revisions
#
#--------------------------------------
#
#  dRegions Command Script Basics
#
# The basic stuff required in a command script container
#
dRegions_Commands:
  type: command
  debug: false
  name: dregions
  description: Denizen Regions Manager
  usage: /dregions
  aliases:
  - drg
  allowed help:
  - determine true

  commandArgs:
    help:
      usage: '/drg help <&lt>arg/<&ns><&gt>'
      permissions: []
    about:
      usage: '/drg about'
      permissions: []
    reload:
      usage: '/drg reload'
      permissions:
        - dregions.reload
    restart:
      usage: '/drg restart'
      permissions:
        - dregions.restart
    define:
      usage: '/drg define [ID] (g:group) (player)'
      permissions:
        - dregions.define
    redefine:
      usage: '/drg redefine [ID]'
      permissions:
        - dregions.redefine
        - dregions.redefine.own.*
        - dregions.redefine.own.%region%
        - dregions.redefine.member.*
        - dregions.redefine.member.%region%
    claim:
      usage: '/drg claim [ID]'
      permissions: []
    select:
      usage: '/drg select [ID] -w world'
      permissions: []
    info:
      usage: '/drg info [ID] -w world'
      permissions:
        - dregions.info
        - dregions.info.own.*
        - dregions.info.own.%region%
        - dregions.info.member.*
        - dregions.info.member.%region%
    addowner:
      usage: '/drg addowner [ID] g:group player -w world'
      permissions:
        - dregions.addowner
        - dregions.addowner.own.*
        - dregions.addowner.own.%region%
        - dregions.addowner.member.*
        - dregions.addowner.member.%region%
    removeowner:
      usage: '/drg removeowner [ID] g:group player -w world'
      permissions:
        - dregions.removeowner
        - dregions.removeowner.own.*
        - dregions.removeowner.own.%region%
        - dregions.removeowner.member.*
        - dregions.removeowner.member.%region%
    addmember:
      usage: '/drg addmember [ID] g:group player -w world'
      permissions:
        - dregions.addmember
        - dregions.addmember.own.*
        - dregions.addmember.own.%region%
        - dregions.addmember.member.*
        - dregions.addmember.member.%region%
    removemember:
      usage: '/drg removemember [ID] g:group player -w world'
      permissions:
        - dregions.removemember
        - dregions.removemember.own.*
        - dregions.removemember.own.%region%
        - dregions.removemember.member.*
        - dregions.removemember.member.%region%
    list:
      usage: '/drg list (page<&ns>) -h -r region -w world -p player'
      permissions:
        - dregions.list
        - dregions.list.own.*
        - dregions.list.own.%region%
        - dregions.list.member.*
        - dregions.list.member.%region%
    flag:
      usage: '/drg flag [ID] [flag] [value] -g group -w world'
      permissions:
        - dregions.flags.*
        - dregions.flags.<def[flag]>
        - dregions.flag
        - dregions.flag.flags.*
        - dregions.flag.flags.<def[flag]>
        - dregions.flag.own.*
        - dregions.flag.own.<def[region]>
        - dregions.flag.member.*
        - dregions.flag.member.<def[region]>
    setpriority:
      usage: '/drg setpriority [ID] [<&ns>]'
      permissions:
        - dregions.setpriority
        - dregions.setpriority.own.*
        - dregions.setpriority.own.%region%
        - dregions.setpriority.member.*
        - dregions.setpriority.member.%region%
    setparent:
      usage: '/drg setparent [ID] [parent]'
      permissions:
        - dregions.setparent
        - dregions.setparent.own.*
        - dregions.setparent.own.%region%
        - dregions.setparent.member.*
        - dregions.setparent.member.%region%
    teleport:
      usage: '/drg teleport [ID] -w world'
      permissions:
        - dregions.teleport
        - dregions.teleport.own.*
        - dregions.teleport.own.%region%
        - dregions.teleport.member.*
        - dregions.teleport.member.%region%
    remove:
      usage: '/drg remove [ID] -w world'
      permissions:
        - dregions.remove
        - dregions.remove.own.*
        - dregions.remove.own.%region%
        - dregions.remove.member.*
        - dregions.remove.member.%region%
    wgimport:
      usage: '/drg wgimport [world(s)] (-a)'
      permissions:
        - dregions.wgimport
    tool:
      usage: '/drg tool [type]'
      permissions:
        - dregions.tool.*
        - dregions.tool.%tool%

  tab complete:
    - define args '<script.list_keys[commandArgs].alphanumeric.to_lowercase||li@>'
    - define arg '<c.args.get[1]||null>'
    - if <def[arg].is[==].to[null]>
      || !<def[args].contains[%arg%]> {
      - inject locally tab_arg_1
      }
      else {
      - inject locally tab_%arg%
      }
    - determine '<def[result]||li@>'

  script:
    - define command '<c.args.get[1].escaped||help>'
    - define args '<script.list_keys[commandArgs].alphanumeric.to_lowercase||li@>'
    - if !<def[args].contains[%command%]> {
      - inject locally help
      }
      else {
      - inject locally %command%
      }


#
#  END dRegions Command Script Basics
#--------------------------------------
#
#  dRegions Command TAB Completion
#
# Each of these subscripts handles TAB completion for the positional argument.
#
#
  tab_arg_1:
    # This Excludes args from the original args
    - foreach %args% {
      - if !<player.permission[dregions.%value%]||<player.is_op||false>> {
        - define args '<def[args].exclude[%value%]||%args%>'
        }
      }
    - if <def[args].is_empty||true> {
      - define result 'li@'
      }
      else {
      - define result '<def[args].filter[starts_with[%arg%]]||li@>'
      - if <def[result].is_empty||true> {
        - define result '%args%'
        }
      }

  tab_help:
    - define spaces '<c.raw_args.to_list.count[ ]||0>'
    - if <def[spaces].is[==].to[0]> {
      - define result 'help [command]'
      }
      else if <def[spaces].is[==].to[1]> {
      - define result 'li@'
      - foreach %args% {
        - if <player.permission[dregions.%value%]||<player.is_op||false>> {
          - define result '<def[result].include[%value%]||%result%>'
          }
          else {
          - foreach next
          }
        }
      - if <c.args.get[2].is[!=].to[null]||false> {
        - define result '<def[args].filter[starts_with[<c.args.get[2]>]]||li@>'
        - if <def[result].is_empty> {
          - foreach %args% {
            - if <player.permission[dregions.%value%]||<player.is_op||false>> {
              - define result '<def[result].include[%value%]||%result%>'
              }
              else {
              - foreach next
              }
            }
          }
        }
      }

  tab_about:
    - define result 'li@'

  tab_reload:
    - define result 'li@'

  tab_restart:
    - define result 'li@'

  tab_define:
  # /drg define [ID] (g:group) (player)
    - if <player.permission[dregions.define]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - if <def[spaces].is[==].to[0]> {
        - define result 'define [ID]'
        }

        else if <def[spaces].is[==].to[1]> {
        - if <c.args.get[2].is[==].to[null]||true> {
          - define result '[ID] (g:group) (player)'
          }
          else {
          - define result '<c.args.get[2]> (g:group) (player)'
          }
        }

        else if <def[spaces].is[OR_MORE].than[2]> {
        - define owners '<c.args.remove[1|2]||li@>'
        - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
          - define owners '<def[owners].remove[<def[owners].find[-w]>|<def[owners].find[-w].add[1].as_int>]||li@>'
          }
        - define owner '<def[owners].last||li@>'
        - if <def[owner].starts_with[g:]||false> {
          - define group '<def[owner].replace[g:]>'
          - define groups '<server.list_permission_groups.filter[starts_with[%group%]]||li@>'
          - if <def[groups].is_empty> {
            - define groups '<server.list_permission_groups||li@>'
            }
          - define result '<def[groups].parse[replace[regex:^].with[g:]]>'
          }
          else {
          - define result '<server.match_player[%owner%].name||null>'
          - if <def[result].is[==].to[null]||true> {
            - define result '<server.list_online_players.parse[name]>'
            }
          }
        }
        else {
        - define result 'li@'
        }
      }
      else {
      - define result 'li@'
      }

  tab_redefine:
  # /drg redefine [ID]
    - if <player.permission[dregions.redefine]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
      - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
      - if !<player.permission[dregions.admin]||<player.is_op||true>> {
        - foreach %regions% {
          - if <proc[dRegions_IsOwner].context[%value%|%world%|<player>].not> {
            - define regions '<def[regions].exclude[%value%]||%regions%>'
            }
          }
        }
      - if <def[spaces].is[==].to[0]> {
        - define result '<def[regions].parse[replace[regex:^].with[redefine ]]>'
        }
        else if <def[spaces].is[==].to[1]> {
        - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||li@>'
        - if <def[result].is_empty||true> {
          - define result '%regions%'
          }
        }
        else {
        - define result 'li@'
        }
      }
      else {
      - define result 'li@'
      }

  tab_claim:
    - if <player.permission[dregions.claim]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
      - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
      - if !<player.permission[dregions.admin]||<player.is_op||false>> {
        - foreach %regions% {
          - if <proc[dRegions_IsOwner].context[%value%|%world%|<player>].not> {
            - define regions '<def[regions].exclude[%value%]||%regions%>'
            }
          }
        }
      - if <def[spaces].is[==].to[0]> {
        - define result '<def[regions].parse[replace[regex:^].with[claim ]]>'
        }
        else if <def[spaces].is[==].to[1]> {
        - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||li@>'
        - if <def[result].is_empty||true> {
          - define result '%regions%'
          }
        }
        else {
        - define result 'li@'
        }
      }
      else {
      - define result 'li@'
      }

  tab_select:
  # /drg select [ID] -w world
    - if <player.permission[dregions.select]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
      - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
      - if !<player.permission[dregions.admin]||<player.is_op||false>> {
        - foreach %regions% {
          - if <proc[dRegions_IsOwner].context[%value%|%world%|<player>].not> {
            - define regions '<def[regions].exclude[%value%]||%regions%>'
            }
          }
        }
      - if <def[spaces].is[==].to[0]> {
        - define result '<def[regions].parse[replace[regex:^].with[select ]]>'
        }
        else if <def[spaces].is[==].to[1]> {
        - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped||null>]]||li@>'
        - if <def[result].is_empty||true> {
          - define result '%regions%'
          }
        }
        else {
        - define result 'li@'
        }
      }
      else {
      - define result 'li@'
      }

  tab_info:
  # /drg info [ID] -w world
    - if <player.permission[dregions.info]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
      - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
      - if !<player.permission[dregions.admin]||<player.is_op||false>> {
        - foreach %regions% {
          - if <proc[dRegions_IsOwner].context[%value%|%world%|<player>].not> {
            - define regions '<def[regions].exclude[%value%]||%regions%>'
            }
          }
        }
      - if <def[spaces].is[==].to[0]> {
        - define result '<def[regions].parse[replace[regex:^].with[info ]]>'
        }
        else if <def[spaces].is[==].to[1]> {
        - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped||null>]]||li@>'
        - if <def[result].is_empty||true> {
          - define result '%regions%'
          }
        }
        else {
        - define result 'li@'
        }
      }
      else {
      - define result 'li@'
      }

  tab_addowner:
  # /drg addowner [ID] g:group player -w world
    - if <player.permission[dregions.addowner]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
      - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
      - if !<player.permission[dregions.admin]||<player.is_op||false>> {
        - foreach %regions% {
          - if <proc[dRegions_IsOwner].context[%value%|%world%|<player>].not> {
            - define regions '<def[regions].exclude[%value%]||%regions%>'
            }
          }
        }
      - if <def[spaces].is[==].to[0]> {
        - define result '<def[regions].parse[replace[regex:^].with[addowner ]]>'
        }
        else if <def[spaces].is[==].to[1]> {
        - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped||null>]]||li@>'
        - if <def[result].is_empty||true> {
          - define result '%regions%'
          }
        }
        else if <def[spaces].is[OR_MORE].than[2]> {
        - define owners '<c.args.remove[1|2]||li@>'
        - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
          - define owners '<def[owners].remove[<def[owners].find[-w]>|<def[owners].find[-w].add[1].as_int>]||li@>'
          }
        - define owner '<def[owners].last||li@>'
        - if <def[owner].starts_with[g:]||false> {
          - define group '<def[owner].replace[g:]>'
          - define groups '<server.list_permission_groups.filter[starts_with[%group%]]||li@>'
          - if <def[groups].is_empty> {
            - define groups '<server.list_permission_groups.alphanumeric||li@>'
            }
          - define result '<def[groups].parse[replace[regex:^].with[g:]]>'
          }
          else {
          - define result '<server.match_player[%owner%].name||null>'
          - if <def[result].is[==].to[null]||true> {
            - define result '<server.list_online_players.parse[name].alphanumeric>'
            }
          }
        }
        else {
        - define result 'li@'
        }
      }
      else {
      - define result 'li@'
      }

  tab_removeowner:
  # /drg removeowner [ID] g:group player -w world
    - if <player.permission[dregions.removeowner]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
      - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
      - if !<player.permission[dregions.admin]||<player.is_op||false>> {
        - foreach %regions% {
          - if <proc[dRegions_IsOwner].context[%value%|%world%|<player>].not> {
            - define regions '<def[regions].exclude[%value%]||%regions%>'
            }
          }
        }
      - if <def[spaces].is[==].to[0]> {
        - define result '<def[regions].parse[replace[regex:^].with[removeowner ]]>'
        }
        else if <def[spaces].is[==].to[1]> {
        - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||li@>'
        - if <def[result].is_empty||true> {
          - define result '%regions%'
          }
        }
        else if <def[spaces].is[OR_MORE].than[2]> {
        - define owners '<c.args.remove[1|2]||li@>'
        - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
          - define owners '<def[owners].remove[<def[owners].find[-w]>|<def[owners].find[-w].add[1].as_int>]||li@>'
          }
        - define owner '<def[owners].last||li@>'
        - if <def[owner].starts_with[g:]||false> {
          - define group '<def[owner].replace[g:]>'
          - define groups '<server.list_permission_groups.filter[starts_with[%group%]]||li@>'
          - if <def[groups].is_empty> {
            - define groups '<server.list_permission_groups.alphanumeric||li@>'
            }
          - define result '<def[groups].parse[replace[regex:^].with[g:]]>'
          }
          else {
          - define result '<server.match_player[%owner%].name||null>'
          - if <def[result].is[==].to[null]||true> {
            - define result '<server.list_online_players.parse[name].alphanumeric>'
            }
          }
        }
        else {
        - define result 'li@'
        }
      }
      else {
      - define result 'li@'
      }

  tab_addmember:
  # /drg addmember [ID] g:group player -w world
    - if <player.permission[dregions.addmember]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
      - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
      - if !<player.permission[dregions.admin]||<player.is_op||false>> {
        - foreach %regions% {
          - if <proc[dRegions_IsOwner].context[%value%|%world%|<player>].not> {
            - define regions '<def[regions].exclude[%value%]||%regions%>'
            }
          }
        }
      - if <def[spaces].is[==].to[0]> {
        - define result '<def[regions].parse[replace[regex:^].with[addmember ]]>'
        }
        else if <def[spaces].is[==].to[1]> {
        - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||li@>'
        - if <def[result].is_empty||true> {
          - define result '%regions%'
          }
        }
        else if <def[spaces].is[OR_MORE].than[2]> {
        - define members '<c.args.remove[1|2]||li@>'
        - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
          - define members '<def[members].remove[<def[members].find[-w]>|<def[members].find[-w].add[1].as_int>]||li@>'
          }
        - define member '<def[members].last||li@>'
        - if <def[member].starts_with[g:]||false> {
          - define group '<def[member].replace[g:]>'
          - define groups '<server.list_permission_groups.filter[starts_with[%group%]]||li@>'
          - if <def[groups].is_empty> {
            - define groups '<server.list_permission_groups.alphanumeric||li@>'
            }
          - define result '<def[groups].parse[replace[regex:^].with[g:]]>'
          }
          else {
          - define result '<server.match_player[%member%].name||null>'
          - if <def[result].is[==].to[null]||true> {
            - define result '<server.list_online_players.parse[name].alphanumeric>'
            }
          }
        }
        else {
        - define result 'li@'
        }
      }
      else {
      - define result 'li@'
      }

  tab_removemember:
  # /drg removemember [ID] g:group player -w world
    - if <player.permission[dregions.removemember]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
      - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
      - if !<player.permission[dregions.admin]||<player.is_op||false>> {
        - foreach %regions% {
          - if <proc[dRegions_IsOwner].context[%value%|%world%|<player>].not> {
            - define regions '<def[regions].exclude[%value%]||%regions%>'
            }
          }
        }
      - if <def[spaces].is[==].to[0]> {
        - define result '<def[regions].parse[replace[regex:^].with[removemember ]]>'
        }
        else if <def[spaces].is[==].to[1]> {
        - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||li@>'
        - if <def[result].is_empty||true> {
          - define result '%regions%'
          }
        }
        else if <def[spaces].is[OR_MORE].than[2]> {
        - define members '<c.args.remove[1|2]||li@>'
        - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
          - define members '<def[members].remove[<def[members].find[-w]>|<def[members].find[-w].add[1].as_int>]||li@>'
          }
        - define member '<def[members].last||li@>'
        - if <def[member].starts_with[g:]||false> {
          - define group '<def[member].replace[g:]>'
          - define groups '<server.list_permission_groups.filter[starts_with[%group%]]||li@>'
          - if <def[groups].is_empty> {
            - define groups '<server.list_permission_groups.alphanumeric||li@>'
            }
          - define result '<def[groups].parse[replace[regex:^].with[g:]]>'
          }
          else {
          - define result '<server.match_player[%member%].name||null>'
          - if <def[result].is[==].to[null]||true> {
            - define result '<server.list_online_players.parse[name].alphanumeric>'
            }
          }
        }
        else {
        - define result 'li@'
        }
      }
      else {
      - define result 'li@'
      }

  tab_list:
    - define result 'li@'

  tab_flag:
  # TODO
  # /drg flag [ID] [flag] [value] -g group -w world
    - if <player.permission[dregions.flag]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - if <def[spaces].is[==].to[0]> {
        - define result 'flag [ID]'
        }
        else if <def[spaces].is[==].to[1]> {
        - if <c.args.get[2].is[==].to[null]||true> {
          - define result '[ID]'
          }
          else if <c.args.get[2].is[==].to[-w]||false> {
          - define result '<server.list_worlds.parse[name.to_lowercase].parse[replace[regex:^].with[-w ]]>'
          }
          else if <context.server.not> {
          - define regions '<yaml[dRegions_<player.world.name.to_lowercase>_regions].list_keys[regions].alphanumeric||li@>'
          - if !<player.permission[dregions.admin]||<player.is_op||false>> {
            - foreach %regions% {
              - if <proc[dRegions_IsOwner].context[%value%|<player.world.name.to_lowercase>|<player>].not> {
                - define regions '<def[regions].exclude[%value%]||%regions%>'
                }
              }
            }
          - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||li@>'
          - if <def[result].is_empty||true> {
            - define result '%regions%'
            }
          }
          else {
          - define result 'li@'
          }
        }
        else if <def[spaces].is[==].to[2]> {
        - if <c.args.get[2].is[==].to[-w]||false> {
          - if <c.args.get[3].is[!=].to[null]||false> {
            - define result '<server.list_worlds.parse[name.to_lowercase].filter[starts_with[<c.args.get[3].escaped>]]||li@>'
            }
          - if <def[result].is_empty||true> {
            - define result '<server.list_worlds.parse[name.to_lowercase]||li@>'
            }
          }
          else if <c.args.get[2].is[!=].to[null]||false> {
          - define allFlags '<server.flag[dRegions.Flags].as_list||li@>'
          - if <c.args.get[3].is[==].to[-w]||false> {
            - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
            - if <c.args.get[3].is[!=].to[null]||false> {
              - define result '<server.list_worlds.parse[name.to_lowercase].filter[starts_with[<c.args.get[3].escaped>]]||li@>'
              }
            - if <def[result].is_empty||true> {
              - define result '<server.list_worlds.parse[name.to_lowercase].parse[replace[regex:^].with[-w ]]||li@>'
              }
            }
            else if <c.args.get[3].is[!=].to[null]||false> {
            - define result '<def[allFlags].filter[starts_with[<c.args.get[3].escaped>]]||li@>'
            - if <def[result].is_empty||true> {
              - define result '<def[allFlags]||li@>'
              }
            }
            else {
            - if <def[result].is_empty||true> {
              - define result '<def[allFlags]||li@>'
              }
            }
          }
        }
        else if <def[spaces].is[==].to[3]> {
        - if <c.args.get[2].is[==].to[-w]||false> {
          - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
          - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].alphanumeric||li@>'
          - if <c.args.get[4].is[!=].to[null]||false> {
            - define result '<def[regions].filter[starts_with[<c.args.get[4].escaped>]]||li@>'
            }
          - if <def[result].is_empty||true> {
            - define result '<def[regions]||li@>'
            }
          }
          else if <c.args.get[3].is[==].to[-w]||false> {
          - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
          - if <c.args.get[4].is[!=].to[null]||false> {
            - define result '<server.list_worlds.parse[name.to_lowercase].filter[starts_with[<c.args.get[3].escaped>]].parse[replace[regex:^].with[-w ]]||li@>'
            }
          - if <def[result].is_empty||true> {
            - define result '<server.list_worlds.parse[name.to_lowercase]||li@>'
            }
          }
          else if <c.args.get[4].is[==].to[-w]||false> {
          - define result '<server.list_worlds.parse[name.to_lowercase].parse[replace[regex:^].with[-w ]]||li@>'
          }
        }
        else if <def[spaces].is[==].to[4]> {
        - if <c.args.get[4].is[==].to[-w]||false> {
          - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||<player.world.name.to_lowercase||null>>'
          - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].alphanumeric||li@>'
          - if <c.args.get[5].is[!=].to[null]||false> {
            - define result '<server.list_worlds.parse[name.to_lowercase].filter[starts_with[<c.args.get[5].escaped>]]||li@>'
            }
          - if <def[result].is_empty||true> {
            - define result '<server.list_worlds.parse[name.to_lowercase]||li@>'
            }
          }
          else {
          - define allFlags '<server.flag[dRegions.Flags].as_list||li@>'
          - if <c.args.get[5].is[!=].to[null]||false> {
            - define result '<def[allFlags].filter[starts_with[<c.args.get[5].escaped>]]||li@>'
            }
          - if <def[result].is_empty||true> {
            - define result '<def[allFlags]||li@>'
            }
          }
        }
      }
      else {
      - define result 'li@'
      }

  tab_setpriority:
  # /drg remove [ID] -w world
    - if <player.permission[dregions.setpriority]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - if <def[spaces].is[==].to[0]> {
        - define result 'setpriority [ID]'
        }
        else if <def[spaces].is[==].to[1]> {
        - if <c.args.get[2].is[==].to[null]||true> {
          - define result '[ID]'
          }
          else if <c.args.get[2].is[==].to[-w]||false> {
          - define result '<server.list_worlds.parse[name.to_lowercase].parse[replace[regex:^].with[-w ]]>'
          }
          else if <context.server.not> {
          - define regions '<yaml[dRegions_<player.world.name.to_lowercase>_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
          - if !<player.permission[dregions.admin]||<player.is_op||false>> {
            - foreach %regions% {
              - if <proc[dRegions_IsOwner].context[%value%|<player.world.name.to_lowercase>|<player>].not> {
                - define regions '<def[regions].exclude[%value%]||%regions%>'
                }
              }
            - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||li@>'
            }
            else {
            - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||%regions%>'
            - if <def[result].is_empty> {
              - define result '%regions%'
              }
            }
          }
          else {
          - define result 'li@'
          }
        }
        else if <def[spaces].is[==].to[2]> {
        - if <c.args.get[2].is[==].to[-w]||false> {
          - if <c.args.get[3].is[!=].to[null]||false> {
            - define result '<server.list_worlds.parse[name.to_lowercase].filter[starts_with[<c.args.get[3].escaped>]]||li@>'
            }
          - if <def[result].is_empty||true> {
            - define result '<server.list_worlds.parse[name.to_lowercase]||li@>'
            }
          }
          else {
          - if <c.args.get[3].is[MATCHES].to[number]> {
            - define result '<c.args.get[3]>'
            }
            else if <c.args.get[3].is[==].to[-w]||false> {
            - define result '<server.list_worlds.parse[name.to_lowercase].parse[replace[regex:^].with[-w ]]||li@>'
            }
            else {
            - define result '<&ns>'
            }
          }
        }
        else if <def[spaces].is[==].to[3]> {
        - if <c.args.get[2].is[==].to[-w]||false> {
          - if <c.args.get[4].is[!=].to[null]||false> {
            - define regions '<yaml[dRegions_<c.args.get[3].escaped>_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
            - define result '<def[regions].filter[starts_with[<c.args.get[4].escaped>]]||li@>'
            - if <def[result].is_empty||true> {
              - define result '%regions%'
              }
            }
            else {
            - define result '<yaml[dRegions_<c.args.get[3].escaped>_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
            }
          }
          else if <c.args.get[3].is[==].to[-w]||false> {
          - define result '<server.list_worlds.parse[name.to_lowercase]||li@>'
          }
          else {
          - if <c.args.get[4].is[!=].to[null]||false> {
            - define result '<server.list_worlds.parse[name.to_lowercase].filter[starts_with[<c.args.get[4].escaped>]]||li@>'
            }
            else {
            - define result '<server.list_worlds.parse[name].parse[replace[regex:^].with[-w ]]||li@>'
            }
          - if <def[result].is_empty||true> {
            - define result '<server.list_worlds.parse[name.to_lowercase].parse[replace[regex:^].with[-w ]]||li@>'
            }
          }
        }
        else if <def[spaces].is[==].to[4]> {
        - if <c.args.get[2].is[==].to[-w]||false>
          || <c.args.get[3].is[==].to[-w]||false> {
          - if <c.args.get[5].is[MATCHES].to[number]> {
            - define result '<c.args.get[5]>'
            }
            else {
            - define result '<&ns>'
            }
          }
          else if <c.args.get[4].is[==].to[-w]> {
          - define result '<server.list_worlds.parse[name.to_lowercase]||li@>'
          }
        }
        else {
        - define result 'li@'
        }
      }
      else {
      - define result 'li@'
      }

  tab_setparent:
  # TODO
    - define result 'li@'

  tab_teleport:
  # TODO
  # /drg teleport [ID] -w world
    - define result 'li@'

  tab_remove:
  # /drg remove [ID] -w world
    - if <player.permission[dregions.remove]||<player.is_op||false>> {
      - define spaces '<c.raw_args.to_list.count[ ]||0>'
      - if <def[spaces].is[==].to[0]> {
        - define result 'remove [ID] -w world'
        }
        else if <def[spaces].is[==].to[1]> {
        - if <c.args.get[2].is[==].to[null]||true> {
          - define result '[ID]'
          }
          else if <c.args.get[2].is[==].to[-w]||false> {
          - define result '<server.list_worlds.parse[name.to_lowercase].parse[replace[regex:^].with[-w ]]>'
          }
          else if <context.server.not> {
          - define regions '<yaml[dRegions_<player.world.name.to_lowercase>_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
          - if !<player.permission[dregions.admin]||<player.is_op||false>> {
            - foreach %regions% {
              - if <proc[dRegions_IsOwner].context[%value%|<player.world.name.to_lowercase>|<player>].not> {
                - define regions '<def[regions].exclude[%value%]||%regions%>'
                }
              }
            }
          - define result '<def[regions].filter[starts_with[<c.args.get[2].escaped>]]||li@>'
          - if <def[result].is_empty||true> {
            - define result '%regions%'
            }
          }
          else {
          - define result 'li@'
          }
        }
        else if <def[spaces].is[==].to[2]> {
        - if <c.args.get[2].is[==].to[-w]||false> {
          - if <c.args.get[3].is[!=].to[null]||false> {
            - define result '<server.list_worlds.parse[name.to_lowercase].filter[starts_with[<c.args.get[3].escaped>]]||li@>'
            }
          - if <def[result].is_empty||true> {
            - define result '<server.list_worlds.parse[name.to_lowercase]||li@>'
            }
          }
          else {
          - define result '<server.list_worlds.parse[name.to_lowercase].parse[replace[regex:^].with[-w ]]>'
          }
        }
        else if <def[spaces].is[==].to[3]> {
        - if <c.args.get[2].is[==].to[-w]||false> {
          - if <c.args.get[4].is[!=].to[null]||false> {
            - define regions '<yaml[dRegions_<c.args.get[3].escaped>_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
            - define result '<def[regions].filter[starts_with[<c.args.get[4].escaped>]]||li@>'
            - if <def[result].is_empty||true> {
              - define result '%regions%'
              }
            }
            else {
            - define result '<yaml[dRegions_<c.args.get[3].escaped>_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
            }
          }
          else {
          - if <c.args.get[4].is[!=].to[null]||false> {
            - define result '<server.list_worlds.parse[name.to_lowercase].filter[starts_with[<c.args.get[4].escaped>]]||li@>'
            }
            else {
            - define result '<server.list_worlds.parse[name.to_lowercase]||li@>'
            }
          - if <def[result].is_empty||true> {
            - define result '<server.list_worlds.parse[name.to_lowercase]||li@>'
            }
          }
        }
        else {
        - define result 'li@'
        }
      }
      else {
      - define result 'li@'
      }

  tab_wgimport:
  # TODO
  # /drg wgimport [world(s)] -a
    - define result 'li@'

  tab_tool:
  # TODO
  # /drg tool [type]
    - define result 'li@'


#
#  END dRegions Command TAB Completion
#--------------------------------------
#
#  dRegions Command Arguments
#
# Each of these subscripts is an argument for the root command.
#
  help:
    - define arg '<c.args.get[2].escaped||null>'
    - if <def[args].contains[%arg%]||false> {
      - run instantly delay:1t s@dRegions_Msg 'def:command.help.syntax|<player||server>|<script.yaml_key[commandArgs.%arg%.usage]||No help for you!>'
      - queue clear
      }
    - if <player.permission[dRegions.admin]||<player.is_op||<context.server||false>>> {
      - inject locally msgsHelpAdmin
      }
      else {
      - inject locally msgsHelpUser
      }
    - inject locally msgsFooter
    - queue clear

  about:
    - inject locally msgsHelpUser
    - inject locally msgsFooter
    - queue clear

  reload:
    - if !<player.permission[dRegions.reload]||<player.is_op||<context.server||false>>> {
      - inject locally help
      - queue clear
      }
    - inject s@dRegions p:reloadYaml instantly

  restart:
    - if !<player.permission[dRegions.restart]||<player.is_op||<context.server||false>>> {
      - inject locally help
      - queue clear
      }
    - run s@dRegions p:start instantly

  wgimport:
    - define args '<c.args.replace[wgimport]>'
    - if <c.server> {
      - if <def[args].size> == 0 {
        - run instantly delay:1t s@dRegions_Msg 'def:command.wgimport.error|<player||server>'
        - queue clear
        }
      }
      else {
      - if !<player.permission[dregions.admin]||false> && !<player.is_op> {
        - queue clear
        }
      }
    - if <def[args].size> > 0 {
      - if <def[args]> contains '-a' {
        - define worlds '<server.list_worlds.parse[name]>'
        }
        else {
        - define worlds '<def[args].escape_contents>'
        }
      }
      else {
      - define worlds '<def[worlds].include[<player.world.name>]>' {
      }
    - foreach '%worlds%':
      - run s@dRegions_WG_Importer 'def:%value%'

  tool:
    - define args '<c.args.replace[tool]>'
    - define tool '<def[args].get[1]||null>'
    - if <c.server> {
      - run instantly delay:1t s@dRegions_Msg 'def:command.error.0|server'
      - queue clear
      }
    - if 'li@wand' !contains '%tool%' {
      - run instantly delay:1t s@dRegions_Msg 'def:tools.error.1|<player>'
      - queue clear
      }
    - if !<player.permission[dregions.admin]||false> && !<player.permission[dregions.tools.*]||false> && !<player.permission[dregions.tools.%tool%]||false> && !<player.is_op> {
      - run instantly delay:1t s@dRegions_Msg 'def:command.error.1|<player>'
      }
    - if <player.item_in_hand.material.is_block> {
      - run instantly delay:1t s@dRegions_Msg 'def:tools.error.2|<player>|<player.item_in_hand.material.name.replace[_].with[ ]>'
      - queue clear
      }
    - choose '%tool%':
      - case 'wand':
        - define type '<def[args].get[2]||cuboid>'
        - if 'li@extender|cuboid' !contains '%type%' {
          - define type 'cuboid'
          }
        - define pad '<el@val[25].sub[<def[type].length>].div[1.5].round>'
        - define lore 'li@<&r.pad_right[%pad%].with[<&sp>]><&6><def[type].to_titlecase><&r.pad_left[%pad%].with[<&sp>]>|<&sp>|<&sp><&sp><&7>Pos1<&co> <&c>unset|<&sp><&sp><&7>Pos2<&co> <&c>unset|<&sp><&sp><&7>LxHxW<&co> <&c>0x0x0|<&sp><&sp><&7>Volume<&co> <&c>0'
        - inventory set 'd:<player.inventory>' 'o:<player.item_in_hand.simple>[display_name=<&r.pad_right[<el@25.sub[13].div[1.5].round>]><&c><&l><&n>dRegions<&sp>Wand<&r.pad_right[<el@25.sub[13].div[1.5].round_down>]>;lore=%lore%;nbt=dRegions_Tool/wand;nbt=dRegions_Owner/<player.uuid>;nbt=dRegions_WandType/%type%;flags=HIDE_ATTRIBUTES|HIDE_DESTROYS|HIDE_ENCHANTS|HIDE_PLACED_ON|HIDE_POTION_EFFECTS|HIDE_UNBREAKABLE]' 'slot:<player.inventory.find[<player.item_in_hand>]>'
        - run instantly delay:1t s@dRegions_Msg 'def:wand.bind.0|<player>|<player.item_in_hand.material.name.replace[_].with[<&sp>]>|%type%'

  define:
  # /drg define [ID] (g:group) (player)
    - inject locally prerun instantly
    # Check for existing region
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]||true>'
    - if <def[exists].is[==].to[orphan]> {
      - run instantly delay:1t s@dRegions_Msg 'def:region.orphan|<player||server>'
      - queue clear
      }
      else if <def[exists]> {
      - run instantly delay:1t s@dRegions_Msg 'def:region.existingRegion|<player||server>'
      - queue clear
      }
    # Check for overlapping regions
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_RegionOverlaps].context[<def[selectedCuboid].separated_by[/].replace[cu@]>|%world%|<player>]> {
        - run instantly delay:1t s@dRegions_Msg 'def:region.otherRegions|<player||server>'
        - queue clear
        }
      }
    # Parse any declared owners
    - define owners '<c.args.remove[1|2].replace[:].with[;]||li@>'
    - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
      - define owners '<def[owners].remove[<def[owners].find[-w]>|<def[owners].find[-w].add[1].as_int>]||li@>'
      }
    - define ownerGroups li@
    - define ownerPlayers li@
    - foreach %owners% {
      - if <def[value].starts_with[g;]||false> {
        - define ownerGroups '<def[ownerGroups].include[<def[value].replace[g;]>]||%ownerGroups%>'
        }
        else {
        - if !<def[value].as_player.is[!=].to[null]||false> {
          - foreach next
          }
        - define ownerPlayers '<def[ownerPlayers].include[<def[value].as_player.uuid>]||%ownerPlayers%>'
        }
      }
    # Automatically add the player that defined the region as the owner
    - if <yaml[dregions_global_config].read[config.regions.ownerOnDefine].is[==].to[true]||false> {
      - if <def[ownerPlayers].contains[<player.uuid>].not||false> {
        - define ownerPlayers '<def[ownerPlayers].include[<player.uuid>]||%ownerPlayers%>'
        }
      }
    # Create the region
    - inject s@dRegions p:createRegionEntry instantly
    - run instantly delay:1t s@dRegions_Msg 'def:command.define.create|<player||server>|%name%|%world%'

  redefine:
  # /drg redefine [ID]
    - inject locally prerun instantly
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run instantly delay:1t s@dRegions_Msg 'def:region.orphan|<player||server>'
      - queue clear
      }
      else if <def[exists].not> {
      - run instantly delay:1t s@dRegions_Msg 'def:region.noRegion|<player||server>'
      - queue clear
      }
    # Don't redefine global type regions
    - if <yaml[dRegions_%world%_regions].read[regions.%name%.type].is[==].to[global]||false> {
      - run instantly delay:1t s@dRegions_Msg 'def:command.redefine.error.1|<player||server>'
      - queue clear
      }
    # Check if is owner
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run instantly delay:1t s@dRegions_Msg 'def:region.notOwner|<player||server>'
        - queue clear
        }
      }
    # Check for overlapping regions
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_RegionOverlaps].context[<def[selectedCuboid].separated_by[/].replace[cu@]>|%world%|<player>]> {
        - run instantly delay:1t s@dRegions_Msg 'def:regions.otherRegions|<player||server>'
        - queue clear
        }
      }
    # Update the region
    - yaml set 'regions.%name%.min:<def[selectedCuboid].min.simple>' 'id:dRegions_%world%_regions'
    - yaml set 'regions.%name%.max:<def[selectedCuboid].max.simple>' 'id:dRegions_%world%_regions'
    - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
    - note cu@<def[selectedCuboid].min.simple>|<def[selectedCuboid].max.simple> 'as:dregions_%world%_%name%'
    - run instantly delay:1t s@dRegions_Msg 'def:command.redefine.update|<player||server>|%name%'

  claim:
  # /drg claim [ID]
    - inject locally prerun instantly
    # Check Global region limits
    - define globalRegionLimit '<yaml[dregions_global_config].read[config.regions.claim.max-region-count-per-player.default]||0>'
    - if <def[globalRegionLimit].is[MORE].than[0]> {
      - define playerGlobalRegions 'li@'
      - foreach <server.list_worlds.parse[name.to_lowercase]> {
        - define thisWorld '%value%'
        - foreach '<yaml[dRegions_%thisWorld%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>' {
          - define region '%value%'
          - if <proc[dRegions_IsOwner].context[<def[region]>|<def[thisWorld]>|<player>]||false> {
            - define playerGlobalRegions '<def[playerGlobalRegions].include[<def[region]>]||<def[playerGlobalRegions]>>'
            }
          }
        }
      - if <def[playerGlobalRegions].size.is[OR_MORE].than[%globalRegionLimit%]> {
        - run instantly delay:1t s@dRegions_Msg 'def:command.claim.error.0|<player||server>|<def[playerGlobalRegions].size>'
        - if !<player.permission[dRegions.admin]||<player.is_op||false>> {
          - queue clear
          }
        - run instantly delay:1t s@dRegions_Msg 'def:admin.override.0|<player||server>'
        }
      }
    # Check World region limits
    - define worldRegionLimit '<yaml[dregions_%world%_config].read[config.regions.claim.max-region-count-per-player.default]||0>'
    - if <def[worldRegionLimit].is[MORE].than[0]> {
      - define playerWorldRegions 'li@'
      - foreach '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>' {
        - define region '%value%'
        - if <proc[dRegions_IsOwner].context[<def[region]>|<def[world]>|<player>]||false> {
          - define playerWorldRegions '<def[playerWorldRegions].include[<def[region]>]||<def[playerWorldRegions]>>'
          }
        }
      - if <def[playerWorldRegions].size.is[OR_MORE].than[%worldRegionLimit%]> {
        - run instantly delay:1t s@dRegions_Msg 'def:command.claim.error.1|<player||server>|<def[playerWorldRegions].size>'
        - if !<player.permission[dRegions.admin]||<player.is_op||false>> {
          - queue clear
          }
        - run instantly delay:1t s@dRegions_Msg 'def:admin.override.0|<player||server>'
        }
      }
    # Check selection volume
    - define globalClaimVol '<yaml[dregions_global_config].read[config.regions.claim.max-volume]||0>'
    - define size '<cu@%pos1%|%pos2%.size>'
    - define size '<def[size].x.mul[<def[size].y>].mul[<def[size].z>]>'
    - if <def[globalClaimVol].is[MORE].than[0]> {
      - if <def[size].is[MORE].than[%globalClaimVol%]> {
        - run instantly delay:1t s@dRegions_Msg 'def:command.claim.error.2|<player||server>|%size%|%globalClaimVol%|<def[size].sub[%globalClaimVol%].round>'
        - if !<player.permission[dRegions.admin]||<player.is_op||false>> {
          - queue clear
          }
        - run instantly delay:1t s@dRegions_Msg 'def:admin.override.0|<player||server>'
        }
      }
    - define worldClaimVol '<yaml[dregions_%world%_config].read[config.regions.claim.max-volume]||0>'
    - if <def[worldClaimVol].is[MORE].than[0]> {
      - if <def[size].is[MORE].than[%worldClaimVol%]> {
        - run instantly delay:1t s@dRegions_Msg 'def:command.claim.error.3|<player||server>|%size%|%worldClaimVol%|<def[size].sub[%worldClaimVol%].round>'
        - if !<player.permission[dRegions.admin]||<player.is_op||false>> {
          - queue clear
          }
        - run instantly delay:1t s@dRegions_Msg 'def:admin.override.0|<player||server>'
        }
      }
    # Check inside existing/owned region
    - if '<yaml[dregions_global_config].read[config.regions.claim.only-inside-existing-regions]||false>' {
      - if <def[playerWorldRegions].exists.not> {
        - define playerWorldRegions 'li@'
        - foreach '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>' {
          - define region '%value%'
          - if <proc[dRegions_IsOwner].context[<def[region]>|<def[world]>|<player>]||false> {
            - define playerWorldRegions '<def[playerWorldRegions].include[<def[region]>]||<def[playerWorldRegions]>>'
            }
          }
        }
      - define cuboids '<def[playerWorldRegions].parse[replace[regex:^].with[cu@dregions_%world%_]].filter[as_cuboid.is[!=].to[null]||false]||li@>'
      - foreach %cuboids% {
        - if <def[pos1].as_location.is_within[%value%]> && <def[pos2].as_location.is_within[%value%]> {
          - define isWithin ''
          - foreach stop
          }
        }
      - if <def[isWithin].exists.not> {
        - run instantly delay:1t s@dRegions_Msg 'def:command.claim.error.4|<player||server>'
        - if !<player.permission[dRegions.admin]||<player.is_op||false>> {
          - queue clear
          }
        - run instantly delay:1t s@dRegions_Msg 'def:admin.override.0|<player||server>'
        }
      }
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run instantly delay:1t s@dRegions_Msg 'def:region.orphan|<player||server>'
      - queue clear
      }
      else if <def[exists]> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run instantly delay:1t s@dRegions_Msg 'def:region.notOwner|<player||server>'
        - queue clear
        }
      - if <yaml[dRegions_%world%_regions].read[regions.%name%.type].is[==].to[global]||false> {
        - run instantly delay:1t s@dRegions_Msg 'def:redefine.error.1|<player||server>'
        - queue clear
        }
      - run instantly delay:1t s@dRegions_Msg 'def:region.existingRegion|<player||server>'
      - run instantly delay:1t s@dRegions_Msg 'def:claim.error.5|<player||server>'
      - define update ''
      }
    # Check for overlapping regions
    # The perm check here is redundant
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_RegionOverlaps].context[<def[selectedCuboid].separated_by[/].replace[cu@]>|%world%|<player>]> {
        - run instantly delay:1t s@dRegions_Msg 'def:region.otherRegions|<player||server>'
        - if !<player.permission[dRegions.admin]||<player.is_op||false>> {
          - queue clear
          }
        - run instantly delay:1t s@dRegions_Msg 'def:admin.override.0|<player||server>'
        }
      }
    # Update the region
    - if <def[update].exists||false> {
      - yaml set 'regions.%name%.min:<def[selectedCuboid].min.simple>' 'id:dRegions_%world%_regions'
      - yaml set 'regions.%name%.max:<def[selectedCuboid].max.simple>' 'id:dRegions_%world%_regions'
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - note cu@<def[selectedCuboid].min.simple>|<def[selectedCuboid].max.simple> 'as:dregions_%world%_%name%'
      - run instantly delay:1t s@dRegions_Msg 'def:claim.update|<player||server>|%name%'
      }
      else {
      - define ownerPlayers 'li@<player.uuid>'
      - inject s@dRegions p:createRegionEntry instantly
      - run instantly delay:1t s@dRegions_Msg 'def:claim.create|<player||server>|%name%|%world%'
      }

  select:
  # /drg select [ID]
    - inject locally prerun instantly
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run instantly delay:1t s@dRegions_Msg 'def:region.orphan|<player||server>'
      - queue clear
      }
      else if <def[exists].not> {
      - run instantly delay:1t s@dRegions_Msg 'def:region.noRegion|<player||server>'
      - queue clear
      }
    # Don't select global type regions
    - if <yaml[dRegions_%world%_regions].read[regions.%name%.type].is[==].to[global]||false> {
      - run instantly delay:1t s@dRegions_Msg 'def:command.select.0|<player||server>'
      - queue clear
      }
    # Check if is owner
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run instantly delay:1t s@dRegions_Msg 'def:region.notOwner|<player||server>'
        - queue clear
        }
      }
    - define min '<yaml[dRegions_%world%_regions].read[regions.%name%.min].as_location.simple||null>'
    - define max '<yaml[dRegions_%world%_regions].read[regions.%name%.max].as_location.simple||null>'
    - if '<yaml[dRegions_global_config].read[config.regions.wand]||unset>' == 'dwe_wand' {
      - flag <player> 'dWEWand_Type:cuboid'
      - flag <player> dWEWand:!
      - flag <player> dWEWand:|:%min%|%max%
      }
      else {
      - define item '<player.item_in_hand>'
      - if !<def[item].has_nbt[dRegions_Tool]||false>  || '<def[item].nbt[dRegions_Tool]||null>' != 'wand' {
        - run instantly delay:1t s@dRegions_Msg 'def:command.error.2|<player>'
        - queue clear
        }
      - define tool '<def[item].nbt[dRegions_Tool]||null>'
      - if ( !<player.has_permission[dRegions.admin]||false> && !<player.has_permission[dRegions.tool.%tool%]||false> && !<player.is_op> ) || '<player.uuid>' != '<def[item].nbt[dRegions_Owner]||null>' {
        - inventory set 'd:<player.inventory>' 'o:<def[item].simple>' 'slot:<player.item_in_hand.slot>'
        - run instantly delay:1t s@dRegions_Msg 'def:tools.error.0|<player>'
        - queue clear
        }
      - define type '<def[item].nbt[dRegions_WandType]||cuboid>'
      - define pad '<el@val[25].sub[<def[type].length>].div[1.5].round>'
      - define lore 'li@<&r.pad_right[%pad%].with[<&sp>]><&6><def[type].to_titlecase><&r.pad_right[%pad%].with[<&sp>]>|<&sp>|<&sp><&sp><&7>Region<&co> <&f>%name%|<&sp><&sp><&7>Pos1<&co> <&b><def[min]||unset>|<&sp><&sp><&7>Pos2<&co> <&b><def[max]||unset>|<&sp><&sp><&7>LxHxW<&co> <&b><cu@%min%|%max%.size.after[l@].before_last[,].split_by[,].parse[round].separated_by[x]||<&c>unset>|<&sp><&sp><&7>Volume<&co> <&b><el@val[<math:<cu@%min%|%max%.size.after[l@].before_last[,].replace[,].with[*]||0>>].round>'
      - inventory set 'd:<player.inventory>' 'o:<def[item].simple>[display_name=<&r.pad_right[<el@25.sub[13].div[1.5].round>]><&c><&l><&n>dRegions<&sp>Wand<&r.pad_right[<el@25.sub[13].div[1.5].round_down>]>;lore=%lore%;nbt=dRegions_Tool/wand;nbt=dRegions_Owner/<player.uuid>;nbt=dRegions_Pos1/<def[min]>;nbt=dRegions_Pos2/<def[max]>;nbt=dRegions_WandType/%type%;flags=HIDE_ATTRIBUTES|HIDE_DESTROYS|HIDE_ENCHANTS|HIDE_PLACED_ON|HIDE_POTION_EFFECTS|HIDE_UNBREAKABLE]' 'slot:<player.item_in_hand.slot>'
      }
    - run instantly delay:1t s@dRegions_Msg 'def:command.select.select|<player||server>|%name%'

  info:
  # /drg info [ID] -w world
    - inject locally prerun instantly
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run instantly delay:1t s@dRegions_Msg 'def:region.orphan|<player||server>'
      - queue clear
      }
      else if <def[exists].not> {
      - run instantly delay:1t s@dRegions_Msg 'def:region.noRegion|<player||server>'
      - queue clear
      }
    # Check if is owner
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run instantly delay:1t s@dRegions_Msg 'def:region.notOwner|<player||server>'
        - queue clear
        }
      }
    - inject locally regionInfo instantly

    - define title '<proc[msgCommand].context[<&6>dRegions|drg help|<&a>Go back to main help]>'
    - define subTitle '<&e>Region Info'
    - define command 'drg info %name%'
    - define entries 'li@<&7>Region<&co> <&e><proc[msgTrim].context[15|%name%]>  <&7>World<&co> <&e><proc[msgTrim].context[15|%world%]>'
    - define entries '<def[entries].include[<&7>Type<&co> <&f>%type%  <&7>Volume<&co> <&8><&lb><&f><&o>%size%<&8><&rb>]>'
    - define entries '<def[entries].include[<&7>Area<&co> <&8><&lb><&f><&o><def[pos1].split[,].remove[4].separated_by[,]> <&f><&o><def[pos2].split[,].remove[4].separated_by[,]><&8><&rb>]>'
    - define entries '<def[entries].include[<&7>Priority<&co> <&f><el@val[%priority%].pad_right[3]><&7>  Parent<&co> <&f>%parent%]>'
    - if <def[ownerPlayers].is_empty||true> && <def[ownerGroups].is_empty||true> {
      - define entries '<def[entries].include[<&7>Owners<&co> <&c>none]>'
      }
      else {
      - define entries '<def[entries].include[<&7>Owners<&co> <&f><def[ownerPlayers].parse[as_player.name].include[<def[ownerGroups].parse[replace[regex:^].with[<&b>]]||>].comma_separated>]>'
      }
    - if <def[memberPlayers].is_empty||true> && <def[memberGroups].is_empty||true> {
      - define entries '<def[entries].include[<&7>Members<&co> <&c>none]>'
      }
      else {
      - define entries '<def[entries].include[<&7>Members<&co> <&f><def[memberPlayers].parse[as_player.name].include[<def[memberGroups].parse[replace[regex:^].with[<&b>]]||>].comma_separated>]>'
      }
    - if <def[flags].is_empty> {
      - define entries '<def[entries].include[<&7>Flags<&co> <&c>none]>'
      }
      else {
      - define entries '<def[entries].include[<&7>Flags<&co>]>'
      - foreach '<def[flags].alphanumeric>' {
        - define flag '<def[value].split[/].get[1]>'
        - define flagVal '<def[value].after[/].strip_color>'
        - define entries '<def[entries].include[<&e.pad_left[3]>%flag%<&co> <&f><parse:%flagVal%>]>'
        }
      }

    - run s@msgBoxed 'def:dRegions|%title%|%subTitle%|%command%|%page%|52|14|<def[entries].separated_by[|]>'

  addowner:
  # /drg addowner [ID] g:group player
    - inject locally prerun instantly
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run instantly delay:1t s@dRegions_Msg 'def:region.orphan|<player||server>'
      - queue clear
      }
      else if <def[exists].not> {
      - run instantly delay:1t s@dRegions_Msg 'def:region.noRegion|<player||server>'
      - queue clear
      }
    # Check if is owner
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run instantly delay:1t s@dRegions_Msg 'def:region.notOwner|<player||server>'
        - queue clear
        }
      }
    # Parse specified owners
    - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
      - define args '<c.args.remove[<c.args.find[-w].add[1].as_int>].exclude[-w]>'
      - define owners '<def[args].get[3].to[<def[args].size>].replace[:].with[;]||null>'
      }
      else {
      - define owners '<c.args.get[3].to[<c.args.size>].replace[:].with[;]||null>'
      }
    - if <def[owners].is_empty||true> {
      - run instantly delay:1t s@dRegions_Msg 'def:command.addowner.error.0|<player||server>'
      - queue clear
      }
    - foreach %owners% {
      - if <def[value].starts_with[g;]||false> {
        - define group '<def[value].replace[g;]>'
        - if <server.list_permission_groups> !contains %group% {
          - run instantly delay:1t s@dRegions_Msg 'def:command.addowner.error.1|<player||server>|%group%'
          - foreach next
          }
        - define groups '<yaml[dRegions_%world%_regions].read[regions.%name%.owners.groups]||li@>'
        - if <def[groups].contains[%group%]||false> {
          - run instantly delay:1t s@dRegions_Msg 'def:command.addowner.error.2|<player||server>|%group%'
          - foreach next
          }
        - define pass true
        - yaml set 'regions.%name%.owners.groups:->:%group%' 'id:dRegions_%world%_regions'
        }
        else {
        - if !<def[value].as_player.is[!=].to[null]||false> {
          - foreach next
          }
        - define players '<yaml[dRegions_%world%_regions].read[regions.%name%.owners.players]||li@>'
        - if <def[players].contains[<def[value].as_player.uuid>]||false> {
          - run instantly delay:1t s@dRegions_Msg 'def:command.addowner.error.3|<player||server>|%value%'
          - foreach next
          }
        - define pass true
        - yaml set 'regions.%name%.owners.players:->:<def[value].as_player.uuid>' 'id:dRegions_%world%_regions'
        - flag <def[value].as_player> 'dRegions.cache.%world%.%name%:!'
        }
      }
    - if <def[pass].exists||false> {
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - run instantly delay:1t s@dRegions_Msg 'def:command.addowner.update|<player||server>|%name%'
      }
      else {
      - run instantly delay:1t s@dRegions_Msg 'def:command.addowner.error.4|<player||server>|%name%'
      }

  removeowner:
  # /drg removeowner [ID] g:group player
    - inject locally prerun instantly
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run instantly delay:1t s@dRegions_Msg 'def:region.orphan|<player||server>'
      - queue clear
      }
      else if <def[exists].not> {
      - run instantly delay:1t s@dRegions_Msg 'def:region.noRegion|<player||server>'
      - queue clear
      }
    # Check if is owner
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run instantly delay:1t s@dRegions_Msg 'def:region.notOwner|<player||server>'
        - queue clear
        }
      }
    # Parse specified owners
    - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
      - define args '<c.args.remove[<c.args.find[-w].add[1].as_int>].exclude[-w]>'
      - define owners '<def[args].get[3].to[<def[args].size>].replace[:].with[;]||null>'
      }
      else {
      - define owners '<c.args.get[3].to[<c.args.size>].replace[:].with[;]||null>'
      }
    - if <def[owners].is_empty||true> {
      - run instantly delay:1t s@dRegions_Msg 'def:command.removeowner.error.0|<player||server>'
      - queue clear
      }
    - foreach %owners% {
      - if <def[value].starts_with[g;]||false> {
        - define group '<def[value].replace[g;]>'
        - if <server.list_permission_groups> !contains %group% {
          - run instantly delay:1t s@dRegions_Msg 'def:command.removeowner.error.1|<player||server>|%group%'
          - foreach next
          }
        - define groups '<yaml[dRegions_%world%_regions].read[regions.%name%.owners.groups]||li@>'
        - if <def[groups].contains[%group%].not||true> {
          - run instantly delay:1t s@dRegions_Msg 'def:command.removeowner.error.2|<player||server>|%group%'
          - foreach next
          }
        - define pass true
        - yaml set 'regions.%name%.owners.groups:<-:%group%' 'id:dRegions_%world%_regions'
        }
        else {
        - if !<def[value].as_player.is[!=].to[null]||false> {
          - foreach next
          }
        - define players '<yaml[dRegions_%world%_regions].read[regions.%name%.owners.players]||li@>'
        - if <def[players].contains[<def[value].as_player.uuid>].not||true> {
          - run instantly delay:1t s@dRegions_Msg 'def:command.removeowner.error.3|<player||server>|%value%'
          - foreach next
          }
        - define pass true
        - yaml set 'regions.%name%.owners.players:<-:<def[value].as_player.uuid>' 'id:dRegions_%world%_regions'
        - flag <def[value].as_player> 'dRegions.cache.%world%.%name%:!'
        }
      }
    - if <def[pass].exists||false> {
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - run instantly delay:1t s@dRegions_Msg 'def:command.removeowner.update|<player||server>|%name%'
      }
      else {
      - run instantly delay:1t s@dRegions_Msg 'def:command.removeowner.error.4|<player||server>|%name%'
      }

  addmember:
  # /drg addmember [ID] g:group player
    - inject locally prerun instantly
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run instantly delay:1t s@dRegions_Msg 'def:region.orphan|<player||server>'
      - queue clear
      }
      else if <def[exists].not> {
      - run instantly delay:1t s@dRegions_Msg 'def:region.noRegion|<player||server>'
      - queue clear
      }
    # Check if is owner
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run instantly delay:1t s@dRegions_Msg 'def:region.notOwner|<player||server>'
        - queue clear
        }
      }
    # Parse specified members
    - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
      - define args '<c.args.remove[<c.args.find[-w].add[1].as_int>].exclude[-w]>'
      - define members '<def[args].get[3].to[<def[args].size>].replace[:].with[;]||null>'
      }
      else {
      - define members '<c.args.get[3].to[<c.args.size>].replace[:].with[;]||null>'
      }
    - if <def[members].is_empty||true> {
      - run instantly delay:1t s@dRegions_Msg 'def:command.addmember.error.0|<player||server>'
      - queue clear
      }
    - foreach %members% {
      - if <def[value].starts_with[g;]||false> {
        - define group '<def[value].replace[g;]>'
        - if <server.list_permission_groups> !contains %group% {
          - run instantly delay:1t s@dRegions_Msg 'def:command.addmember.error.1|<player||server>|%group%'
          - foreach next
          }
        - define groups '<yaml[dRegions_%world%_regions].read[regions.%name%.members.groups]||li@>'
        - if <def[groups].contains[%group%]||false> {
          - run instantly delay:1t s@dRegions_Msg 'def:command.addmember.error.2|<player||server>|%group%'
          - foreach next
          }
        - define pass true
        - yaml set 'regions.%name%.members.groups:->:%group%' 'id:dRegions_%world%_regions'
        }
        else {
        - if !<def[value].as_player.is[!=].to[null]||false> {
          - foreach next
          }
        - define players '<yaml[dRegions_%world%_regions].read[regions.%name%.members.players]||li@>'
        - if <def[players].contains[<def[value].as_player.uuid>]||false> {
          - run instantly delay:1t s@dRegions_Msg 'def:command.addmember.error.3|<player||server>|%value%'
          - foreach next
          }
        - define pass true
        - yaml set 'regions.%name%.members.players:->:<def[value].as_player.uuid>' 'id:dRegions_%world%_regions'
        - flag <def[value].as_player> 'dRegions.cache.%world%.%name%:!'
        }
      }
    - if <def[pass].exists||false> {
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - run instantly delay:1t s@dRegions_Msg 'def:command.addmember.update|<player||server>|%name%'
      }
      else {
      - run instantly delay:1t s@dRegions_Msg 'def:command.addmember.error.4|<player||server>|%name%'
      }

  removemember:
  # /drg reomvemember [ID] g:group player
    - inject locally prerun instantly
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run instantly delay:1t s@dRegions_Msg 'def:region.orphan|<player||server>'
      - queue clear
      }
      else if <def[exists].not> {
      - run instantly delay:1t s@dRegions_Msg 'def:region.noRegion|<player||server>'
      - queue clear
      }
    # Check if is owner
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run instantly delay:1t s@dRegions_Msg 'def:region.notOwner|<player||server>'
        - queue clear
        }
      }
    # Parse specified members
    - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
      - define args '<c.args.remove[<c.args.find[-w].add[1].as_int>].exclude[-w]>'
      - define members '<def[args].get[3].to[<def[args].size>].replace[:].with[;]||null>'
      }
      else {
      - define members '<c.args.get[3].to[<c.args.size>].replace[:].with[;]||null>'
      }
    - if <def[members].is_empty||true> {
      - run instantly delay:1t s@dRegions_Msg 'def:command.removemember.error.0|<player||server>'
      - queue clear
      }
    - foreach %members% {
      - if <def[value].starts_with[g;]||false> {
        - define group '<def[value].replace[g;]>'
        - if <server.list_permission_groups> !contains %group% {
          - run instantly delay:1t s@dRegions_Msg 'def:command.removemember.error.1|<player||server>|%group%'
          - foreach next
          }
        - define groups '<yaml[dRegions_%world%_regions].read[regions.%name%.members.groups]||li@>'
        - if <def[groups].contains[%group%].not||true> {
          - run instantly delay:1t s@dRegions_Msg 'def:command.removemember.error.2|<player||server>|%group%'
          - foreach next
          }
        - define pass true
        - yaml set 'regions.%name%.members.groups:<-:%group%' 'id:dRegions_%world%_regions'
        }
        else {
        - if !<def[value].as_player.is[!=].to[null]||false> {
          - foreach next
          }
        - define players '<yaml[dRegions_%world%_regions].read[regions.%name%.members.players]||li@>'
        - if <def[players].contains[<def[value].as_player.uuid>].not||true> {
          - run instantly delay:1t s@dRegions_Msg 'def:command.removemember.error.3|<player||server>|%value%'
          - foreach next
          }
        - define pass true
        - yaml set 'regions.%name%.members.players:<-:<def[value].as_player.uuid>' 'id:dRegions_%world%_regions'
        - flag <def[value].as_player> 'dRegions.cache.%world%.%name%:!'
        }
      }
    - if <def[pass].exists||false> {
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - run instantly delay:1t s@dRegions_Msg 'def:command.removemember.update|<player||server>|%name%'
      }
      else {
      - run instantly delay:1t s@dRegions_Msg 'def:command.removemember.error.4|<player||server>|%name%'
      }

  list:
  # /drg list (page#) -r region -w world -p player

    - define args '<c.args.remove[1]>'
    # Check the specified player
    - if <def[args].find[-p].is[OR_MORE].than[0]||false> {
      - if !<player.permission[dregions.admin]||<player.is_op||false>> {
        - run instantly delay:1t s@dRegions_Msg 'def:command.list.error.0|<player||server>'
        - queue clear
        }
      - define player '<def[args].get[<def[args].find[-p].add[1].as_int>].escaped||null>'
      - if !<def[player].as_player.is[!=].to[null]||false> {
        - run instantly delay:1t s@dRegions_Msg 'def:command.list.error.1|<player||server>'
        - queue clear
        }
      - define filterPlayer ''
      - define args '<def[args].remove[<def[args].find[-p].add[1].as_int>].exclude[-p]||li@>'
      }
      else {
      - if <context.server.not> {
        - define player '<player.name>'
        }
        else {
        - define player 'null'
        }
      }

    # Check the specified world
    - if <def[args].find[-w].is[OR_MORE].than[0]||false> {
      - define world '<def[args].get[<def[args].find[-w].add[1].as_int>].as_world.name.to_lowercase.escaped||null>'
      - if <def[world].is[==].to[null]||true> {
        - run instantly delay:1t s@dRegions_Msg 'def:command.error.3|<player||server>|<script.yaml_key[commandArgs.list.usage]||No help for you!>'
#        - run instantly delay:1t s@dRegions_Msg 'def:command.list.error.2|<player||server>'
        - queue clear
        }
      - define filterWorld ''
      - define args '<def[args].remove[<def[args].find[-w].add[1].as_int>].exclude[-w]||li@>'
      }
      else {
      - if <context.server.not> {
        - define world '<player.world.name.to_lowercase>'
        }
        else {
        - define world 'null'
        }
      }

    # Does the player want to list the regions where he stands?
    - if <def[args].find[-h].is[OR_MORE].than[0]||false> {
      - define filterHere ''
      - define args '<def[args].remove[<def[args].find[-h]>]||li@>'
      }

    # Do we want to show results for ALL worlds?
    - if <def[args].find[-a].is[OR_MORE].than[0]||false> {
      - define worlds '<server.list_worlds.parse[name.to_lowercase]>'
      - define getAll ''
      - define args '<def[args].remove[<def[args].find[-a]>]||li@>'
      }

    # Check the specified region name
    - if <def[args].find[-r].is[OR_MORE].than[0]||false> {
      - define region '<def[args].get[<def[args].find[-r].add[1].as_int>].escaped||null>'
      - if <def[region].is[!=].to[null]||true> {
        - define exists '<proc[dRegions_RegionExists].context[<def[region]>|<def[world]>]>'
        - if <def[exists].is[==].to[orphan]> {
          - run instantly delay:1t s@dRegions_Msg 'def:region.orphan|<player||server>'
          - queue clear
          }
          else if <def[exists].not> {
          - run instantly delay:1t s@dRegions_Msg 'def:region.noRegion|<player||server>'
          - queue clear
          }
        - if !<player.permission[dregions.admin]||<player.is_op||false>> {
          - if <proc[dRegions_IsOwner].context[<def[region]>|<def[world]>|<player>].not> {
            - run instantly delay:1t s@dRegions_Msg 'def:region.notOwner|<player||server>'
            - queue clear
            }
          }
        }
        else {
        - run instantly delay:1t s@dRegions_Msg 'def:region.empty|<player||server>'
        - queue clear
        }
      - define filterRegion ''
      - define args '<def[args].remove[<def[args].find[-r].add[1].as_int>].exclude[-r]||li@>'
      }

    # OK, we've validated all the user input, let's get the regions and apply filters
    - define regions li@
    - if <def[filterHere].exists> {
      - define standingIn '<player.location.cuboids.parse[notable_name].filter[split[_].get[1].is[==].to[dRegions]].parse[after[dregions_%world%_]].separated_by[,]>'
      - define worldRegions '<proc[dRegions_HighestPriority].context[%world%|%standingIn%]||li@>'
      - if <def[worldRegions].is_empty||true> {
        - define worldRegions 'li@__global__'
        }
      - inject locally filterRegionList
      }
      else if <def[getAll].exists> {
      - foreach %worlds% {
        - define world %value%
        - define worldRegions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
        - inject locally filterRegionList
        }
      }
      else {
      - define worldRegions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__].alphanumeric||li@>'
      - inject locally filterRegionList
      }

    # Display the list
    - define page '<def[args].get[1].replace[-].escaped||1>'
    - define entries 'li@'
    - foreach '<def[regions]>':
      - define color '<t[<def[value].split[.].get[3].is[==].to[owner]>]:&6||<t[<def[value].split[.].get[3].is[==].to[member]>]:&e||&f>>'
      - define entry '<def[loop_index].pad_left[3].with[<&sp>]><&dot.pad_right[2].with[<&sp>]> <proc[msgCommand].context[<%color%><def[value].split[.].get[2]>|drg info <def[value].split[.].get[2]>|<&d>Click for region info]>'
      - define entries '<def[entries].include[%entry%]>'
    - run s@msgBoxed 'def:dRegions|<proc[msgCommand].context[<&6>dRegions|drg help|<&a>Go back to main help]>|<&e>Region List|drg list|%page%|52|10|<def[entries].separated_by[|]>'

  flag:
  # /drg flag [ID] [flag] [value] -g group -w world

    - define args '<c.args.remove[1]>'

    # Check the specified world
    - if <def[args].find[-w].is[OR_MORE].than[0]||false> {
      - define world '<def[args].get[<def[args].find[-w].add[1].as_int>].as_world.name.escaped.to_lowercase||null>'
      - if <def[world].is[==].to[null]||true> {
        - run instantly delay:1t s@dRegions_Msg 'def:command.error.3|<player||server>|<script.yaml_key[commandArgs.flag.usage]||No help for you!>'
        - queue clear
        }
      - define args '<def[args].remove[<def[args].find_all[-w].parse[add[1].as_int]>].exclude[-w]||li@>'
      }
      else {
      - if <context.server.not> {
        - define world '<player.world.name.to_lowercase>'
        }
        else {
        - define world 'null'
        }
      }

    # Check the specified group
    - if <def[args].find[-g].is[OR_MORE].than[0]||false> {
      - define group '<def[args].get[<def[args].find[-g].add[1].as_int>].escaped.to_lowercase||null>'
      - if !<el@val[members|nonmembers|owners|nonowners|all].as_list.contains[%group%]||false> {
        - run instantly delay:1t s@dRegions_Msg 'def:command.flag.error.0|<player||server>|<def[group].unescaped>'
        - queue clear
        }
      - define args '<def[args].remove[<def[args].find_all[-g].parse[add[1].as_int]>].exclude[-g]||li@>'
      }

    # Check the specified region name
    - define region '<def[args].get[1].escaped.to_lowercase||null>'
    - if <def[region].is[!=].to[null]||true> {
      - define exists '<proc[dRegions_RegionExists].context[<def[region]>|<def[world]>]>'
      - if <def[exists].is[==].to[orphan]> {
        - run instantly delay:1t s@dRegions_Msg 'def:region.orphan|<player||server>'
        - queue clear
        }
        else if <def[exists].not> {
        - run instantly delay:1t s@dRegions_Msg 'def:region.noRegion|<player||server>'
        - queue clear
        }
      - if !<player.permission[dregions.admin]||<player.is_op||false>> {
        - if <proc[dRegions_IsOwner].context[<def[region]>|<def[world]>|<player>].not> {
          - run instantly delay:1t s@dRegions_Msg 'def:region.notOwner|<player||server>'
          - queue clear
          }
        }
      }
      else {
      - run instantly delay:1t s@dRegions_Msg 'def:region.empty|<player||server>'
      - queue clear
      }

    # Check the specified flag name
    - define flag '<def[args].get[2].escaped.to_lowercase||null>'
    - if <def[flag].is[!=].to[null]||true> {
      - define flags '<server.list_scripts.filter[starts_with[s@dRegions_Flag_]].parse[name.split[_].get[3]]||li@>'
      - if !<def[flags].contains[%flag%]||false> {
        - run instantly delay:1t s@dRegions_Msg 'def:command.flag.error.1|<player||server>'
        - queue clear
        }
      }
      else {
      - run instantly delay:1t s@dRegions_Msg 'def:command.flag.error.1|<player||server>'
      - queue clear
      }

    # By this point, we know the flag is being set or cleared, so let's clear the flag
    # cache for this region, any child regions, and any overlapping regions including __global__
    - run instantly delay:1t s@dRegions p:clearCache 'def:%region%|%world%|%flag%'

    # Check the specified flag value and set or clear it.
    - define flagValue '<def[args].get[3].to[<def[args].size>].space_separated.escaped||null>'
    - if <def[flagValue].is[!=].to[null]||true> {
      - define type '<s@dRegions_Flag_%flag%.yaml_key[flag_type]>'
      - if <def[type].is[==].to[location]> {
        - if <def[flagValue].is[==].to[here]||true> {
          - define flagValue '<player.location.simple>'
          }
        }
      - define typeMatch '<proc[dRegion_FlagTypeMatch].context[%flagValue%|%flag%]>'
      - if !<def[TypeMatch]> {
        - define lines '<proc[dRegions_LineWrap].context[<s@dRegions_Flag_%Flag%.yaml_key[flag_help]||<&c>%flag% flag requires a %type% value!>|45]>'
        - foreach <def[lines]> {
          - run instantly delay:1t s@dRegions_Msg 'def:command.help.syntax|<player||server>|<&c><def[value]>'
          }
        - queue clear
        }
      - if <li@st|sg|stg|stsg.contains[%type%]||false>
        && <def[flagValue].is[==].to[none]||false> {
        - inject s@dRegions_Flag_%flag% p:command_handler
        - yaml set 'regions.%region%.flags.%flag%:!' 'id:dRegions_%world%_regions'
        - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
        - yaml 'savefile:dRegions/worlds/%world%/cache.yml' 'id:dRegions_%world%_cache'
        - run instantly delay:1t s@dRegions_Msg 'def:command.flag.clear|<player||server>|%flag%|%region%'
        - queue clear
        }
      - inject s@dRegions_Flag_%flag% p:command_handler
      - if <s@dRegions_Flag_%flag%.yaml_key[flag_takeGroup]||false> && <def[group].exists> {
        - yaml set 'regions.%region%.flags.%flag%:<def[flagValue].unescaped>/%group%' 'id:dRegions_%world%_regions'
        }
        else {
        - yaml set 'regions.%region%.flags.%flag%:<def[flagValue].unescaped>' 'id:dRegions_%world%_regions'
        }
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - define string "<&f><&o>%region%<&7><&o> set %flag% flag to <&f><&o>%flagValue%"
      - define lines '<proc[dRegions_LineWrap].context[<def[string]>|45]>'
      - foreach <def[lines]> {
        - run instantly delay:1t s@dRegions_Msg 'def:command.help.syntax|<player||server>|<&f><&o><def[value].unescaped>'
        }
      }
      else {
      - inject s@dRegions_Flag_%flag% p:command_handler
      - yaml set 'regions.%region%.flags.%flag%:!' 'id:dRegions_%world%_regions'
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - run instantly delay:1t s@dRegions_Msg 'def:command.flag.clear|<player||server>|%flag%|%region%'
      - queue clear
      }

  setpriority:
  # /drg setpriority [ID] [#]
    - inject locally prerun instantly
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run instantly delay:1t s@dRegions_Msg 'def:region.orphan|<player||server>'
      - queue clear
      }
      else if <def[exists].not> {
      - run instantly delay:1t s@dRegions_Msg 'def:region.noRegion|<player||server>'
      - queue clear
      }
    # Check if is owner
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run instantly delay:1t s@dRegions_Msg 'def:region.notOwner|<player||server>'
        - queue clear
        }
      }
    # Verify specified priority
    - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
      - define args '<c.args.remove[<c.args.find[-w].add[1].as_int>].exclude[-w]>'
      - define priority '<def[args].get[3].escaped||null>'
      }
      else {
      - define priority '<c.args.get[3].escaped||null>'
      }
    - if <def[priority].is[matches].to[number].not||true> {
      - run instantly delay:1t s@dRegions_Msg 'def:command.setpriority.error.0|<player||server>'
      - queue clear
      }
    # Update region
    - yaml set 'regions.%name%.priority:%priority%' 'id:dRegions_%world%_regions'
    - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
    - run instantly delay:1t s@dRegions_Msg 'def:command.setpriority.set|<player||server>|%name%|%priority%'

  setparent:
  # /drg setparent [ID] [parent]
    - inject locally prerun instantly
    # Check if child region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run instantly delay:1t s@dRegions_Msg 'def:region.orphan|<player||server>'
      - queue clear
      }
      else if <def[exists].not> {
      - run instantly delay:1t s@dRegions_Msg 'def:region.noRegion|<player||server>'
      - queue clear
      }
    # Check if is owner
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run instantly delay:1t s@dRegions_Msg 'def:region.notOwner|<player||server>'
        - queue clear
        }
      }
    # Check if parent region exists
    - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
      - define args '<c.args.remove[<c.args.find[-w].add[1].as_int>].exclude[-w]>'
      - define parent '<def[args].get[3].escaped||null>'
      }
      else {
      - define parent '<c.args.get[3].escaped||null>'
      }
    - if %parent% == null {
      - define parent <yaml[dRegions_%world%_regions].read[regions.%name%.parent]||null>
      - if %parent% != null {
        - yaml set 'regions.%parent%.children:<-:%name%' 'id:dRegions_%world%_regions'
        }
      - yaml set 'regions.%name%.parent:!' 'id:dRegions_%world%_regions'
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - run instantly delay:1t s@dRegions_Msg 'def:command.setparent.unset|<player||server>|%name%'
      - queue clear
      }
    # Check if parent region exists
    - define exists '<proc[dRegions_RegionExists].context[%parent%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run instantly delay:1t s@dRegions_Msg 'def:region.orphan|<player||server>'
      - queue clear
      }
      else if <def[exists].not> {
      - run instantly delay:1t s@dRegions_Msg 'def:region.noRegion|<player||server>'
      - queue clear
      }
    # Check if player owns parent
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%parent%|%world%|<player>].not> {
        - run instantly delay:1t s@dRegions_Msg 'def:region.notOwner|<player||server>'
        - queue clear
        }
      }
    # Update the region
    - yaml set 'regions.%name%.parent:%parent%' 'id:dRegions_%world%_regions'
    - if <yaml[dRegions_%world%_regions].read[regions.%parent%.children]||li@> contains %name% {
      - yaml set 'regions.%parent%.children:<-:%name%' 'id:dRegions_%world%_regions'
      }
      else {
      - yaml set 'regions.%parent%.children:->:%name%' 'id:dRegions_%world%_regions'
      }
    - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
    - run instantly delay:1t s@dRegions_Msg 'def:command.setparent.set|<player||server>|%name%|%parent%'

  teleport:
  # /drg teleport [ID] -w world
    - narrate "Stub"
    - inject locally prerun instantly
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists]> == orphan {
      - run instantly delay:1t s@dRegions_Msg 'def:region.orphan|<player||server>'
      - queue clear
      }
      else if !%exists% {
      - run instantly delay:1t s@dRegions_Msg 'def:region.noRegion|<player||server>'
      - queue clear
      }
    # Check if is owner
    - if !<player.permission[dregions.admin]||false> && !<player.is_op> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run instantly delay:1t s@dRegions_Msg 'def:region.notOwner|<player||server>'
        - queue clear
        }
      }
    # Check for teleport perms
    - if !<player.permission[dregions.teleport]||false> && !<player.permission[dregions.teleport.own]||false> && !<player.permission[dregions.teleport.own.%name%]||false> {
      - run instantly delay:1t s@dRegions_Msg 'def:command.error.1|<player||server>'
      - queue clear
      }

  remove:
  # /drg remove [ID] -w world
    - inject locally prerun instantly
    # Check if region exists
    - define exists '<proc[dRegions_RegionExists].context[%name%|%world%]>'
    - if <def[exists].is[==].to[orphan]> {
      - run instantly delay:1t s@dRegions_Msg 'def:region.orphan|<player||server>'
      - queue clear
      }
      else if <def[exists].not> {
      - run instantly delay:1t s@dRegions_Msg 'def:region.noRegion|<player||server>'
      - queue clear
      }
    # Don't remove the __global__ region
    - if <def[name].is[==].to[__global__]> {
      - run instantly delay:1t s@dRegions_Msg 'def:command.remove.error.0|<player||server>'
      - queue clear
      }
    # Check if is owner
    - if !<player.permission[dregions.admin]||<player.is_op||false>> {
      - if <proc[dRegions_IsOwner].context[%name%|%world%|<player>].not> {
        - run instantly delay:1t s@dRegions_Msg 'def:region.notOwner|<player||server>'
        - queue clear
        }
      }
    # Remove region from ancestry
    # This should be done smarterer now since regions know both children and parents.
    - define regions '<yaml[dRegions_%world%_regions].list_keys[regions].exclude[__global__]||li@>'
    - foreach %regions% {
      - if <yaml[dRegions_%world%_regions].read[regions.%value%.parent]||null> == %name% {
        - yaml set 'regions.%value%.parent:<-:%name%' 'id:dRegions_%world%_regions'
        }
      - if <yaml[dRegions_%world%_regions].read[regions.%value%.children]||li@> contains %name% {
        - yaml set 'regions.%value%.children:<-:%name%' 'id:dRegions_%world%_regions'
        }
      }
    # Remove the region
    - yaml set 'regions.%name%:!' 'id:dRegions_%world%_regions'
    - note remove 'as:dregions_%world%_%name%'
    - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
    - run instantly delay:1t s@dRegions_Msg 'def:remove.remove|<player||server>|%name%|%world%'

#
#  END dRegions Command Arguments
#--------------------------------------
#
#  dRegions Command Utilities
#
# Just some commonly used code blocks
#
  prerun:
  # Block of checks run before /most/ commands
    - if !<player.permission[dRegions.%command%]||false> && !<player.is_op> {
      - inject locally help
      - queue clear
      }
    - if <c.args.find[-w].is[OR_MORE].than[0]||false> {
      - define world '<c.args.get[<c.args.find[-w].add[1].as_int>].escaped.as_world.name.to_lowercase||null>'
      - if <def[world].is[==].to[null]||true> {
        - run instantly delay:1t s@dRegions_Msg 'def:command.error.3|<player>|<script.yaml_key[commandArgs.%command%.usage]>'
        - queue clear
        }
      - define args '<c.args.remove[<c.args.find[-w].add[1].as_int>].exclude[-w]>'
      - define name '<def[args].get[2].escaped.to_lowercase||null>'
      }
      else {
      - define world '<player.world.name.to_lowercase>'
      }
    - if <li@define|redefine|claim.contains[%command%]> {
      - if '<yaml[dRegions_global_config].read[config.regions.wand]||unset>' == 'dwe_wand' {
        - define wandType '<player.flag[dWEWand_Type]||cuboid>'
        - define pos1 '<player.flag[dWEWand].get[1].as_location||null>'
        - define pos2 '<player.flag[dWEWand].get[2].as_location||null>'
        }
        else {
        - define item '<player.item_in_hand>'
        - if !<def[item].has_nbt[dRegions_Tool]||false> {
          - run instantly delay:1t s@dRegions_Msg 'def:command.error.2|<player>'
          - queue clear
          }
        - define wandType '<def[item].nbt[dRegions_WandType]||cuboid>'
        - define pos1 '<def[item].nbt[dRegions_Pos1].as_location||null>'
        - define pos2 '<def[item].nbt[dRegions_Pos2].as_location||null>'
        }
      - if <li@cuboid|extender.contains[%wandType%].not||true> {
        - run instantly delay:1t s@dRegions_Msg 'def:command.error.4|<player||server>|<script.yaml_key[commandArgs.%command%.usage]>'
        - queue clear
        }
      - if <def[pos1].is[==].to[null]>
        || <def[pos2].is[==].to[null]> {
        - run instantly delay:1t s@dRegions_Msg 'def:command.error.5|<player||server>|<script.yaml_key[commandArgs.%command%.usage]>'
        - queue clear
        }
      - if <def[pos1].world.name.is[!=].to[%world%]>
        || <def[pos2].world.name.is[!=].to[%world%]> {
        - run instantly delay:1t s@dRegions_Msg 'def:command.error.6|<player||server>|<script.yaml_key[commandArgs.%command%.usage]>'
        - queue clear
        }
      - define selectedCuboid '<cu@%pos1%|%pos2%>'
      }
    - define name '<def[name]||<c.args.get[2].escaped.to_lowercase||null>>'
    - if '<def[name].is[==].to[null]||true>' {
      - if <li@info|select.contains[%command%]> {
        - define dRegions '<player.location.cuboids.parse[notable_name].filter[split[_].get[1].is[==].to[dRegions]].parse[after[dregions_%world%_]].separated_by[,]>'
        - define orderedRegions '<proc[dRegions_HighestPriority].context[%world%|%dRegions%]>'
        - if <def[orderedRegions].is_empty||true> {
          - define name '__global__'
          }
          else {
          - define name '<def[orderedRegions].get[1]>'
          - if <def[orderedRegions].size.is[MORE].than[1]> {
            - run instantly delay:1t s@dRegions_Msg 'def:region.multiRegions|<player||server>|info'
            }
          }
        }
        else {
        - run instantly delay:1t s@dRegions_Msg 'def:region.empty|<player||server>'
        - run instantly delay:1t s@dRegions_Msg 'def:command.help.syntax|<player||server>|<&f><script.yaml_key[commandArgs.%command%.usage]>'
        - queue stop
        }
      }
    - if '<def[name].matches[^[a-z0-9-_]+$].not>' {
      - run instantly delay:1t s@dRegions_Msg 'def:region.invalidName|<player||server>'
      - run instantly delay:1t s@dRegions_Msg 'def:command.help.syntax|<player||server>|<&f><script.yaml_key[commandArgs.%command%.usage]>'

      - queue stop
      }
    - define page "<t[<c.args.filter[is[matches].to[number]].is_empty.not>]:<c.args.filter[is[matches].to[number]].get[1]>||1>"
#    - inject s@dRegions_Commands p:selection_Size instantly
#    - define oldSize '%size%'


  filterRegionList:
  # Used in /drg list to apply various filters
    - if <def[filterRegion].exists||false> {
      - define filteredRegions 'li@'
      - foreach %worldRegions% {
        - define worldRegion '%value%'
        - if <yaml[dRegions_%world%_regions].read[regions.%worldRegion%.parent].is[==].to[<def[region]>]||false> {
          - define filteredRegions '<def[filteredRegions].include[%worldRegion%]||<def[filteredRegions]>>'
          }
        }
      }
    - if <def[filteredRegions].exists> {
      - define worldRegions '<def[filteredRegions]>'
      }
    - foreach %worldRegions% {
      - define worldRegion '%value%'
      - if <proc[dRegions_IsOwner].context[<def[worldRegion]>|<def[world]>|<def[player].as_player>]||false> {
        - define regions '<def[regions].include[<def[world]>.<def[worldRegion]>.owner]||<def[regions]>>'
        }
        else if <proc[dRegions_IsMember].context[<def[worldRegion]>|<def[world]>|<def[player].as_player>]||false> {
        - define regions '<def[regions].include[<def[world]>.<def[worldRegion]>.member]||<def[regions]>>'
        }
        else if <def[filterPlayer].exists.not||true> {
        - define regions '<def[regions].include[<def[world]>.<def[worldRegion]>.nonmember]||<def[regions]>>'
        }
      }

  regionInfo:
  # Build the data set for region info
    - define type '<yaml[dRegions_%world%_regions].read[regions.%name%.type]||null>'
    - if <def[type].is[==].to[cuboid]||false> {
      - define POS1 '<yaml[dRegions_%world%_regions].read[regions.%name%.min]||null>'
      - define POS2 '<yaml[dRegions_%world%_regions].read[regions.%name%.max]||null>'
      - define size '<proc[selectionSize].context[%pos1%|%pos2%]>'
      }
      else if <def[type].is[==].to[global]||false> {
      - define POS1 '0,0,0,%world%'
      - define POS2 '0,0,0,%world%'
      - define size 'infinite'
      }
      else {
      - run instantly delay:1t s@dRegions_Msg 'def:region.misconfigured|<player||server>'
      - queue clear
      }
    - define priority '<yaml[dRegions_%world%_regions].read[regions.%name%.priority]||0>'
    - define parent '<yaml[dRegions_%world%_regions].read[regions.%name%.parent]||<&c>none>'
    - define ownerGroups '<yaml[dRegions_%world%_regions].read[regions.%name%.owners.groups]||li@>'
    - define ownerPlayers '<yaml[dRegions_%world%_regions].read[regions.%name%.owners.players]||li@>'
    - define memberGroups '<yaml[dRegions_%world%_regions].read[regions.%name%.members.groups]||li@>'
    - define memberPlayers '<yaml[dRegions_%world%_regions].read[regions.%name%.members.players]||li@>'
    - define flagList '<yaml[dRegions_%world%_regions].list_keys[regions.%name%.flags]||li@>'
    - define flags 'li@'
    - foreach %flagList% {
      - define flags '<def[flags].include[%value%/<yaml[dRegions_%world%_regions].read[regions.%name%.flags.%value%].as_list.comma_separated||null>]||%flags%>'
      }

#
#  END dRegions dRegions Command Utilities
#--------------------------------------
#
#  dRegions Command Messages
#
# Some messages used by commands. Should probably move to s@dRegions_Msg
#
  msgsHeader:
    - narrate "<&5>|----------------------------------------|"
    - narrate "<&5>|<&sp><&sp><&sp><&6>dRegions   <&7><def[msgsHeaderTitle]||>"
    - narrate "<&5>|<&f>"

  msgsFooter:
#    - define anthony "text<&co>'<&7>|Anthony|',clickEvent<&co><&chr[007B]>action<&co>open_url,value<&co>'http<&co>//mineconomy.org'<&chr[007D]>,hoverEvent<&co><&chr[007B]>action<&co>show_item,value<&co>'<&chr[007B]><i@dRegions_Author_Anthony.json><&chr[007D]>'<&chr[007D]>"
#    - define spacer "text<&co>'  '"
#    - define prefix "text<&co>'<&5>|  <&f>Authors<&co>  '"
    - if <player.is_player||false> {
# JSON is broken in denizen. Just narrate for now.
      - narrate "<&5>|  <&f>Authors<&co>  <&7>|Anthony|"
#      - execute as_server "tellraw <player.name> <&chr[007B]>text<&co>'',extra<&co>[<&chr[007B]>%prefix%<&chr[007D]>,<&chr[007B]>%anthony%<&chr[007D]>]<&chr[007D]>"
      }
      else {
      - announce to_console "<&5>|  <&f>Authors<&co>    <&7>|Anthony|"
      }
    - narrate "<&5>|-----------<&d>S<&5>-<&d>c<&5>-<&d>r<&5>-<&d>o<&5>-<&d>l<&5>-<&d>l<&5>---<&d>U<&5>-<&d>p<&5>-------------|"

  msgsHelpAdmin:
    # Filter the list of commands this player can use
    - define commands '<s@dRegions_Commands.list_keys[commandArgs].alphanumeric.to_lowercase||li@>'
    - foreach %commands% {
      - if !<player.permission[dregions.%value%]||<player.is_op||<c.server||false>>> {
        - define commands '<def[commands].exclude[%value%]>'
        }
      }

    # Display the list
    - define page '<def[arg].replace[-].escaped||1>'
    - if <def[page].is[MATCHES].to[number].not> {
      - define page '1'
      }
    - define pages '<def[commands].size.div[5].round_up||1>'
    - if <def[page].is[MORE].than[%pages%]> {
      - define page '%pages%'
      }
    - define highNumber '<def[page].mul[5].as_int>'
    - define lowNumber '<def[highNumber].sub[4].as_int>'
    - define msgsHeaderTitle '<&e>Admin Help   <el@val[<&7><&o>Page <&f><&o>%page% <&7><&o>of %pages%].pad_left[30]>'
    - inject locally msgsHeader instantly
    - foreach <def[commands].get[%lowNumber%].to[%highNumber%]||li@> {
      - narrate "<&5>|<&sp><&sp><&f><def[value].to_titlecase><&co>"
      - narrate "<&5>|<&sp><&sp><&sp><&sp><&7><parse:<script.yaml_key[commandArgs.%value%.usage]||No usage info available!>>"
      }
    - narrate "<&5>|"

  msgsHelpUser:
    - define msgsHeaderTitle 'User Help'
    - inject locally msgsHeader instantly
    - define par1 "dRegions is an advanced region management and world protection system written with the Denizen Scripting Engine."
    - define par2 "Heavily inspired by WorldGuard, the goal is to have an extremely efficient events system supporting an exhaustive set of region flags and configuration options."
    - define par3 "dRegions offers an intuitive command interface and provides thorough TAB completion."
    - define strings "<el@val[%par1%|%par2%|%par3%].as_list>"
    - foreach <def[strings]> {
      - define string "<&f><&sp><def[value]>"
      - define lines '<proc[dRegions_LineWrap].context[<def[string]>|44]>'
      - foreach <def[lines]> {
        - narrate "<&5>|<&f><&sp><&sp><def[value].unescaped>"
        }
      - narrate "<&5>|"
      }
#
#  END dRegions Command Messages
#
#--------------------------------------
#
dRegions_Commands_Help:
  type: command
  debug: false
  speed: 0
  name: drghelp
  description: Show dRegions help
  usage: /drg help
  aliases: ''
  allowed help: ''

  data:
    description:
      - ' This is the help for dRegions. The help files are here to help you. Help yourself by reading the help. It<&sq>s helpful. <&c>Seriously!'
      - ' '
      - ' Thorough TAB completion is available for all dRegions commands, including help. Try it and see!'
    usage: '/drg help <&lt>arg/<&ns><&gt>'
    examples:
      - ' <&f>To show the <&a>second<&f> page of help for the <&2>help<&f> command'
      - '<&sp>'
      - '   <&e>/drg help <&2>help <&a>2'
      - ' '
      - ' <&f>To show the <&a>third<&f> page of the help files'
      - '<&sp>'
      - '   <&e>/drg help <&a>3'
    permissions: []

  tab complete:
    - if !<def[command].exists> {
      - define commands '<server.flag[drg.Command_List].as_list||li@>'
      - define args "<c.args>"
      }
    - define command '<def[args].get[1].escaped||>'
    - if <def[commands].contains[%command%]> {
      - determine 'li@'
      }
      else {
      - define commands '<def[commands].filter[starts_with[%command%]]||%commands%>'
      }
    - foreach %commands% {
      - if !<proc[dRegions_HasPerm_Command].context[%command%|<player||server>]> {
        - define commands '<def[commands].exclude[%value%]||%commands%>'
        }
      }
    - if <def[commands].is_empty||true> {
      - determine 'li@'
      }
    - determine '<def[commands]||li@>'

  script:
    - if !<def[command].exists> {
      - define command 'help'
      }
    - define commands '<s@dRegions_Commands.list_keys[commandArgs].alphanumeric.to_lowercase||li@>'
    - define args "<context.args>"
    - define arg '<def[args].get[1].escaped||1>'
    - if <def[arg].is[matches].to[number]> {
      - define page '<def[arg].abs.round||1>'
      - inject s@dRegions_Commands_Help p:helpList
      - queue clear
      }
    - if <def[commands].contains[%arg%]||false> {
      - define command '%arg%'
      - define page '<tern[<def[args].get[2].is[matches].to[number]||false>]:<def[args].get[2].abs.round>||1>'
      - inject s@dRegions_Commands_Help p:helpCommand
      - queue clear
      }
    - inject s@dRegions_Commands_Help p:helpList
    - queue clear

  helpList:
    # Filter the list of commands this player can use
    - define helpDoc 'li@'
    - if !<player.permission[dregions.admin]||<player.is_op||<c.server||false>>> {
      - foreach '%commands%' {
        - if !<player.permission[dregions.%value%]||false> {
          - define commands '<def[commands].exclude[%value%]>'
          }
        }
      }
    # Build the help documentation
    - if <c.server||false> {
      - foreach '%commands%' {
        - define helpDoc '<def[helpDoc].include[<&f><def[value].to_titlecase><&co>|<&e.pad_right[5]><parse:<s@dRegions_Commands.yaml_key[commandArgs.%value%.usage]||No usage info available!>>]>'
        }
      - run s@dRegions_Msg_Boxed_Console instantly 'def:dRegions|Help Files|<def[page]||1>|52|20|<def[helpDoc].separated_by[|]>'
      - queue clear
      }
    - foreach '%commands%':
      - define tButton '"text":"<def[value].to_titlecase><&co>","color":"white","clickEvent":{"action":"run_command","value":"/drghelp %value%"},"hoverEvent":{"action":"show_text","value":["",{"text":"Click for %value% help","color":"green"}]}'
      - define syntax '<parse:<s@dRegions_Commands.yaml_key[commandArgs.%value%.usage]||No usage info available!>>'
      - define sButton '"text":"<&e.pad_right[5]><def[syntax].substring[1,52]>","color":"yellow"'
      - define helpDoc '<def[helpDoc].include[<def[tButton]>|<def[sButton]>]>'
    - run s@dRegions_Msg_Boxed instantly 'def:dRegions|Help Files|drghelp|<def[page]||1>|52|10|<def[helpDoc].separated_by[|]>'

  helpCommand:
    # Help for a specific command
    - if <c.server||false> {
      - define short '<&7><parse:<s@dRegions_Commands_%command%.yaml_key[description]||A not so useless description should be here!>>'
      - define desc '<list[]>'
      - foreach '<parse:<s@dRegions_Commands_%command%.yaml_key[data.description]||A not so useless description should be here!>>' {
        - foreach '<proc[dRegions_LineWrap].context[%value%|52]>' {
          - define desc '<def[desc].include[<&f>%value%]>'
          }
        }
      - define usage '   <&e><parse:<s@dRegions_Commands_%command%.yaml_key[data.usage]||No help for you!>>'
      - define examples '<list[]>'
      - foreach '<parse:<s@dRegions_Commands_%command%.yaml_key[data.examples]||No help for you!>>' {
        - foreach '<proc[dRegions_LineWrap].context[%value%|52]>' {
          - define examples '<def[examples].include[<&e>%value%]>'
          }
        }
      - define entries '%short%| |<def[desc].separated_by[|]>| |<&b><&n>Usage<&co>| |%usage%| |<&3><&n>Examples<&co>| |<def[examples].separated_by[|]>'
      - run s@dRegions_Msg_Boxed_Console instantly 'def:dRegions|Help Files|<def[page]||1>|52|10|%entries%'
      - queue clear
      }
    - define short '"text":"<parse:<s@dRegions_Commands_%command%.yaml_key[description]||A not so useless description should be here!>>","color":"gray"'
    - define desc '<list[]>'
    - foreach '<parse:<s@dRegions_Commands_%command%.yaml_key[data.description]||A not so useless description should be here!>>':
      - foreach '<proc[dRegions_LineWrap].context[%value%|52]>':
        - define desc '<def[desc].include["text":"%value%","color":"white"]>'
    - define usage '"text":"   <parse:<s@dRegions_Commands_%command%.yaml_key[data.usage]||No help for you!>>","color":"yellow"'
    - define examples '<list[]>'
    - foreach '<parse:<s@dRegions_Commands_%command%.yaml_key[data.examples]||No help for you!>>':
      - foreach '<proc[dRegions_LineWrap].context[%value%|52]>':
        - define examples '<def[examples].include["text":"%value%"]>'
    - define nl '"text":" "'
    - define u '"text":"Usage<&co>","color":"aqua","underlined":true'
    - define e '"text":"Examples<&co>","color":"dark_aqua","underlined":true'
    - define entries '%short%|%nl%|<def[desc].separated_by[|]>|%nl%|%u%|%nl%|%usage%|%nl%|%e%|%nl%|<def[examples].separated_by[|]>'
    - run s@dRegions_Msg_Boxed instantly 'def:dRegions|Help - <def[command].to_titlecase>|drghelp %command%|<def[page]||1>|52|10|%entries%'
#
#  END dRegions Help Command
#
#-------------------------------------
#
# Used to process input for some flags
#
dRegions_Flags_CommandProcessors:
  type: task
  debug: false

  command_verifiedList:
    - if <def[flagValue].is[==].to[null]||false> {
      - yaml set 'regions.%region%.flags.%flag%:!' 'id:dRegions_%world%_regions'
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - run instantly delay:1t s@dRegions_Msg 'def:flag.clear|<player||server>|%flag%|%region%'
      - queue clear
      }
      else {
      - define entries '<def[flagValue].split[ ].get[2].to[<def[flagValue].split[ ].size>].parse[to_lowercase].deduplicate||li@>'
      - if <def[entries].get[1].is[==].to[all]> {
        - if '<def[flagValue].split[ ].get[1].is[==].to[-a]||false>' {
          - yaml set 'regions.%region%.flags.%flag%:all' 'id:dRegions_%world%_regions'
          - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
          - run instantly delay:1t s@dRegions_Msg 'def:flag.set|<player||server>|%region%|%flag%|%flagValue%'
          - queue clear
          }
        - if '<def[flagValue].split[ ].get[1].is[==].to[-r]||false>' {
          - yaml set 'regions.%region%.flags.%flag%:!' 'id:dRegions_%world%_regions'
          - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
          - run instantly delay:1t s@dRegions_Msg 'def:flag.clearlist|<player||server>|%flag%|%region%'
          - queue clear
          }
        }
      - foreach %entries% {
        - if <parse:<s@dRegions_Flag_%Flag%.yaml_key[command_verifyEntry]||false>> {
          - define entries '<def[entries].exclude[%value%]||li@>'
          - run instantly delay:1t s@dRegions_Msg 'def:flag.error.2|<player||server>|%value%|<s@dRegions_Flag_%Flag%.yaml_key[command_entryType]>'
          }
        }
      - if <def[entries].is_empty||true> {
        - run instantly delay:1t s@dRegions_Msg 'def:flag.error.3|<player||server>|<s@dRegions_Flag_%Flag%.yaml_key[command_entryType]>'
        - define lines '<proc[dRegions_LineWrap].context[<s@dRegions_Flag_%Flag%.yaml_key[flag_help]||<&c>%flag% flag requires a %type% value!>|45]>'
        - foreach <def[lines]> {
          - run instantly delay:1t s@dRegions_Msg 'def:command.help.syntax|<player||server>|<&c><def[value]>'
          }
        - queue clear
        }

      - define currentEntries '<yaml[dRegions_%world%_regions].read[regions.%region%.flags.%flag%].replace[, ].with[|].as_list||li@>'
      - if '<def[flagValue].split[ ].get[1].is[==].to[-a]||false>' {
        - define flagValue '<def[currentEntries].include[<def[entries].replace[li@]>].deduplicate||li@>'
        }
      - if '<def[flagValue].split[ ].get[1].is[==].to[-r]||false>' {
        - define flagValue '<def[currentEntries].exclude[<def[entries].replace[li@]>].deduplicate||li@>'
        }
      - if <def[flagValue].is_empty||true> {
        - yaml set 'regions.%region%.flags.%flag%:!' 'id:dRegions_%world%_regions'
        - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
        - run instantly delay:1t s@dRegions_Msg 'def:flag.clearlist|<player||server>|%flag%|%region%'
        - queue clear
        }
      - define flagValue '<def[flagValue].comma_separated>'
      }


  command_stringList:
    - if <def[flagValue].is[==].to[null]||false> {
      - yaml set 'regions.%region%.flags.%flag%:!' 'id:dRegions_%world%_regions'
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - run instantly delay:1t s@dRegions_Msg 'def:flag.clearlist|<player||server>|%flag%|%region%'
      - queue clear
      }
    - define action '<def[flagValue].split[ ].get[1]>'
    - define string '<def[flagValue].after[<def[action]>]>'

    - if '<def[string].is[==].to[all]>' {
      - if <def[action].is[==].to[-a]||false> {
        - yaml set 'regions.%region%.flags.%flag%:all' 'id:dRegions_%world%_regions'
        - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
        - run instantly delay:1t s@dRegions_Msg 'def:flag.set|<player||server>|%region%|%flag%|%flagValue%'
        - queue clear
        }
      - if <def[action].is[==].to[-r]||false> {
        - yaml set 'regions.%region%.flags.%flag%:!' 'id:dRegions_%world%_regions'
        - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
        - run instantly delay:1t s@dRegions_Msg 'def:flag.clearlist|<player||server>|%flag%|%region%'
        - queue clear
        }
      }
    - if <def[string].length.is[==].to[0]||true> {
      - run instantly delay:1t s@dRegions_Msg 'def:flag.error.3|<player||server>|<s@dRegions_Flag_%Flag%.yaml_key[command_entryType]>'
      - define lines '<proc[dRegions_LineWrap].context[<s@dRegions_Flag_%Flag%.yaml_key[flag_help]||<&c>%flag% flag requires a %type% value!>|45]>'
      - foreach <def[lines]> {
        - run instantly delay:1t s@dRegions_Msg 'def:command.help.syntax|<player||server>|<&c><def[value]>'
        }
      - queue clear
      }

    - define currentEntries '<yaml[dRegions_%world%_regions].read[regions.%region%.flags.%flag%].replace[ ; ].with[|].as_list||li@>'
    - if '<def[action].is[==].to[-a]||false>' {
      - define flagValue '<def[currentEntries].include[<def[string]>].deduplicate||li@>'
      }
    - if '<def[action].is[==].to[-r]||false>' {
      - define flagValue '<def[currentEntries].exclude[<def[string]>].deduplicate||li@>'
      }
    - if <def[flagValue].is_empty||true> {
      - yaml set 'regions.%region%.flags.%flag%:!' 'id:dRegions_%world%_regions'
      - yaml 'savefile:dRegions/worlds/%world%/regions.yml' 'id:dRegions_%world%_regions'
      - run instantly delay:1t s@dRegions_Msg 'def:flag.clearlist|<player||server>|%flag%|%region%'
      - queue clear
      }
    - define flagValue '<def[flagValue].replace[|].with[ ; ].replace[li@]>'

#
################################################################################
#
#  FlagTypeMatch Procedure script
#
#    Used to check that the player specified value matches the type required
#   by the flag.
#
#    Use this to compare 2 values. Check if they are one of NUMBER, DECIMAL,
#   LOCATION, BOOLEAN, STATE, GROUP, LIST or any other STRING.
#
#   usage:
#     - define YourValue "Some string"
#     - define Type "<s@dRegions_Flag_%flag%.yaml_key[flag_type]||null>"
#     - define TypeMatch '<proc[dRegion_FlagTypeMatch].context[%YourValue%|%flag%]>'
#     - if <def[TypeMatch]> {
#       - narrate "%YourValue% matches %type%."
#       }
#       else {
#       - narrate "%YourValue% is not a %type%"
#       }
#
dRegion_FlagTypeMatch:
# Used to check if the value supplied when setting a flag is valid for the flag type.
  type: procedure
  debug: false
  definitions: YourValue|Flag

  script:
    - choose '<s@dRegions_Flag_%Flag%.yaml_key[flag_type]||null>':
      - case 'decimal':
        - determine '<def[YourValue].is[MATCHES].to[number]>'
      - case 'number':
        - determine '<def[YourValue].is[MATCHES].to[number].and[<def[YourValue].as_int.is[==].to[%YourValue%]>]>'
      - case 'b':
        - determine '<def[YourValue].is[MATCHES].to[boolean]>'
      - case 'location':
        - determine '<def[YourValue].as_location.world.is[!=].to[null]||false>'
      - case 'stg':
        - determine '<li@allow|deny|none.contains[%YourValue%]||false>'
      - case 'st':
        - determine '<li@allow|deny|none.contains[%YourValue%]||false>'
      - case 'sg':
        - determine '<li@allow|deny|none.contains[%YourValue%]||false>'
      - case 'stsg':
        - determine '<li@allow|deny|none.contains[%YourValue%]||false>'
      - case 'group':
        - determine '<li@members|nonmembers|owners|nonowners|all.as_list.contains[%YourValue%]||false>'
      - case 'list':
        - determine '<def[YourValue].split[ ].get[1].contains_any_text[-a|-r]||false>'
      - case 'custom':
        - determine '<s@dRegions_Flag_%flag%.yaml_key[flag_type_customVal].as_list.contains[%YourValue%]||false>'
      - case 'string':
        - determine '<def[YourValue].is[!=].to[null]||false>'
      - default:
        - determine 'false'

#
