################################################################################
#
#                         d  R  e  s  t  a  u  r  a  n  t
#                       For the real Restaurant experience!
#
#
#   Authors: |Anthony| calico-kid
#   Version: 0.1
#   dScript Version: 0.9.6-DEV_b96
#
#
#
#--- About this script
#
#  The dRestarunt system brings realistic NPC animated restaurants to Minecraft.
# Those with permissions can create new restaurants. Restaurants can be bought
# and sold, and Waitresses and Chefs can be employed and fired.
#
#  Restaurants must have properly built equipment for the NPCs to be able to do
# their jobs. NPCs will automagically navigate their environment. A list of
# equipment and building instructions will follow. Adding more equipment to your
# restaurant will unlock additional menu items.
#
#  You can create new menu items by creating a new dRestaurant_item script. Copy
# the provided template and build your "recipe" using the provided animations.
# dRestaurant will keep track of ingredient stock and equipment. If a menu item
# can't be made for whatever reason, it will be removed from the menu for that
# specific restaurant.
#
#  Each restaurant can have it's own menu. Restaurant owners are responsible for
# hiring chefs and waitresses, keeping raw materials stocked, building kitchen
# equipment, and creating their menus. Players can learn new menu items by
# buying a menu item from an existing restaurant and adding it to their menu.
# Server owned restaurants can add any menu item to any restaurant provided it
# has the correct equipment.
#
#
#--- Permissions
#
#  dRestaurant.admin   - Admin perm gives access to all commands and features.
#                      - Can manage all restaurants.
#  dRestaurant.create  - Can create new dRestaurants.
#  dRestaurant.delete  - Can delete dRestaurants you own.
#  dRestaurant.buy     - Can buy dRestaurants that are for sale.
#  dRestaurant.sell    - Can sell dRestaurants that you own.
#  dRestaurant.manage  - Can manage dRestaurants you have purchased.
#  dRestaurant.user    - General user permission to interact with dRestaurant NPCs
#
#
#--- Ticket System
#
#  The Ticket System is a single flag that holds all the ticket information for
# all restaurants. We're using <util.random.duuid> for our %ticketNumber% to
# avoid some silly incremental indexing method.
#
#  The server flag that holds the ticket info: <server.flag[dRestaurantTickets]>
#  It contains a list of lists and is structured like this:
#   - %ticketNumber%/%chef%/%waitress%/<player>/%foodItems%|...
#
#  To get a list of all ticket numbers:
#   - define ticketList <server.flag[dRestaurantTickets].get_sub_items[1].split_by[/]>
#
#  To get a specific ticket object all you need is the %ticketNumber%
#   - define tickets '<server.flag[dRestaurantTickets].as_list>'
#   - define ticket '<def[tickets].get[<def[tickets].get_sub_items[1].split_by[/].find[%ticketNumber%]>]>'
#
#  To get ticket details
#   - define ticketNumber '<def[ticket].split_by[/].get[1]>'
#   - define chef '<def[ticket].split_by[/].get[2].as_npc>'
#   - define waitress '<def[ticket].split_by[/].get[3].as_npc>'
#   - define player '<def[ticket].split_by[/].get[4].as_player>'
#   - define foodItems '<def[ticket].split_by[/].get[5].split_by[\]>'
#
#  To add a new ticket
#   - define ticketNumber '<util.random.duuid>'
#   - define chef ''
#   - define waitress ''
#   - define player ''
#   - define foodItems ''
#   - flag server dRestaurantTickets:->:%ticketNumber%/%chef%/%waitress%/<player>/%foodItems%
#
#  To remove an existing ticket use the %ticket% object as defined above
#   - flag server dRestaurantTickets:<-:%ticket%
#
#
#--- NPC Workflow
#    - For those that want to know and for me so I don't have to remember
#
#  A typical dRestaurant workflow can be outlined as such:
#
#  - Player gets menu from a waitress
#    - <player.flag[dRestaurant_Order]> now holds the name of the restaurant.
#
#  - Player selects items from menu and hits the Order Accept button
#    - <player.flag[dRestaurant_Order]> now has %restaurant%/<def[foodItems].as_list>
#    - flag player dRestaurant_Order_Placed:true
#      - Boolean check for getting and opening a menu.
#    - event "order placed" context:player|<player>
#
#  - Notify the least busy Waitress that a player has placed his order
#    - flag %waitress% dRestaurant_MenuQueue:->:<player>
#    - Check her status and collect menus if she's available
#
#  - Build a new ticket object for each food item the player ordered and notify
#    the kitchen.
#    - inject s@MasterWaitressNPC p:assignWaitress
#    - inject s@MasterWaitressNPC p:assignChef
#    - inject s@MasterWaitressNPC p:assignTicketNumber
#    - flag server dRestaurantTickets:->:%ticketNumber%/%chef%/%waitress%/<player>/%food%
#    - action "order in" %chef% context:ticket|%ticketNumber%
#
#  - Chef hears the order and decides what to do
#    - flag npc OrderQueue:->:%ticketNumber%
#    - If chef is available he'll run processOrderQueue
#    - If chef is busy he'll start cooking when he's not
#
#  - Chef completes cooking
#    - Deliver food to window
#    - flag npc OrderQueue:<-:%ticketNumber%
#    - event "order up" context:ticket|%ticketNumber%|displayItems|<def[displayItems].replace[li@].replace[|].with[/]>
#
#  - Notify the Waitress that an order is ready to be delivered to the player:
#    - flag npc TicketQueue:->:%ticketNumber%/<def[displayItems].as_list.replace[li@].replace[|].with[\]>
#    - If waitress is available she'll run processTicketQueue
#    - If waitress is busy she'll run processTicketQueue
#
#  - Deliver food to player
#    - Waitress walks to window, collects food, brings it to player
#    - flag npc TicketQueue:<-:%TicketQueueEntry%
#    - Remove ticket object from master ticket list
#      - flag server dRestaurantTickets:<-:%ticket%
#
#
################################################################################
#
#  dRestaurant World Script
#
#  This should cover all restaurant related world events. This is also the house
# for all of the equipment locators and the animations.
#
dRestaurant:
  type: world
  debug: false

#______________________________________
#--------------------------------------
#  DRESTAURANT EVENT HANDLERS
#
  events:
#
#--------------------------------------
#
#  dRestaurant NPC events
#
    # Custom event fired by the world script when a player places an order
    on order placed:
      # Define requisite data and do null check
      - define player '<c.player||null>'
      - define orderDetails <def[player].flag[dRestaurant_Order]||null>
      - flag player dRestaurant_Order:!
      - define restaurant <def[orderDetails].split[/].get[1]||null>
      - define foodItems <def[orderDetails].split[/].get[2].as_list||null>
      - inject s@MasterWaitressNPC p:assignWaitress
      # This nullCheck should probably be written as a foreach to properly
      # handle definitions that contain lists
      - define nullCheck li@%player%|%orderDetails%|%restaurant%|%foodItems%|%waitress%
      - if <def[nullCheck].contains[null]> {
        - announce "<&b>dRestaurant<&co> <&c>Something went wrong on <&6>order placed<&c>!" to_console
        - announce "<&b>dRestaurant<&co> <&3>player<&co> <&b>%player%" to_console
        - announce "<&b>dRestaurant<&co> <&3>orderDetails<&co> <&b>%orderDetails%" to_console
        - announce "<&b>dRestaurant<&co> <&3>restaurant<&co> <&b>%restaurant%" to_console
        - announce "<&b>dRestaurant<&co> <&3>foodItems<&co> <&b>%foodItems%" to_console
        - announce "<&b>dRestaurant<&co> <&3>waitress<&co> <&b>%waitress%" to_console
        - queue clear
        }
      # Tell the least busy waitress to collect the menu. She'll decide when to
      # actually get the menu based on status.
      - flag %waitress% dRestaurant_MenuQueue:->:<player>
      # Each of the %foodItems% in an order is a unique %ticketNumber%. This
      # means that all work is evenly distributed amongst the restaurant staff.
      # We do one final null check before creating each ticket.
      - foreach %foodItems% {
        - define food %value%
        - inject s@MasterWaitressNPC p:assignChef
        - inject s@MasterWaitressNPC p:assignTicketNumber
        - if <el@val[%chef%|%ticketNumber%].as_list.contains[null]> {
          - announce "<&b>dRestaurant<&co> <&c>Something went wrong on <&6>order placed<&c>!" to_console
          - announce "<&b>dRestaurant<&co> <&3>player<&co> <&b>%player%" to_console
          - announce "<&b>dRestaurant<&co> <&3>restaurant<&co> <&b>%restaurant%" to_console
          - announce "<&b>dRestaurant<&co> <&3>foodItem<&co> <&b>%food%" to_console
          - announce "<&b>dRestaurant<&co> <&3>chef<&co> <&b>%chef%" to_console
          - announce "<&b>dRestaurant<&co> <&3>ticketNumber<&co> <&b>%ticketNumber%" to_console
          - foreach next
         }
        - flag server dRestaurantTickets:->:%ticketNumber%/%restaurant%/%chef%/<player>/%food%
        - action "order in" %chef% context:ticket|%ticketNumber%
        - wait 10t
        }

    # Custom event fired by the chef when an order is ready for delivery
    on order up:
      # Define requisite data and do null check
      - define ticketNumber '<c.ticket||null>'
      - define displayItems '<c.displayItems.split_by[/]||null>'
      - define tickets '<server.flag[dRestaurantTickets].as_list||null>'
      - define ticket '<def[tickets].get[<def[tickets].get_sub_items[1].split_by[/].find[%ticketNumber%]>]||null>'
      - define restaurant '<def[ticket].split[/].get[2]||null>'
      - inject s@MasterWaitressNPC p:assignWaitress
      # This nullCheck should probably be written as a foreach to properly
      # handle definitions that contain lists
      - define nullCheck li@%ticketNumber%|%tickets%|%ticket%|%waitress%
      - if <def[nullCheck].contains[null]> {
        - announce "<&b>dRestaurant<&co> <&c>Something went wrong on <&6>order up<&c>!" to_console
        - announce "<&b>dRestaurant<&co> <&3>ticketNumber<&co> <&b>%ticketNumber%" to_console
        - announce "<&b>dRestaurant<&co> <&3>tickets<&co> <&b>%tickets%" to_console
        - announce "<&b>dRestaurant<&co> <&3>ticket<&co> <&b>%ticket%" to_console
        - announce "<&b>dRestaurant<&co> <&3>waitress<&co> <&b>%waitress%" to_console
        - queue clear
        }
      - flag %waitress% TicketQueue:->:%ticketNumber%/<def[displayItems].as_list.replace[li@].replace[|].with[\]||null>
      # Let the waitress decide what to do based on status
      - inject npc:%waitress% s@MasterWaitressNPC p:orderup_<def[waitress].flag[Status]||drunk>

    # There has to be a way to cancel an order /after/ it has been entered into
    # the ticket system if the chef detects missing equipment or ingredients,
    # or if a player action cancels the order (logout, exit restaurant, dies)
    on order canceled:
      - announce to_console "<&b>dRestaurant<&co> <&c><c.ticket> cancelled!"

#
#  END dRestaurant NPC events
#--------------------------------------
#
#  dRestaurant Menu events
#
    on player right clicks with i@menu:
      - if <player.has_flag[dRestaurant_Order]||true>
        && <player.flag[dRestaurant_Order_Placed].is[!=].to[true]||true> {
        - define restaurantName '<player.flag[dRestaurant_Order].split[/].get[1]||null>'
        - define menuinventory '<el@val[in@%restaurantName%].as_inventory||null>'
        - if <li@%restaurantName%|%menuinventory%.contains[null]||true> {
          - narrate "%restaurantName%"
          - narrate "%menuinventory%"
          - take 'i@menu[display_name=%restaurantName% Menu]'
          - narrate "I don<&sq>t think you should have this... and even if you were supposed to have it, I have no idea what I<&sq>m doing right now!"
          - flag <player> dRestaurant_Order:!
          - queue clear
          }
        - inventory open d:%menuinventory%
        }

    on player clicks in inventory:
      # Setup some data and do a basic null check
      - define restaurantName '<player.flag[dRestaurant_Order].split[/].get[1]||null>'
      - define order '<player.flag[dRestaurant_Order].split[/].get[2].as_list||li@>'
      - define menuinventory '<el@val[in@%restaurantName%].as_inventory||null>'
      # If the defs are null then it must not be a menu? We should have
      # something to uniquely and instantly identify menu inventories.
      - if <li@%restaurantName%|%menuinventory%.contains[null]||true> {
        - queue stop
        }

      # Some debug output comes out after we're sure we're clicking in a valid
      # inventory
      - if <player.has_flag[dRestaurant_debug]> {
        - narrate "<context.item>"
        - narrate "<context.inventory>"
        - narrate "%menuinventory%"
        - narrate "<context.click>"
        - narrate "<context.slot_type>"
        - narrate "<context.action>"
        }
      # Pull out the admin check for right now. We should add an admin button to
      # the menu if the player is the restaurant owner. The admin button will
      # link to an admin interface where the player can hire/fire employees,
      # add/remove items from the menu, and adjust menu prices.
      - if <server.flag[dRestaurant.%restaurantName%.Owner].as_player.is[==].to[<player>]||false>
        && <c.inventory.is[==].to[%menuinventory%]||false> {
        - if <player.has_flag[dRestaurant_MenuEdit]> queue clear
        }
      # The menu of available items this restaurant sells
      - if <c.inventory.is[==].to[%menuinventory%]||false> {
        - determine passively cancelled
        - if <c.item.is[==].to[i@GUI_Button_Order_Review]||false> {
          - if <def[order].is_empty||true> {
            - narrate "<red>you must place items on your ticket before reviewing them!"
            - inventory update
            - queue clear
            }
            else {
            - note in@restaurantinventory as:<player.name>_restaurant
            - foreach %order% {
              - adjust %value% "lore:click to remove item" save:item
              - give <entry[item].result> to:in@<player.name>_restaurant
              }
            - inventory open d:in@<player.name>_restaurant
            - inventory update
            }
          }
        - if <def[order].size.is[OR_MORE].than[9]> {
          - narrate "<red>your order size is maxed out"
          - inventory update
          }
          else if <c.item.is[!=].to[c.item]> && <c.item.is[!=].to[i@air]> && <c.item.is[!=].to[i@GUI_Button_Order_Review]> && <%menuinventory%.contains[<c.item>]> {
          - if <c.item.display.is[!=].to[null]> {
            - narrate "<green><c.item.display> added to your ticket!"
            }
            else {
            - narrate "<green><c.item.material.name.replace[_].with[ ]> added to your ticket!"
            }
          - flag player dRestaurant_Order:%restaurantName%/<def[order].include[<c.item||>]>
          - inventory update
          }
        }

      # The order review gui
      - if <c.inventory.is[==].to[in@<player.name>_restaurant]> {
        - determine passively cancelled
        - if <c.item.is[==].to[i@GUI_Button_Order_Accept]> {
          - inventory close d:<player.inventory>
          - note remove as:in@<player.name>_restaurant
          - flag player dRestaurant_Order_Placed:true
          - inventory update
          - event "order placed" context:player|<player>
          }
          else if <c.item.is[==].to[i@GUI_Button_Back]> {
          - inventory open d:%menuinventory%
          - inventory update
          - queue clear
          }
          else if <c.item.is[!=].to[c.item]> && <c.item.is[!=].to[i@air]> {
          - if <c.item.display.is[!=].to[null]> {
            - narrate "<red><c.item.display> removed from your ticket!"
            }
            else {
            - narrate "<red><c.item.material.name.replace[_].with[ ]> removed from your ticket!"
            }
          - flag player dRestaurant_Order:%restaurantName%/<def[order].remove[<def[order].find[<c.item.simple>]>]||%order%>
          - take from:in@<player.name>_restaurant <c.item> qty:!
          - inventory update
          }
        }

#
#  END dRestaurant Menu events
#--------------------------------------
#
#  Cuboid Selection
#
    on player right clicks block with dRestaurantTool:
    - determine passively CANCELLED
    - if !<player.has_permission[dRestaurant.create]> {
      - take i@dRestaurantTool
      - narrate "<&4><&l>ERROR<&co><&r> <&a>You should not have this!"
      - queue stop
      }
    - narrate "<&b><&l>dRestaurant<&co><&r> <&a>Set POS1 to <context.location.simple>"
    - flag player dRestaurantToolPOS1:<context.location>

    on player left clicks block with dRestaurantTool:
    - determine passively CANCELLED
    - if !<player.has_permission[dRestaurant.create]> {
      - take i@dRestaurantTool
      - narrate "<&4><&l>ERROR<&co><&r> <&a>You should not have this!"
      - queue stop
      }
    - narrate "<&b><&l>dRestaurant<&co><&r> <&a>Set POS2 to <context.location.simple>"
    - flag player dRestaurantToolPOS2:<context.location>

#
#  END Cuboid Selection
#--------------------------------------
#
#  NPC Spawn Eggs
#
    on player right clicks with i@chefegg:
      - create player chef712 <player.location.cursor_on.add[0.5,1,0.5]>
      - execute as_op "npc select"
      - assignment set script:MasterChefNPC npc:<player.selected_npc>
      - take i@chefegg
      - give i@waitressegg
      - flag player chef:<player.selected_npc>

    on player right clicks with i@waitressegg:
      - create player waitress <player.location.cursor_on.add[0.5,1,0.5]>
      - execute as_op "npc select"
      - assignment set script:waitress npc:<player.selected_npc>
      - take i@waitressegg
      - flag <player.selected_npc> chef:<player.flag[chef]>

#
#  END NPC Spawn Eggs
#--------------------------------------
#
#
#  END DRESTAURANT EVENT HANDLERS
#______________________________________
#--------------------------------------
#
#  Kitchen Equipment Locators
#
#  These are the mechanics we use to find the various kitchen equipment
# End users don't need to concern themselves with this.
#
#  The Equipment Locators return a list of location pairs that the animations
# will use later. You can choose to <def[locations.random]> to get a random
# location from the list, or you can <def[locations].get[1]> to get the closest.
# The first value in the location pair is the location of the equipment that the
# NPC will look at and interact with. The display item (if used) will be
# displayed to this locations surface. The next value in the location pair is
# the location that the NPC will walk to.
#
#  Example:
#    - ^inject locally findYourEquipment instantly
#    - ^define destination '<def[locations].random.split[/]>'
#    - ^define equipmentLoc '<def[destination].get[1].as_location>'
#    - ^define walkLoc '<def[destination].get[2].as_location>'
#
#  TODO
#    - Pantry
#    - Walkin Freezer
#    - Various Bar stuffs
#    - Frying station
#    - Fancy Grill?
#
#  Working on switching to cuboid based searches instead of radius. Need a tag
# or some sane method to quickly filter out all irrelevant blocks. The current
# foreach method that's commented out is just way to heavy to be acceptable.
#
#
  findBasicFridge:
  # The BasicFridge is 2 ironblocks tall with a stone button on the front of the top block
    - define fridgeBlocks <cu@restaurant_%restaurant%.get_blocks[iron_block].filter[below.material.name.is[==].to[iron_block]]||li@>
    - if !<def[fridgeBlocks].is_empty> {
      - define locations li@
      - foreach %fridgeBlocks% {
        - define fridge '%value%'
        - define cardinals li@<def[fridge].add[1,0,0]>|<def[fridge].add[-1,0,0]>|<def[fridge].add[0,0,1]>|<def[fridge].add[0,0,-1]>
        - define walkLocs <def[cardinals].filter[material.name.is[==].to[[stone_button]].filter[below.material.name.is[==].to[air]].filter[sub[0,2,0].material.is_solid]||li@>
        - foreach %walkLocs% {
          - define locations <def[locations].include[%fridge%/<def[value].below>]>
          }
        }
      }
      else announce format:GenericNPCFormat to_console "I found no basic fridges in %restaurant%."

  findFancyFridge:
  # The FancyFridge is 2 ironblocks tall with an iron door on the front
    - define fridgeBlocks <cu@restaurant_%restaurant%.get_blocks[iron_block].filter[below.material.name.is[==].to[iron_block]]||li@>
    - if !<def[fridgeBlocks].is_empty> {
      - define locations li@
      - foreach %fridgeBlocks% {
        - define fridge '%value%'
        - define cardinals li@<def[fridge].add[1,0,0]>|<def[fridge].add[-1,0,0]>|<def[fridge].add[0,0,1]>|<def[fridge].add[0,0,-1]>
        - define walkLocs <def[cardinals].filter[material.name.is[==].to[iron_door_block]].filter[below.material.name.is[==].to[iron_door_block]].filter[sub[0,2,0].material.is_solid]||li@>
        - foreach %walkLocs% {
          - define locations <def[locations].include[%fridge%/<def[value].below>]>
          }
        }
      }
      else announce format:GenericNPCFormat to_console "I found no fancy fridges in %restaurant%."

  findGrill:
  # The Grill is a trapdoor over fire
  # This currently sets the location to walk to as the solid block the player
  #  would stand on. This differs from all of the other equipment search
  #  functions since they all return the air block in front of the equipment.
  #  I want to keep this just to see if there is a noticeable difference. As in
  #  does the NPC get closer to the target block.
    - define grillBlocks <cu@restaurant_%restaurant%.get_blocks[fire,15].filter[above.material.name.is[==].to[trap_door]]||li@>
    - if !<def[grillBlocks].is_empty> {
      - define locations li@
      - foreach %grillBlocks% {
        - define grill '%value%'
        - define cardinals li@<def[grill].add[1,0,0]>|<def[grill].add[-1,0,0]>|<def[grill].add[0,0,1]>|<def[grill].add[0,0,-1]>
        - define walkLocs <def[cardinals].filter[material.is_solid].filter[above.material.name.is[==].to[air]].filter[add[0,2,0].material.name.is[==].to[air]]||li@>
        - foreach %walkLocs% {
          - define locations <def[locations].include[<def[grill].above>/%value%]>
          }
        }
      }
      else announce format:GenericNPCFormat to_console "I found no grills in %restaurant%."

  findSink:
  # The sink is a Cauldron full of water with a tripwire hook above
    - define sinkBlocks <cu@restaurant_%restaurant%.get_blocks[cauldron,3].filter[above.material.name.is[==].to[tripwire_hook]]||li@>
    - if !<def[sinkBlocks].is_empty> {
      - define locations li@
      - foreach %sinkBlocks% {
        - define sink '%value%'
        - define cardinals li@<def[sink].add[1,0,0]>|<def[sink].add[-1,0,0]>|<def[sink].add[0,0,1]>|<def[sink].add[0,0,-1]>
        - define walkLocs <def[cardinals].filter[material.name.is[==].to[air]].filter[above.material.name.is[==].to[air]].filter[below.material.is_solid]||li@>
        - foreach %walkLocs% {
          - define locations <def[locations].include[%sink%/%value%]>
          }
        }
      }
      else announce format:GenericNPCFormat to_console "I found no sinks in %restaurant%."

  findPrep:
  # The Prep station is the top half stone slab with a wood pressure plate on top
    - define prepBlocks <cu@restaurant_%restaurant%.get_blocks[stone_slab_up].filter[above.material.name.is[==].to[wood_plate]]||li@>
    - if !<def[prepBlocks].is_empty> {
      - define locations li@
      - foreach %prepBlocks% {
        - define prep '%value%'
        - define cardinals li@<def[prep].add[1,0,0]>|<def[prep].add[-1,0,0]>|<def[prep].add[0,0,1]>|<def[prep].add[0,0,-1]>
        - define walkLocs <def[cardinals].filter[material.name.is[==].to[air]].filter[above.material.name.is[==].to[air]].filter[below.material.is_solid]||li@>
        - foreach %walkLocs% {
          - define locations <def[locations].include[%prep%/%value%]>
          }
        }
      }
      else announce format:GenericNPCFormat to_console "I found no prep stations in %restaurant%."

  findOven:
  # The oven is a 2 tall by 2 wide set of furnaces.
  # We will accept furnaces that are on or off
  # For some reason i'm getting duplicate results, so for now i'm purging the
  #  dupes with:    - define locations '<def[locations].deduplicate>'
    - define materials 'li@furnace,2|furnace,3|furnace,4|furnace,5|burning_furnace,2|burning_furnace,3|burning_furnace,4|burning_furnace,5'
    - define ovenBlocks <cu@restaurant_%restaurant%.get_blocks[%materials%].filter[below.material.contains[furnace]]||li@>
    - if !<def[ovenBlocks].is_empty> {
      - define locations li@
      - foreach %ovenBlocks% {
        - define oven1 '%value%'
        - define cardinals li@<def[oven1].add[1,0,0]>|<def[oven1].add[-1,0,0]>|<def[oven1].add[0,0,1]>|<def[oven1].add[0,0,-1]>
        - define oven2list <def[cardinals].filter[material.contains[furnace]].filter[below.material.contains[furnace]]||li@>
        - foreach %oven2list% {
          - define oven2 '%value%'
          - define cardinals li@<def[oven2].add[1,0,0]>|<def[oven2].add[-1,0,0]>|<def[oven2].add[0,0,1]>|<def[oven2].add[0,0,-1]>
          - define walkLocs <def[cardinals].filter[material.name.is[==].to[air]].filter[below.material.name.is[==].to[air]].filter[sub[0,2,0].material.is_solid]||li@>
          - foreach %walkLocs% {
            - define locations <def[locations].include[%oven2%/<def[value].sub[0,1,0]>]>
            - define locations <def[locations].include[<def[oven2].sub[0,1,0]>/<def[value].sub[0,1,0]>]>
            }
          }
        }
      }
      else announce format:GenericNPCFormat to_console "I found no ovens in %restaurant%."
    - define locations '<def[locations].deduplicate||li@>'

  findStove:
  # The Stove is a furnace with a stone pressure plate on top
    - define materials 'li@furnace,2|furnace,3|furnace,4|furnace,5|burning_furnace,2|burning_furnace,3|burning_furnace,4|burning_furnace,5'
    - define stoveBlocks <cu@restaurant_%restaurant%.get_blocks[%materials%].filter[above.material.name.is[==].to[stone_plate]]>
    - if !<def[stoveBlocks].is_empty> {
      - define locations li@
      - foreach %stoveBlocks% {
        - define stove '%value%'
        - define cardinals li@<def[stove].add[1,0,0]>|<def[stove].add[-1,0,0]>|<def[stove].add[0,0,1]>|<def[stove].add[0,0,-1]>
        - define walkLocs <def[cardinals].filter[material.name.is[==].to[air]].filter[above.material.name.is[==].to[air]].filter[below.material.is_solid]||li@>
        - foreach %walkLocs% {
          - define locations <def[locations].include[%stove%/%value%]>
          }
        }
      }
      else announce format:GenericNPCFormat to_console "I found no stoves in %restaurant%."

  findTap:
  # The tap is a tripwire hook under a lever
    - define tapBlocks <cu@restaurant_%restaurant%.get_blocks[tripwire_hook].filter[above.material.name.is[==].to[lever]]||li@>
    - if !<def[tapBlocks].is_empty> {
      - define locations li@
      - foreach %tapBlocks% {
        - define tap '%value%'
        - define cardinals li@<def[tap].add[1,0,0]>|<def[tap].add[-1,0,0]>|<def[tap].add[0,0,1]>|<def[tap].add[0,0,-1]>
        - define walkLocs <def[cardinals].filter[material.name.is[==].to[air]].filter[above.material.name.is[==].to[air]].filter[below.material.name.is[==].to[air]].filter[sub[0,2,0].material.is_solid]||li@>
        - foreach %cardinals% {
          - define locations <def[locations].include[%tap%/<def[value].below>]>
          }
        }
      }
      else announce format:GenericNPCFormat to_console "I found no taps in %restaurant%."

  findWindow_chef:
  #  The Window is an upside down stair block with a carpet on top and a
  # redstone_lamp_on above that. It must have an air block in front of it.
  # This is the same window that the Waitress picks up food from. The chef
  # delivers cooked food to the side of the window inside the kitchen. Be sure
  # to have carpet on the floor in front of the window (outside the kitchen) so
  # the chef and waitress are finding the same windows!
  #  The commented materials list is for every upsidedown stair block. It is
  # still too large a material list and causes momentary lag.
#    - define materials 'li@acacia_stairs,4|birch_wood_stairs,4|brick_stairs,4|cobblestone_stairs,4|dark_oak_stairs,4|jungle_wood_stairs,4|nether_brick_stairs,4|quartz_stairs,4|sandstone_stairs,4|smooth_stairs,4|spruce_wood_stairs,4|wood_stairs,4|acacia_stairs,5|birch_wood_stairs,5|brick_stairs,5|cobblestone_stairs,5|dark_oak_stairs,5|jungle_wood_stairs,5|nether_brick_stairs,5|quartz_stairs,5|sandstone_stairs,5|smooth_stairs,5|spruce_wood_stairs,5|wood_stairs,5|acacia_stairs,6|birch_wood_stairs,6|brick_stairs,6|cobblestone_stairs,6|dark_oak_stairs,6|jungle_wood_stairs,6|nether_brick_stairs,6|quartz_stairs,6|sandstone_stairs,6|smooth_stairs,6|spruce_wood_stairs,6|wood_stairs,6|acacia_stairs,7|birch_wood_stairs,7|brick_stairs,7|cobblestone_stairs,7|dark_oak_stairs,7|jungle_wood_stairs,7|nether_brick_stairs,7|quartz_stairs,7|sandstone_stairs,7|smooth_stairs,7|spruce_wood_stairs,7|wood_stairs,7'
    - define materials 'li@quartz_stairs,4|quartz_stairs,5|quartz_stairs,6|quartz_stairs,7'
    - define windowBlocks '<cu@restaurant_%restaurant%.get_blocks[%materials%].filter[above.material.bukkit_enum.is[==].to[CARPET]].filter[add[0,2,0].material.name.is[==].to[redstone_lamp_on]]||li@>'
    - if !<def[windowBlocks].is_empty> {
      - define locations li@
      - foreach %windowBlocks% {
        - define window '%value%'
        - define cardinals li@<def[window].add[1,0,0]>|<def[window].add[-1,0,0]>|<def[window].add[0,0,1]>|<def[window].add[0,0,-1]>
        - define walkLocs <def[cardinals].filter[material.name.is[==].to[air]].filter[above.material.name.is[==].to[air]].filter[below.material.is_solid]||li@>
        - foreach %walkLocs% {
          - define locations <def[locations].include[%window%/%value%]>
          }
        }
      }
      else announce format:GenericNPCFormat to_console "I found no windows in %restaurant%."

  findWindow_waitress:
  # The Window is an upside down stair block with a carpet on top and a
  # redstone_lamp_on above that. It must have an air block in front of it.
  # This is the same window that the Waitress picks up food from. The chef
  # delivers cooked food to the side of the window inside the kitchen. Be sure
  # to have carpet on the floor in front of the window (outside the kitchen) so
  # the chef and waitress are finding the same windows!
  #  The commented materials list is for every upsidedown stair block. It is
  # still too large a material list and causes momentary lag.
#    - define materials 'li@acacia_stairs,4|birch_wood_stairs,4|brick_stairs,4|cobblestone_stairs,4|dark_oak_stairs,4|jungle_wood_stairs,4|nether_brick_stairs,4|quartz_stairs,4|sandstone_stairs,4|smooth_stairs,4|spruce_wood_stairs,4|wood_stairs,4|acacia_stairs,5|birch_wood_stairs,5|brick_stairs,5|cobblestone_stairs,5|dark_oak_stairs,5|jungle_wood_stairs,5|nether_brick_stairs,5|quartz_stairs,5|sandstone_stairs,5|smooth_stairs,5|spruce_wood_stairs,5|wood_stairs,5|acacia_stairs,6|birch_wood_stairs,6|brick_stairs,6|cobblestone_stairs,6|dark_oak_stairs,6|jungle_wood_stairs,6|nether_brick_stairs,6|quartz_stairs,6|sandstone_stairs,6|smooth_stairs,6|spruce_wood_stairs,6|wood_stairs,6|acacia_stairs,7|birch_wood_stairs,7|brick_stairs,7|cobblestone_stairs,7|dark_oak_stairs,7|jungle_wood_stairs,7|nether_brick_stairs,7|quartz_stairs,7|sandstone_stairs,7|smooth_stairs,7|spruce_wood_stairs,7|wood_stairs,7'
    - define materials 'li@quartz_stairs,4|quartz_stairs,5|quartz_stairs,6|quartz_stairs,7'
    - define windowBlocks '<cu@restaurant_%restaurant%.get_blocks[%materials%].filter[above.material.bukkit_enum.is[==].to[CARPET]].filter[add[0,2,0].material.name.is[==].to[redstone_lamp_on]]||li@>'
    - if !<def[windowBlocks].is_empty> {
      - define locations li@
      - foreach %windowBlocks% {
        - define window '%value%'
        - define cardinals li@<def[window].add[1,0,0]>|<def[window].add[-1,0,0]>|<def[window].add[0,0,1]>|<def[window].add[0,0,-1]>
        - define walkLocs <def[cardinals].filter[material.bukkit_enum.is[==].to[CARPET]].filter[above.material.name.is[==].to[air]].filter[below.material.is_solid]||li@>
        - foreach %walkLocs% {
          - define locations <def[locations].include[%window%/%value%]>
          }
        }
      }
      else announce format:GenericNPCFormat to_console "I found no windows in %restaurant%."


#
#  END Kitchen Equipment Locators
#______________________________________
#--------------------------------------
#
#  Animations
#
# These are the animations we provide to the end users. All they have to do is
# inject them from their recipe scripts and have the right definitions available
#
#  TODO
#
#    - Figure out a way to have unattended cooking operations
#    - Add a cookTime option to baking
#    - Animations for any new equipment
#
#
#-----------------------
#  Chef Specific Animations
#
  getFood_FancyFridge:
  # Walk to the FancyFridge and get the %foodItems%
    - ^inject locally findFancyFridge instantly
    - ^define destination '<def[locations].random>'
    - ^define door '<def[destination].split[/].get[2].as_location>'
    - ^lookclose state:true
    - ~walkto %door% speed:<def[speed].add[0.1].as_money||0.8>
    - ^lookclose state:false
    - ^look <npc> '<def[destination].split[/].get[1].as_location>'
    - ^playsound %door% sound:door_open
    - ^animate <npc> animation:ARM_SWING
    - ^switch %door% state:toggle
    - ^wait 15t
    - foreach %foodItems% {
      - animate <npc> animation:ARM_SWING
      - ~equip <npc> hand:<def[value].as_item>
      - wait 15t
      }
    - ^animate <npc> animation:ARM_SWING
    - ^switch %door% state:toggle
    - ^playsound %door% sound:door_close
    - ^wait 10t

  getFood_BasicFridge:
  # Walk to the BancyFridge and get the %foodItems%
    - ^inject locally findBasicFridge instantly
    - ^define destination '<def[locations].random>'
    - ^define door '<def[destination].split[/].get[2].as_location>'
    - ^lookclose state:true
    - ~walkto %door% speed:<def[speed].add[0.1].as_money||0.8>
    - ^lookclose state:false
    - ^look <npc> '<def[destination].split[/].get[1].as_location>'
    - ^playsound %door% sound:door_open
    - ^animate <npc> animation:ARM_SWING
    - ^switch %door% state:toggle
    - ^wait 15t
    - foreach %foodItems% {
      - animate <npc> animation:ARM_SWING
      - ~equip <npc> hand:<def[value].as_item>
      - wait 15t
      }
    - ^animate <npc> animation:ARM_SWING
    - ^switch %door% state:toggle
    - ^playsound %door% sound:door_close
    - ^wait 10t

  washFood:
  # Walk to sink and wash the %foodItems%
    - ^inject locally findSink instantly
    - ^define destination '<def[locations].random>'
    - ^define sinkLoc '<def[destination].split[/].get[1].as_location>'
    - ^lookclose state:true
    - ~walkto '<def[destination].split[/].get[2].as_location>' speed:<def[speed].add[0.1].as_money||0.8>
    - ^lookclose state:false
    - ^look <npc> %sinkLoc%
    - ^wait 5t
    - ~equip <npc> hand:<i@air>
    - ^animate <npc> animation:SNEAK
    - ^animate <npc> animation:ARM_SWING
    - ^playsound %sinkLoc% sound:splash2
    - ^define displayItems li@
    - ^foreach %foodItems% {
      - displayitem <def[value].as_item> '%sinkLoc%' save:displayItem_%loop_index%
      - define displayItems '<def[displayItems].include[<entry[displayItem_%loop_index%].dropped>]>'
      }
    - ^foreach %foodItems% {
      - define food <def[value].as_item>
      - ^repeat 5 {
        - ~equip <npc> hand:%food%
        - animate <npc> animation:ARM_SWING
        - playsound %sinkLoc% sound:swim
        - wait <util.random.int[5].to[15]>t
        }
      }
    - ^playsound %sinkLoc% sound:splash2
    - ^animate <npc> animation:STOP_SNEAKING
    - ^remove %displayItems%
    - ^animate <npc> animation:ARM_SWING
    - ~equip <npc> hand:<def[foodItems].random.as_item>
    - ^wait 10t

  prepFood:
  # Walk to prep area and prep the %foodItems%
    - ^inject locally findPrep instantly
    - ^define destination '<def[locations].random>'
    - ^define prepLoc '<def[destination].split[/].get[1].as_location>'
    - ^lookclose state:true
    - ~walkto '<def[destination].split[/].get[2].as_location>' speed:<def[speed].add[0.1].as_money||0.8>
    - ^lookclose state:false
    - ^look <npc> %prepLoc%
    - ^animate <npc> animation:SNEAK
    - ^animate <npc> animation:ARM_SWING
    - ~equip <npc> hand:<i@air>
    - ^define displayItems li@
    - ^foreach %foodItems% {
      - displayitem <def[value].as_item> '%prepLoc%' save:displayItem_%loop_index%
      - define displayItems '<def[displayItems].include[<entry[displayItem_%loop_index%].dropped>]>'
      }
    - ^repeat 5 {
      - animate <npc> animation:ARM_SWING
      - ^define sound 'li@step_ladder|lava_pop'
      - playsound %prepLoc% sound:<def[sound].random>
      - wait 5t
      }
    - ^remove %displayItems%
    - ^animate <npc> animation:STOP_SNEAKING
    - ~equip <npc> hand:<def[foodItems].random.as_item>
    - ^wait 10t

  bakeFood_Attended:
  # Walk to oven and bake the %foodItem%
  # Items should be baked one at a time in my opinion, but idk.
    - ^inject locally findOven instantly
    - ^define destination '<def[locations].random>'
    - ^lookclose state:true
    - ~walkto '<def[destination].split[/].get[2].as_location>' speed:<def[speed].add[0.1].as_money||0.8>
    - ^lookclose state:false
    - ^define furnace '<def[destination].split[/].get[1].as_location>'
    - ^look <npc> %furnace%
    - ~equip <npc> hand:<i@air>
    - ^animate <npc> animation:ARM_SWING
    - ^wait 5t
    - ^playsound %furnace% sound:ghast_fireball
    - ^showfake m@burning_furnace,<def[furnace].material.data> %furnace% to:<def[furnace].find.players.within[10]> d:200t
    - ^repeat 20 {
      - ^define sound 'li@fuse|fire.random|fire.random|fire.random'
      - ^playsound %furnace% sound:<def[sound].random>
      - ^wait 5t
      }
    - ^animate <npc> animation:ARM_SWING
    - ~equip <npc> hand:%foodItem%
    - ^wait 10t

  bakeFood_Unattended:
  # Walk to oven and start cooking.
    - ^inject locally findOven instantly
    - ^define destination '<def[locations].random>'
    - ^define furnace '<def[destination].split[/].get[1].as_location>'
    - ^define walkLoc '<def[destination].split[/].get[2].as_location>'
    - ^lookclose state:true
    - ~walkto %walkLoc% speed:<def[speed].add[0.1].as_money||0.8>
    - ^lookclose state:false
    - ^look <npc> %furnace%
    - ~equip <npc> hand:<i@air>
    - ^animate <npc> animation:ARM_SWING
    - ^wait 5t
    - ^playsound %furnace% sound:ghast_fireball
    - ^modifyblock %furnace% m@burning_furnace,<def[furnace].material.data> no_physics
    - ^run locally bakeFood_Unattended_Cooking def:%ticketNumber%|%furnace%|%walkLoc%|%cookTime%|%cookedFood%

  bakeFood_Unattended_Cooking:
  # This is the part of the animation that is done without the NPC
    - define ticketNumber %1%
    - define furnace %2%
    - define walkLoc %3%
    - define cookTime %4%
    - define cookedFood %5%
    # Default (fallback) cook time of 30 seconds
    - ^define finishTime <def[cookTime].mul[1000].add_int[<server.current_time_millis>]||<server.current_time_millis.add_int[30000]>>
    # This method provides AT LEAST a 90 second max cook time. The longest
    # possible cook time is 270 seconds. There's a bit of randomness to this
    # though since the wait time between iterations is random. Animation will
    # stop regardless of the actual cook time after 360 iterations.
    - ^repeat 360 {
      - if <def[finishTime].is[LESS].than[<server.current_time_millis>]> repeat stop
      - ^define sound 'li@fuse|fire.random|fire.random'
      - ^playsound %furnace% sound:<def[sound].random>
      - ^wait <util.random.int[5].to[15]>t
      }
    - ^action "cook complete" context:ticket|%ticketNumber%|equipmentLoc|%furnace%|walkLoc|%walkLoc%|displayEntity|null|cookedFood|%cookedFood%

  bakeFood_Unattended_Get:
  # This is triggered from the cook complete action
    - ^lookclose state:true
    - ~walkto %walkLoc% speed:<def[speed].add[0.1].as_money||0.8>
    - ^lookclose state:false
    - ^look <npc> %equipmentLoc%
    - ^animate <npc> animation:ARM_SWING
    - ~equip <npc> hand:%cookedFood%
    - ^modifyblock %equipmentLoc% m@furnace,<def[equipmentLoc].material.data> no_physics
    - ^wait 10t

  grillFood_Attended:
  # Walk to grill and cook %rawFood% into %cookedFood%
    - ^inject locally findGrill instantly
    - ^define destination '<def[locations].random>'
    - ^lookclose state:true
    - ~walkto '<def[destination].split[/].get[2].as_location>' speed:<def[speed].add[0.1].as_money||0.8>
    - ^lookclose state:false
    - ^define grill '<def[destination].split[/].get[1].as_location>'
    - ^look <npc> %grill%
    - ~equip <npc> hand:<i@air>
    - ^animate <npc> animation:ARM_SWING
    - ^wait 5t
    - ^playsound %grill% sound:ghast_fireball
    - ^displayitem <def[rawFood].as_item> '%grill%' d:300s save:rawFood
    # Default (fallback) cook time of 30 seconds
    - ^define finishTime <def[cookTime].mul[1000].add_int[<server.current_time_millis>]||<server.current_time_millis.add_int[30000]>>
    # This method provides AT LEAST a 90 second max cook time. The longest
    # possible cook time is 270 seconds. There's a bit of randomness to this
    # though since the wait time between iterations is random. Animation will
    # stop regardless of the actual cook time after 360 iterations.
    - ^repeat 360 {
      - if <def[finishTime].is[LESS].than[<server.current_time_millis>]> repeat stop
      - ^define sound 'li@fuse|fuse|fire.random'
      - ^playsound %grill% sound:<def[sound].random>
      - ^if <util.random.int[1].to[10].is[OR_MORE].than[7]> animate <npc> animation:ARM_SWING
      - ^if <util.random.int[1].to[10].is[OR_MORE].than[4]> playeffect %grill% effect:smoke qty:1 data:4
      - ^wait <util.random.int[5].to[15]>t
      }
    - ^animate <npc> animation:ARM_SWING
    - ^remove <entry[rawFood].dropped>
    - ^displayitem <def[cookedFood].as_item> '%grill%' d:30s save:cookedFood
    - ^repeat 3 {
      - ^define sound 'li@fuse|fuse|fire.random'
      - ^playsound %grill% sound:<def[sound].random>
      - ^playeffect %grill% effect:smoke qty:1 data:4
      - ^wait 15t
      }
    - ^animate <npc> animation:ARM_SWING
    - ^remove <entry[cookedFood].dropped>
    - ~equip <npc> hand:%cookedFood%
    - ^wait 10t

  boilFood_Attended:
  # Walk to stove and cook %rawFood% into %cookedFood%
    - ^inject locally findStove instantly
    - ^define destination '<def[locations].random>'
    - ^lookclose state:true
    - ~walkto '<def[destination].split[/].get[2].as_location>' speed:<def[speed].add[0.1].as_money||0.8>
    - ^lookclose state:false
    - ^define stove '<def[destination].split[/].get[1].as_location>'
    - ^look <npc> %stove%
    - ~equip <npc> hand:<i@air>
    - ^animate <npc> animation:ARM_SWING
    - ^wait 5t
    - ^playsound %stove% sound:ghast_fireball
    - ^modifyblock %stove% m@burning_furnace,<def[stove].material.data> no_physics
    - ^displayitem <def[rawFood].as_item> '%stove%' d:300s save:rawFood
    # Default (fallback) cook time of 30 seconds
    - ^define finishTime <def[cookTime].mul[1000].add_int[<server.current_time_millis>]||<server.current_time_millis.add_int[30000]>>
    # This method provides AT LEAST a 90 second max cook time. The longest
    # possible cook time is 270 seconds. There's a bit of randomness to this
    # though since the wait time between iterations is random. Animation will
    # stop regardless of the actual cook time after 360 iterations.
    - ^repeat 360 {
      - if <def[finishTime].is[LESS].than[<server.current_time_millis>]> repeat stop
      - ^define sound 'li@fuse|lava|fire.random'
      - ^playsound %stove% sound:<def[sound].random>
      - ^if <util.random.int[1].to[10].is[OR_MORE].than[7]> animate <npc> animation:ARM_SWING
      - ^if <util.random.int[1].to[10].is[OR_MORE].than[4]> playeffect %stove% effect:mob_spell qty:10 data:0.2 offset:0.2
      - ^wait <util.random.int[5].to[15]>t
      }
    - ^animate <npc> animation:ARM_SWING
    - ^remove <entry[rawFood].dropped>
    - ^displayitem <def[cookedFood].as_item> '%stove%' d:30s save:cookedFood
    - ^repeat 3 {
      - ^define sound 'li@fuse|lava|fire.random'
      - ^playsound %stove% sound:<def[sound].random>
      - ^playeffect %stove% effect:smoke qty:1 data:4
      - ^wait 15t
      }
    - ^animate <npc> animation:ARM_SWING
    - ^remove <entry[cookedFood].dropped>
    - ~equip <npc> hand:%cookedFood%
    - ^modifyblock %stove% m@furnace,<def[stove].material.data> no_physics
    - ^wait 10t

  boilFood_Unattended:
  # Walk to stove and start cooking.
    - ^inject locally findStove instantly
    - ^define destination '<def[locations].random>'
    - ^define stove '<def[destination].split[/].get[1].as_location>'
    - ^lookclose state:true
    - ^define walkLoc '<def[destination].split[/].get[2].as_location>'
    - ^lookclose state:false
    - ~walkto %walkLoc% speed:<def[speed].add[0.1].as_money||0.8>
    - ^look <npc> %stove%
    - ~equip <npc> hand:<i@air>
    - ^animate <npc> animation:ARM_SWING
    - ^wait 5t
    - ^playsound %stove% sound:ghast_fireball
    - ^modifyblock %stove% m@burning_furnace,<def[stove].material.data> no_physics
    - ^displayitem <def[rawFood].as_item> '%stove%' d:300s save:rawFood
    - ^run locally boilFood_Unattended_Cooking def:%ticketNumber%|%stove%|%walkLoc%|<entry[rawFood].dropped>|%cookTime%|%cookedFood%


  boilFood_Unattended_Cooking:
  # This is the part of the animation that is done without the NPC
    - define ticketNumber %1%
    - define stove %2%
    - define walkLoc %3%
    - define rawDisplay %4%
    - define cookTime %5%
    - define cookedFood %6%
    # Default (fallback) cook time of 30 seconds
    - ^define finishTime <def[cookTime].mul[1000].add_int[<server.current_time_millis>]||<server.current_time_millis.add_int[30000]>>
    # This method provides AT LEAST a 90 second max cook time. The longest
    # possible cook time is 270 seconds. There's a bit of randomness to this
    # though since the wait time between iterations is random. Animation will
    # stop regardless of the actual cook time after 360 iterations.
    - ^repeat 360 {
      - if <def[finishTime].is[LESS].than[<server.current_time_millis>]> repeat stop
      - ^define sound 'li@fuse|lava|fire.random'
      - ^playsound %stove% sound:<def[sound].random>
      - ^if <util.random.int[1].to[10].is[OR_MORE].than[4]> playeffect %stove% effect:mob_spell qty:10 data:0.2 offset:0.2
      - ^wait <util.random.int[5].to[15]>t
      }
    - ^remove %rawDisplay%
    - ^displayitem <def[cookedFood].as_item> '%stove%' d:30s save:cookedFood
    - ^repeat 3 {
      - ^define sound 'li@fuse|lava|fire.random'
      - ^playsound %stove% sound:<def[sound].random>
      - ^playeffect %stove% effect:smoke qty:1 data:4
      - ^wait 15t
      }
    - ^action "cook complete" context:ticket|%ticketNumber%|equipmentLoc|%stove%|walkLoc|%walkLoc%|displayEntity|<entry[cookedFood].dropped>|cookedFood|%cookedFood%

  boilFood_Unattended_Get:
  # This is triggered from the cook complete action
    - ^lookclose state:true
    - ~walkto %walkLoc% speed:<def[speed].add[0.1].as_money||0.8>
    - ^lookclose state:false
    - ^look <npc> %equipmentLoc%
    - ^animate <npc> animation:ARM_SWING
    - ^remove %displayEntity%
    - ~equip <npc> hand:%cookedFood%
    - ^modifyblock %equipmentLoc% m@furnace,<def[equipmentLoc].material.data> no_physics
    - ^wait 10t

  deliverFood_chef:
  # Walk to the window and deliver the %foodItems%
    - ^inject locally findWindow_chef instantly
    - ^define destination '<def[locations].random>'
    - ^define windowLoc '<def[destination].split[/].get[1].as_location>'
    - ^lookclose state:true
    - ~walkto '<def[destination].split[/].get[2].as_location>' speed:<def[speed].add[0.1].as_money||0.8>
    - ^lookclose state:false
    - ^look <npc> %windowLoc%
    - ~equip <npc> hand:<i@air>
    - ^define displayItems li@
    - ^foreach %foodItems% {
      - displayitem <def[value].as_item> '%windowLoc%' d:30s save:displayItem_%loop_index%
      - define displayItems '<def[displayItems].include[<entry[displayItem_%loop_index%].dropped>]>'
      }
    - ^narrate "Order up!" 'targets:<npc.location.find.players.within[3]>' format:GenericNPCFormat
    - ^event "order up" context:ticket|%ticketNumber%|displayItems|<def[displayItems].replace[li@].replace[|].with[/]>


#-----------------------
#  Waitress Specific Animations
#
  deliverFood_waitress:
  # Walk to window, collect the %foodItems%, and deliver them to the player.
  # Currently using a simple walkto command. This may lead to table dancers.
    # Find the window and walk to it
    - ^inject locally findWindow_waitress instantly
    - ^define destination '<def[locations].random>'
    - ^define windowLoc '<def[destination].split[/].get[1].as_location>'
    - ^lookclose state:true
    - ~walk '<def[destination].split[/].get[2].as_location>' 'speed:<def[speed].add[0.1].as_money||0.8>'
    - ^lookclose state:false
    - ^look <npc> %windowLoc%
    - ^wait 10t
    # Pickup the food. This means we need to store the entity id for the display items
    - ^remove %displayItems%
    - ~equip <npc> hand:<def[foodItems].random.as_item>
    - ^wait 10t
    # Really should have a method to ensure that the player is still online and
    # still in the restaurant before we proceed.
    # Should also be using the follow command along with a proximity move action
    - ^lookclose state:true
    - ^if <def[player].is_online>
      && <def[player].location.is_within[cu@restaurant_%restaurant%]||false> {
      - follow target:%player%
      - inject locally followPlayer_waitress
      - follow stop target:%player%
      - wait 10t
      - animate <npc> animation:arm_swing
      - playsound <def[player].location> sound:silverfish_walk pitch:0.3
      - playsound <def[player].location> sound:step_grass pitch:0.7
      }
    - ^give player:%player% %foodItems%
    - ~equip <npc> hand:i@air
    - ^narrate format:GenericNPCFormat "Here is your <def[foodItems].parse[display].as_list.formatted>" target:%player%
#    - ^define foods li@
#    - ^foreach %fooditems% {
#      - define foods <def[foods].include[<def[value].display>]>
#      }
#    - ^narrate format:GenericNPCFormat "Here is your <def[foods].as_list.formatted>" target:%player%

  followPlayer_waitress:
    - ^wait 1s
    - ^define counter <def[counter].add[1]||0>
    - ^if <npc.is_spawned||false>
      && <def[player].is_online||false>
      && <def[counter].is[OR_LESS].than[9]||false>
      && <def[player].location.distance[<npc.location>].is[MORE].than[3]||false>
      && <def[player].location.is_within[cu@restaurant_%restaurant%]||false>
      && <npc.location.is_within[cu@restaurant_<def[restaurant]||null>]||false>
      && <el@val[<npc.flag[Status].is[==].to[order]||false>].or[<npc.flag[Status].is[==].to[deliver]||false>]||false> {
      - inject locally followPlayer_waitress
      }
      else follow stop target:%player%

  idleQueue_Waitress_Fidget:
    - ^if <util.random.int[1].to[100].is[OR_MORE].than[99]> {
      - random {
        - narrate format:GenericNPCFormat "We<&sq>ve got the best food!" targets:<npc.location.find.players.within[5]||null>
        - narrate format:GenericNPCFormat "Our chefs were trained by the finest programmers!" targets:<npc.location.find.players.within[5]||null>
        - narrate format:GenericNPCFormat "I hope you enjoy your meal." targets:<npc.location.find.players.within[5]||null>
        - narrate format:GenericNPCFormat "You can watch the Chefs do what they do best!" targets:<npc.location.find.players.within[5]||null>
        - narrate format:GenericNPCFormat "Enjoy your stay!" targets:<npc.location.find.players.within[5]||null>
        }
      }
    - ^define fidgetLocation '<def[fidgetValues].get[5]||npc.location>'
    - ^define fidgetHeight '<def[fidgetValues].get[6]||1>'
    - ^define pathMaterial '<def[fidgetValues].get[7].split_by[/]||cobblestone|coal_block|cobblestone_stairs>'
    - ^define target '<cu@restaurant_%restaurant%.get_spawnable_blocks[%pathMaterial%].filter[distance[<npc.location>].is[OR_LESS].than[%range%]].filter[distance[%fidgetLocation%].vertical.is[OR_LESS].than[%fidgetHeight%]].random||<npc.location>>'
    - ~walk %target% speed:%speed%
#    - ^repeat 5 {
#      - define target '<cu@restaurant_%restaurant%.get_spawnable_blocks[%pathMaterial%].random||null>'
#      - if <def[target].distance[%fidgetLocation%].vertical.is[OR_LESS].than[%fidgetHeight%]>
#        && <def[target].distance[<npc.location>].is[OR_LESS].than[%fidgetRadius%]> {
#        - ~walk %target% speed:%speed%
#        - repeat stop
#        }
#      }


#
#  END Animations
#-----------------------
#
#  Chef Idle Mechanics
#
  idleQueue_Chef:
    - ^if !<npc.is_spawned||false> queue clear
    - ^flag npc Status:idle
    - ^lookclose state:true
    - ^if <queue.exists[processOrder_<npc.id>]> queue queue:processOrder_<npc.id> stop
    - ^define fidgetValues '<npc.flag[dRestaurant_FidgetValues].as_list||null>'
    - ^define list li@55/Fidget|15/DishWashing|15/PrepCleaning|15/GrillCleaning
    - ^inject s@WeightedRandomChoice p:asDef instantly
    - ^define restaurant '<def[fidgetValues].get[1]||null>'
    - ^define range '<def[fidgetValues].get[3]||30>'
    - ^define speed '<def[fidgetValues].get[4]||0.7>'
    - ^inject locally idleQueue_Chef_%result%
    - ^define wait '<def[fidgetValues].get[2]||10>'
    - ^wait <util.random.int[<def[wait].mul[0.5].as_int>].to[<def[wait].mul[1.5].as_int>]>s
    - ^if <queue.exists[processOrder_<npc.id>]> queue queue:processOrder_<npc.id> stop
    - ^run s@MasterChefNPC p:processOrderQueue id:processOrder_<npc.id> delay:2t
    - ^queue clear

  idleQueue_Chef_Fidget:
#    - ^narrate format:GenericNPCFormat "Just walking around..." 'targets:<npc.location.find.players.within[5]>'
    - ^define fidgetLocation '<def[fidgetValues].get[5]||npc.location>'
    - ^define fidgetHeight '<def[fidgetValues].get[6]||1>'
    - ^define pathMaterial '<def[fidgetValues].get[7].split_by[/]||cobblestone|coal_block|cobblestone_stairs>'
    - ^repeat 5 {
      - define target '<cu@restaurant_%restaurant%.get_spawnable_blocks[%pathMaterial%].random||null>'
#      - define target '<def[fidgetLocation].as_location.find.surface_blocks[<def[pathMaterial]>].within[<def[range]>].random>'
      - if <def[target].distance[%fidgetLocation%].vertical.is[OR_LESS].than[%fidgetHeight%]> {
        - ~walk %target% speed:%speed%
        - repeat stop
        }
      }

  idleQueue_Chef_DishWashing:
  # washing dishes in prep for customers
    - ^narrate format:GenericNPCFormat "Time to wash some dishes." 'targets:<npc.location.find.players.within[5]>'
    - ^define fooditems li@bowl|wood_plate
    - ~inject locally washfood
    - ~inject locally prepFood
    - ^lookclose state:true
    - ~equip npc hand:i@air

  idleQueue_Chef_PrepCleaning:
    - ^narrate format:GenericNPCFormat "I<&sq>m going to clean the prep station." 'targets:<npc.location.find.players.within[5]>'
    - ^inject locally findprep
    - ^define destination '<def[locations].random>'
    - ^define prepstand '<def[destination].split[/].get[2].as_location>' speed:<def[speed].add[0.1].as_money||0.8>
    - ^define prep '<def[destination].split[/].get[1].as_location>'
    - ^lookclose state:true
    - ~walkto %prepstand%
    - ^lookclose state:false
    - ^look <npc> %prep%
    - ~equip npc hand:i@potion,16388
    - wait 1s
    - ^playeffect %prep% effect:snow_shovel qty:2
    - playsound <npc.location> sound:fuse pitch:2
    - ^playeffect %prep% effect:snow_shovel qty:2
    - playsound <npc.location> sound:fuse pitch:2
    - ~equip npc hand:i@red_carpet
    - ^animate <npc> animation:arm_swing
    - playsound <npc.location> sound:step_wood pitch:-1
    - ^animate <npc> animation:arm_swing
    - playsound <npc.location> sound:step_wood pitch:-1
    - wait 1s
    - ^playeffect %prep% effect:fireworks_spark qty:5
    - ^playsound <npc.location> sound:level_up pitch:-1
    - ^lookclose state:true
    - ~equip npc hand:i@air

  idleQueue_Chef_GrillCleaning:
    - narrate format:GenericNPCFormat "That grill needs a good cleaning!" 'targets:<npc.location.find.players.within[5]>'
    - ^inject findgrill locally
    - ^define destination '<def[locations].random>'
    - ^define grillpad'<def[destination].split[/].get[2].as_location>'
    - ^define grill '<def[destination].split[/].get[1].as_location>'
    - ^lookclose state:true
    - ~walkto %grillpad% speed:<def[speed].add[0.1].as_money||0.8>
    - ^lookclose state:false
    - ^look <npc> %grill%
    - ~equip npc hand:i@potion,16388
    - wait 1s
    - ^playeffect %grill% effect:snow_shovel qty:2
    - playsound <npc.location> sound:fuse pitch:2
    - ^playeffect %grill% effect:snow_shovel qty:2
    - playsound <npc.location> sound:fuse pitch:2
    - ~equip npc hand:i@red_carpet
    - ^animate <npc> animation:arm_swing
    - playsound <npc.location> sound:fizz pitch:2
    - ^animate <npc> animation:arm_swing
    - playsound <npc.location> sound:fizz pitch:2
    - wait 1s
    - ^playeffect %grill% effect:fireworks_spark qty:5
    - ^playsound <npc.location> sound:level_up pitch:-1
    - ^lookclose state:true
    - ~equip npc hand:i@air

#
#  END Chef Idle Mechanics
#-----------------------
#
#
#
#  END DRESTAURANT WORLD SCRIPT
#______________________________________
#--------------------------------------
