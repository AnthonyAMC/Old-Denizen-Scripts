################################################################################
#
#  Master Waitress Assignment Script
#
# The Waitress will greet players, deliver menus, take orders, and deliver food.
#
MasterWaitressNPC:
  type: assignment
  speed: 1t
  debug: true

  actions:
    on assignment:
      - run locally assignment instantly
    on spawn:
      - run locally spawn instantly delay:2s
    on despawn:
      - run locally despawn instantly delay:1s
    on click:
      - run locally click_<npc.flag[status]||drunk> instantly


  assignment:
  # What happens on assignment. We want this as a subscript so we can run it
  # outside the on assignment action if needed.
    - trigger name:chat state:true radius:5 cooldown:5s
    - trigger name:click state:true radius:5 cooldown:5s
    - trigger name:proximity state:false
    - trigger name:damage state:true radius:5 cooldown:5s
    - vulnerable state:false
    - lookclose true range:5 realistic
    - flag npc respawn_location:<npc.location>
    - flag npc Pathfind.FidgetRadius:15
    - flag npc Pathfind.FidgetSpeed:0.7
    - flag npc Pathfind.FidgetWait:5
    - flag npc Pathfind.FidgetLocation:<npc.location>
    - flag npc Pathfind.FidgetHeight:1
    - flag npc Pathfind.FidgetPathMaterial:->:<npc.location.standing_on.material.name>
    - inject locally spawn instantly

  spawn:
    - chat "Alright, time to start work..." no_target
    - if <queue.exists[fidgetQueue_<npc.id>]> queue queue:fidgetQueue_<npc.id> stop
    - inject locally processTicketQueue
    - run s@Fidget id:fidgetQueue_<npc.id>

  despawn:
  # Just a code stub
    - chat "Phew... I<&sq>m glad to be done work for the day!" no_target

  damage:
  # Just a code stub
    - chat "Why would you do that?" no_target

#
#--------------------------------------
#
#  Logic Utilities
#
#
  collectMenus:
  # Run through a list of players that are waiting to have their menus collected
  # Then go and get them. We aren't going to walk to players that are offline or
  # 30 blocks or more away from the npc. This REALLY should check if the player
  # is in the restaurant cuboid and possibly if the player still has the menu in
  # inventory.
  # Should add nullChecks for this
    - if <queue.exists[fidgetQueue_<npc.id>]> queue queue:fidgetQueue_<npc.id> stop
    - define players '<npc.flag[dRestaurant_MenuQueue].as_list||null>'
    - if !<def[players].is_empty||true> {
      - foreach %players% {
        - define player '<def[value].as_player>'
        - if <def[player].is_online||false> && <npc.location.distance[<def[player].location>].is[LESS].than[30]||false> {
          - define loc '<def[player].location.find.surface_blocks[<npc.flag[Pathfind.FidgetPathMaterial].as_list>].within[5].random||<npc.location>>'
          - ~walk %loc% 'speed:<npc.flag[Pathfind.FidgetSpeed].add[0.1].as_money>'
          - look <def[player].eye_location> d:2s
          - wait 10t
          - chat "Your order should be out in just a moment." targets:%player%
          }
        - take i@menu player:%player%
        - flag %player% dRestaurant_Order_Placed:!
        - flag <npc> dRestaurant_MenuQueue:<-:%player%
        - wait 10t
        }
      - if !<npc.flag[dRestaurant_MenuQueue].as_list.is_empty||true> {
        - inject collectMenus locally
        }
      }
    - flag <npc> dRestaurant_MenuQueue:!
    # %1% is only set by the order placed event.
    - if <def[1].exists||false> {
      - define 1:!
      - if <queue.exists[fidgetQueue_<npc.id>]> queue queue:fidgetQueue_<npc.id> stop
      - inject processTicketQueue locally
      - queue clear
      }
    # Now the waitress can go back to what she was doing

  processTicketQueue:
  # Run through a list of orders waiting to be delivered. Rinse and repeat until
  # the queue is cleared.
  # Should add nullChecks for this
    - define ticketQueue '<npc.flag[TicketQueue].as_list||null>'
    - if !<def[ticketQueue].is_empty||true> {
      - flag npc Status:deliver
      - foreach <def[ticketQueue]> {
        - define TicketQueueEntry %value%
        - if <npc.has_flag[dRestaurant_MenuQueue]> {
          - inject locally collectMenus
          }
        - define ticketNumber '<def[TicketQueueEntry].split_by[/].get[1]>'
        - define displayItems '<def[TicketQueueEntry].split_by[/].get[2].split_by[\].as_list>'
        - define tickets '<server.flag[dRestaurantTickets].as_list>'
        - define ticket '<def[tickets].get[<def[tickets].get_sub_items[1].split_by[/].find[%ticketNumber%]>]>'
        - define player '<def[ticket].split_by[/].get[4].as_player>'
        - define foodItems '<def[ticket].split_by[/].get[5]>'
        - inject s@dRestaurant p:deliverFood_waitress
        - flag npc TicketQueue:<-:%TicketQueueEntry%
        - flag server dRestaurantTickets:<-:%ticket%
        }
      - inject processTicketQueue locally
      }
    # Finish up by collecting any menus in queue
    - if <npc.has_flag[dRestaurant_MenuQueue]> {
      - inject locally collectMenus
      }
    - flag npc Status:available
    - if <queue.exists[fidgetQueue_<npc.id>]> queue queue:fidgetQueue_<npc.id> stop
    - run s@Fidget id:fidgetQueue_<npc.id>
    - queue clear

  findRestaurant:
  # This requires an NPC object and should only be run when the player is
  # getting a menu from a waitress in the on click action
    - define restaurants li@
    - foreach <npc.location.cuboids> {
      - if <def[value].notable_name.split[_].get[1].is[==].to[Restaurant]> {
        - define restaurant '<def[value].notable_name.split[_].get[2]>'
        - define owner '<server.flag[dRestaurant.%restaurant%.Owner].as_player>'
        - if <def[owner].is[==].to[<npc.owner>]> {
          - define restaurants '<def[restaurants].include[%restaurant%]>'
          }
        }
      }
    # Because why else would any sane admin have restaurant cuboids overlap?
    - define restaurant '<def[restaurants].random||null>'
    - if <def[restaurant].is[==].to[null]> {
      - chat "Oh dear, I seem to be quite lost..." no_target
      - flag npc status:drunk
      - queue stop
      }

  assignWaitress:
  # This assumes we know the restaurant
    - define waitresses li@
    - define owner '<server.flag[dRestaurant.%restaurant%.Owner].as_player>'
    - foreach <el@val[cu@Restaurant_%restaurant%].as_cuboid.list_npcs> {
      - define npc %value%
      - if <def[owner].is[==].to[<def[npc].owner>]>
        && <def[npc].script.name.is[==].to[MasterWaitressNPC]> {
        - define waitresses '<def[waitresses].include[%npc%]>'
        }
      }
    # Now we have a list of waitresses, let's find the least busy
    - define waitress <def[waitresses].get[1]>
    - foreach <def[waitresses].get[2].to[<def[waitresses].size>]> {
      - if <def[value].flag[TicketQueue].size.is[LESS].than[<def[waitress].flag[TicketQueue].size>]> {
        - define waitress %value%
        }
      }
    - define waitress <def[waitress]||null>

  assignChef:
  # This assumes we know the restaurant
    - define chefs li@
    - define owner '<server.flag[dRestaurant.%restaurant%.Owner].as_player>'
    - foreach <el@val[cu@Restaurant_%restaurant%].as_cuboid.list_npcs> {
      - define npc %value%
      - if <def[owner].is[==].to[<def[npc].owner>]>
        && <def[npc].script.name.is[==].to[MasterChefNPC]> {
        - define chefs '<def[chefs].include[%npc%]>'
        }
      }
    # Now we have a list of chefs, let's find the least busy
    - define chef <def[chefs].get[1]>
    - foreach <def[chefs].get[2].to[<def[chefs].size>]> {
      - if <def[value].flag[TicketQueue].size.is[LESS].than[<def[chef].flag[TicketQueue].size>]> {
        - define chef %value%
        }
      }
    - define chef <def[chef]||null>

  assignTicketNumber:
    - repeat 20 {
      - define ticketNumber <util.random.duuid>
      - define ticketList <server.flag[dRestaurantTickets].get_sub_items[1].split_by[/]>
      - if !<def[ticketList].contains[%ticketNumber%]> repeat stop
      - if <def[value].is[OR_MORE].than[20]> {
        - define ticketNumber "LastLostTicketDetails"
        - announce "<&b>dRestaurant<&co> <&c>Order Lost - Couldn<&sq>t get a valid ticket number!" to_console
        - announce "<&b>dRestaurant<&co> <&c>%ticketNumber%" to_console
        - announce "<&b>dRestaurant<&co> <&c>Chef<&co> %chef%" to_console
        - announce "<&b>dRestaurant<&co> <&c>Waitress<&co> %waitress%" to_console
        - announce "<&b>dRestaurant<&co> <&c>Player<&co> <player>" to_console
        - announce "<&b>dRestaurant<&co> <&c>foodItems<&co> %foodItems%" to_console
        }
      }

#
#  END Logic Utilities
#
#--------------------------------------
#
#  MasterWaitress Status Actions
#
# We're using an NPC status system for action responses. This is a low latency
# and low load method that allows for very fast NPC reactions since they do not
# have to do ANY comparisons. They just run the correct subscript based on the
# action and their current status.
#
#
#--------------------------------------
#  Click Responses
#
  click_drunk:
  # A catchall if something derps
    - flag npc status:drunk
    - if <queue.exists[fidgetQueue_<npc.id>]> queue queue:fidgetQueue_<npc.id> stop
    - chat "I<&sq>m not feeling well... I have to go." no_target
    - wait 2s
    - despawn <npc>

  click_available:
  # When the Waitress is available for whatever
    - flag npc status:order
    - if <player.has_flag[dRestaurant_Order_Placed]> {
      - chat "Someone will collect your menu soon."
      - flag npc status:available
      - queue stop
      }
    - if <player.has_flag[dRestaurant_Order]> {
      - chat "Open up your menu and complete your order."
      - flag npc status:available
      - queue stop
      }
    - if <queue.exists[fidgetQueue_<npc.id>]> queue queue:fidgetQueue_<npc.id> stop
    - inject locally findRestaurant instantly
    - flag <player> dRestaurant_Order:%restaurant%
    - define loc <player.location.find.surface_blocks[<npc.flag[Pathfind.FidgetPathMaterial].as_list>].within[2].get[1]||<npc.location>>
    - ~walk %loc% 'speed:<npc.flag[Pathfind.FidgetSpeed].add[0.1].as_money>'
    - look <player.eye_location> d:2s
    - wait 5t
    - chat "Here you go. Take a look through our menu and choose what you would like."
    - give i@menu
    - wait 15t
    - chat "Someone will come grab the menu when you are ready."
    - wait 30t
    # Now the waitress can go back fidgeting around
    - run s@Fidget id:fidgetQueue_<npc.id>
    - flag npc status:available

  click_order:
  # When the Waitress is taking an order
    - wait 15t
    - chat "I<&sq>ll be right with you <player.name>."

  click_deliver:
  # When the Waitress is delivering food
    - wait 15t
    - chat "We<&sq>re a little busy right now <player.name>."
    - wait 15t
    - chat "Please have a seat and a Waitress will be right with you."

#
#--------------------------------------
#  Order Up Responses
#
  orderup_drunk:
  # A catchall if something derps
    - flag npc status:drunk
    - flag npc TicketQueue:->:%ticketNumber%/<def[displayItems].as_list.replace[li@].replace[|].with[\]>
    - if <queue.exists[fidgetQueue_<npc.id>]> queue queue:fidgetQueue_<npc.id> stop
    - chat "I<&sq>m not feeling well... I have to go." no_target
    - wait 2s
    - despawn <npc>

  orderup_available:
  # When the Waitress is available for whatever
    - flag npc status:deliver
    - chat "Ticket %ticketNumber% heard!" no_target range:10
    - flag npc TicketQueue:->:%ticketNumber%/<def[displayItems].as_list.replace[li@].replace[|].with[\]>
    - if <queue.exists[fidgetQueue_<npc.id>]> queue queue:fidgetQueue_<npc.id> stop
    - inject locally processTicketQueue

  orderup_order:
  # When the Waitress is taking an order
    - chat "Heard ticket %ticketNumber%! I<&sq>m taking an order right now." no_target range:10
    - flag npc TicketQueue:->:%ticketNumber%/<def[displayItems].as_list.replace[li@].replace[|].with[\]>

  orderup_deliver:
  # When the Waitress is delivering food
    - chat "Heard ticket %ticketNumber%! I<&sq>m running food right now." no_target range:10
    - flag npc TicketQueue:->:%ticketNumber%/<def[displayItems].as_list.replace[li@].replace[|].with[\]>

#
#  END MasterWaitress Status Actions
#--------------------------------------
#
#
#  END MASTERWAITRESS ASSIGNMENT SCRIPT CONTAINER
#
