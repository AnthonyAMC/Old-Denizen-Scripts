################################################################################
#
#                            d W o r l d E d i t o r
#
#
#   Authors: |Anthony|, mcmonkey
#   Version: 0.21
#   dScript Version: 0.9.6-1543
#
#
#
#--- About this script
#
#  This is a basic recreation of WorldEdit in denizen
#
#--- Permission nodes
#  dwe.basic: use the /dwe command
#  dwe.admin:  Admin commands
#  dwe.chunk:  Set the chunk you are standing in as your selection
#  dwe.contract:  Contract your region selection
#  dwe.expand:  Expand your region selection
#  dwe.inset:  Inset your region selection
#  dwe.outset:  Outset your region selection
#  dwe.pos:  Use commands to set selection positions
#  dwe.set:  Set the blocks in a selection
#  dwe.shift:  Shift your selection
#  dwe.show:  Show your current region selection
#  dwe.wand:  Get the region selection wand
#  dwe.undo:  Undo previous edits
#
#
# TODO:
#  - Selection
#    - Inset
#    - Outset
#    - Shift
#  - Editing & Clipboard
#    - Copy
#    - Paste
#    - Stack
#    - Rotate
#  - Permissions
#    - Permissions for each individual command
#    - Parent permissions for categories (selection,tool,navigation)
#  - Config File
#    - Maxblocks to change per operation
#    - Undo history size
#    - async-blockedit
#
#
################################################################################
#
#  dWE World Events Script
#
#  This should cover all dWE related world events.
#
dWE_Events:
  type: world
  debug: false
  events:
    on player clicks block:
      - if <c.item.scriptname.split[_].get[1].is[!=].to[dWE]||true> queue clear
      - determine passively CANCELLED
      - inject <c.item.scriptname.as_script> instantly

dWE_Msg:
  type: item
  debug: false
  material: i@human_skull
  display name: "<&4>     [<&6>dWE<&4>]"
  lore:
  - <&5>Click for Help
  script:
    - ^define text '<&4>[<&6>dWE<&4>]'
    - ^define hover '{<i@dWE_Msg.json>}'
    - ^define click '/dwe help'
    - ^define button "text:'%text%',clickEvent:{action:run_command,value:'%click%'},hoverEvent:{action:show_item,value:'%hover%'}"
    - ^define spacer "text:'  '"
    - ^define msg "text:'%1%'"
    - ^execute as_server "tellraw <player.name> {text:'',extra:[{%button%},{%spacer%},{%msg%}]}"

  set_Pos:
    - inject s@dWE_Commands p:selection_Size instantly
    - run s@dWE_Msg 'def:<&f>POS%pos%<&co>  <&3><&o><def[pos%pos%].replace[,].with[<&7>, <&3><&o>]>  <&7>(<&o>%size%<&7>)'

  set_pos1:
    - run s@dWE_Msg 'def:<&f>Selection started at <&3><&o><def[cuboid].min.simple.replace[,].with[<&7>,<&3><&o>]>'

  set_pos2:
    - inject s@dWE_Commands p:selection_Size instantly
    - run s@dWE_Msg 'def:<&f>Selection expanded to include<&co> <&3><&o><context.location.simple.replace[,].with[<&7>,<&3><&o>]> <&7>(<&o>%size%<&7>)'

  shift:
    - inject s@dWE_Commands p:selection_Size instantly
    - run s@dWE_Msg 'def:<&f>Shifted<&f>  <&7><&o>%direction% <&7>by <&o>%n% <&7>blocks (<&o>%size%<&7>)'

  expand:
    - inject s@dWE_Commands p:selection_Size instantly
    - define expandBy '<def[size].sub[%oldSize%].as_int>'
    - run s@dWE_Msg 'def:<&f>Expanded<&f>  <&7><&o>%direction% <&7>by <&o>%expandBy% <&7>blocks (<&o>%size%<&7>)'

  contract:
    - inject s@dWE_Commands p:selection_Size instantly
    - define contractBy '<def[oldSize].sub[%size%].as_int>'
    - run s@dWE_Msg 'def:<&f>Contracted<&f>  <&7><&o>%direction% <&7>by <&o>%contractBy% <&7>blocks (<&o>%size%<&7>)'

  inset:
    - inject s@dWE_Commands p:selection_Size instantly
    - define insetBy '<def[oldSize].sub[%size%].as_int>'
    - run s@dWE_Msg 'def:<&f>Inset<&f>  <&7>by <&o>%insetBy% <&7>blocks (<&o>%size%<&7>)'

  outset:
    - inject s@dWE_Commands p:selection_Size instantly
    - define outsetBy '<def[size].sub[%oldSize%].as_int>'
    - run s@dWE_Msg 'def:<&f>Outset<&f>  <&7>by <&o>%outsetBy% <&7>blocks (<&o>%size%<&7>)'

dWE_Wand:
  type: item
  debug: false
  material: m@wood_axe
  display name: dWE Region Selector
  lore:
  - <&7><&o>Left<&7> click to start a selection
  - <&7><&o>Right<&7> click to expand the selection

  script:
    - if !<player.has_permission[dwe.wand]||<player.is_op>> {
      - take i@dWE_Wand
      - run s@dWE_Msg 'def:<&4><&l>ERROR<&co> <&a>You should not have this!' instantly
      - queue clear
      }
    - if <c.click_type.is[==].to[LEFT_CLICK_BLOCK]> define pos 1
      else if <c.click_type.is[==].to[RIGHT_CLICK_BLOCK]> define pos 2
      else queue clear
    - define pos1 '<player.flag[dWEWand].as_list.get[1]||null>'
    - define pos2 '<player.flag[dWEWand].as_list.get[2]||null>'
    - define type '<player.flag[dWEWand_Type]||cuboid>'
    - if <li@cuboid|extender.contains[%type%]||false> inject locally %type%
      else inject locally cuboid

  cuboid:
    - if <context.location.simple.is[==].to[<def[pos%pos%]>]||false> {
      - run s@dWE_Msg 'def:<&c>pos%pos% is already set'
      - queue clear
      }
    - define pos%pos% '<context.location.simple>'
    - flag player dWEWand:!
    - flag player dWEWand:|:%pos1%|%pos2%
    - inject s@dWE_Msg p:set_Pos

  extender:
    - define cuboid cu@%pos1%|%pos2%
    - if %pos% == 1 {
      - define cuboid cu@<context.location.simple>|<context.location.simple>
      }
      else {
      - if %pos1% == null {
        - run s@DWE_Msg 'Def:<&c>You must begin a selection before you can expand it.'
        - queue clear
        }
      - define cuboid_old %cuboid%
      - define cuboid <def[cuboid].include[<context.location.simple>]>
      - if <def[cuboid_old]> == <def[cuboid]> {
        - run s@dWE_Msg 'def:<&c>That position is already included.'
        - queue clear
        }
      }
    - define pos1 '<def[cuboid].min>'
    - define pos2 '<def[cuboid].max>'
    - flag player dWEWand:!
    - flag player dWEWand:|:%pos1%|%pos2%
    - inject s@dWE_Msg p:set_pos%pos%


################################################################################
#
#  Denizen World Editor Command Script Container
#
# This script covers all dWE commands
#
#
#
#--------------------------------------
#
#  dWE Command Script Basics
#
# The basic stuff required in a command script container
#
dWE_Commands:
  type: command
  debug: false
  name: dwe
  description: Denizen World Editor
  usage: /dwe
  aliases: ''
  allowed help:
  - determine <player.has_permission[dwe.basic]||<player.is_op>>
  script:
    - if !<player.has_permission[dwe.basic]||<player.is_op>> {
      - narrate "<red>You do not have permission to use this command."
      - queue clear
      }
    - define arg1 '<c.args.get[1].escaped||help>'
    - define args 'li@help|wand|expand|contract|inset|outset|shift|pos1|pos2|hpos1|hpos2|sphere|chunk|show|set|undo'
    - if !<def[args].contains[%arg1%]> inject locally help instantly
      else inject locally %arg1% instantly

#
#  END dWE Command Script Basics
#--------------------------------------
#
#  dWE Command Arguments
#
# Each of these subscripts is an argument for the root command.
#
  help:
    - if <player.has_permission[dwe.admin]||<player.is_op||<context.server>>> inject locally msgsHelpAdmin instantly
      else inject locally msgsHelpUser instantly
    - inject locally msgsFooter instantly
    - queue clear

  wand:
  # /dwe wand (-type [cuboid/extender])
    - if !<player.has_permission[dwe.wand]||<player.is_op||false>> {
      - inject locally help
      - queue clear
      }
    - if <c.args.find[-type].is[OR_MORE].than[0]||false> {
      - define type <c.args.get[<c.args.find[-type].add[1].as_int>]||null>
      - if <li@cuboid|extender.contains[%type%]||false> {
        - run s@dWE_Msg 'def:<&7><&o>Now using the <&f><&o>%type% <&7><&o>selection wand'
        - flag player 'dWEWand_Type:%type%'
        }
        else {
        - run s@dWE_Msg 'def:<&4><&l>ERROR<&co> <&c>Unknown type!'
        - run s@dWE_Msg 'def:<&c>SYNTAX<&co> <&e>/dwe -type <&6><&lb><&7>cuboid/extender<&6><&rb>'
        }
      - queue clear
      }
    - give i@dWE_Wand
    - define type '<player.flag[dWEWand_Type]||cuboid>'
    - if <def[type].is[==].to[cuboid]> {
      - run s@dWE_Msg 'def:<&a>Left click to select pos1'
      - run s@dWE_Msg 'def:<&a>Right click to select pos2'
      }
      else {
      - run s@dWE_Msg 'def:<&a>Left click to start a selection,'
      - run s@dWE_Msg 'def:<&a>Right click to expand the selection.'
      }
    - queue clear

#
#-----------------------------
#  Selection Commands
#
  show:
    - if !<player.has_permission[dwe.show]||<player.is_op||false>> {
      - inject locally help
      - queue clear
      }
    - define pos1 '<player.flag[dWEWand].get[1].as_location||null>'
    - define pos2 '<player.flag[dWEWand].get[2].as_location||null>'
    - if <def[pos1].is[==].to[null]> run s@dWE_Msg 'def:<&c>Must select corner 1 with left-click.'
      else if <def[pos2].is[==].to[null]> run s@dWE_Msg 'def:<red>Must select corner 2 with right-click.'
      else showfake m@blue_stained_glass <cu@%pos1%|%pos2%.get_outline> to:<player> d:10s

  pos1:
    - if !<player.has_permission[dwe.pos]||<player.is_op||false>> {
      - inject locally help
      - queue clear
      }
    - define pos1 '<player.flag[dWEWand].as_list.get[1]||null>'
    - if <player.location.simple.is[==].to[%pos1%]> {
      - run s@dWE_Msg 'def:<&c>pos1 is already set'
      - queue clear
      }
    - define pos1 '<player.location.simple>'
    - define pos2 '<player.flag[dWEWand].as_list.get[2]||null>'
    - flag player dWEWand:!
    - flag player dWEWand:|:%pos1%|%pos2%
    - define pos 1
    - inject s@dWE_Msg p:set_Pos

  pos2:
    - if !<player.has_permission[dwe.pos]||<player.is_op||false>> {
      - inject locally help
      - queue clear
      }
    - define pos2 '<player.flag[dWEWand].as_list.get[2]||null>'
    - if <player.location.simple.is[==].to[%pos2%]> {
      - run s@dWE_Msg 'def:<&c>pos2 is already set'
      - queue clear
      }
    - define pos1 '<player.flag[dWEWand].as_list.get[1]||null>'
    - define pos2 '<player.location.simple>'
    - flag player dWEWand:!
    - flag player dWEWand:|:%pos1%|%pos2%
    - define pos 2
    - inject s@dWE_Msg p:set_Pos

  hpos1:
    - if !<player.has_permission[dwe.pos]||<player.is_op||false>> {
      - inject locally help
      - queue clear
      }
    - define pos1 '<player.flag[dWEWand].as_list.get[1]||null>'
    - if <player.location.cursor_on[160].simple.is[==].to[%pos1%]> {
      - run s@dWE_Msg 'def:<&c>pos1 is already set'
      - queue clear
      }
    - define pos1 '<player.location.cursor_on[160].simple>'
    - define pos2 '<player.flag[dWEWand].as_list.get[2]||null>'
    - flag player dWEWand:!
    - flag player dWEWand:|:%pos1%|%pos2%
    - define pos 1
    - inject s@dWE_Msg p:set_Pos

  hpos2:
    - if !<player.has_permission[dwe.pos]||<player.is_op||false>> {
      - inject locally help
      - queue clear
      }
    - define pos2 '<player.flag[dWEWand].as_list.get[2]||null>'
    - if <player.location.cursor_on[160].simple.is[==].to[%pos2%]> {
      - run s@dWE_Msg 'def:<&c>pos2 is already set'
      - queue clear
      }
    - define pos1 '<player.flag[dWEWand].as_list.get[1]||null>'
    - define pos2 '<player.location.cursor_on[160].simple>'
    - flag player dWEWand:!
    - flag player dWEWand:|:%pos1%|%pos2%
    - define pos 2
    - inject s@dWE_Msg p:set_Pos

  chunk:
    - if !<player.has_permission[dwe.chunk]||<player.is_op||false>> {
      - inject locally help
      - queue clear
      }
    - define pos1 '<player.location.get_chunk.cuboid.min>'
    - define pos2 '<player.location.get_chunk.cuboid.max>'
    - flag player dWEWand:!
    - flag player dWEWand:|:%pos1%|%pos2%
    - run s@dWE_Msg 'def:<&f>Chunk selected<&co> <player.location.get_chunk.replace[ch@].split[,].get[1|2].comma_separated>'

  expand:
  # /dwe expand <amount/v> (n/s/e/w/u/d)
    - define command 'expand'
    - inject locally prerun instantly
    - if <c.args.get[2].escaped.is[==].to[v]||false> {
      - define pos1 '<def[pos1].sub[0,<def[pos1].y>,0].replace[l@]>'
      - define pos2 '<def[pos2].add[0,<el@val[255].sub[<def[pos2].y>]>,0].replace[l@]>'
#      - define pos1 '<def[pos1].x>,0,<def[pos1].z>'
#      - define pos2 '<def[pos2].x>,255,<def[pos2].z>'
      - flag player dWEWand:!
      - flag player dWEWand:|:%pos1%|%pos2%
      - define direction 'Vertically'
      - inject s@dWE_Msg p:expand
      - queue clear
      }

    - define n '<c.args.get[2].escaped.round_up||0>'
    - define d '<c.args.get[3].escaped||0>'
    - if <def[n].is[OR_LESS].than[0]||true> {
      - run s@dWE_Msg 'def:<&c>SYNTAX<&co> <&e>/dwe expand <&6><&lb><&7>amount/v<&6><&rb> <&6>(<&7>direction<&6>)'
      - queue clear
      }
    - if <el@[li@n|e|s|w|u|d].contains[%d%].not||true> define d '<proc[getFacing].context[<player.location.pitch.as_money>|<player.location.yaw.as_money>]>'
    - if <el@[li@n|e|s|w|u|d].contains[%d%].not||true> {
      - run s@dWE_Msg 'def:<&4><&l>ERROR<&co> <&c>Unknown direction!'
      - queue clear
      }
    - if <def[d].is[==].to[n]||false> {
      - if <def[pos1].z.is[OR_LESS].than[<def[pos2].z>]> define pos1 '<def[pos1].sub[0,0,%n%]>'
        else define pos2 '<def[pos2].sub[0,0,%n%]>'
      - define direction 'North'
      - inject s@dWE_Msg p:expand
      }
      else if <def[d].is[==].to[e]||false> {
      - if <def[pos1].x.is[OR_MORE].than[<def[pos2].x>]> define pos1 '<def[pos1].add[%n%,0,0]>'
        else define pos2 '<def[pos2].add[%n%,0,0]>'
      - define direction 'East'
      - inject s@dWE_Msg p:expand
      }
      else if <def[d].is[==].to[s]||false> {
      - if <def[pos1].z.is[OR_MORE].than[<def[pos2].z>]> define pos1 '<def[pos1].add[0,0,%n%]>'
        else define pos2 '<def[pos2].add[0,0,%n%]>'
      - define direction 'South'
      - inject s@dWE_Msg p:expand
      }
      else if <def[d].is[==].to[w]||false> {
      - if <def[pos1].x.is[OR_LESS].than[<def[pos2].x>]> define pos1 '<def[pos1].sub[%n%,0,0]>'
        else define pos2 '<def[pos2].sub[%n%,0,0]>'
      - define direction 'West'
      - inject s@dWE_Msg p:expand
      }
      else if <def[d].is[==].to[u]||false> {
      - if <def[pos1].y.is[OR_MORE].than[<def[pos2].y>]> define pos1 '<def[pos1].add[0,%n%,0]>'
        else define pos2 '<def[pos2].add[0,%n%,0]>'
      - define direction 'Up'
      - inject s@dWE_Msg p:expand
      }
      else if <def[d].is[==].to[d]||false> {
      - if <def[pos1].y.is[OR_LESS].than[<def[pos2].y>]> define pos1 '<def[pos1].sub[0,%n%,0]>'
        else define pos2 '<def[pos2].sub[0,%n%,0]>'
      - define direction 'Down'
      - inject s@dWE_Msg p:expand
      }
      else {
      - run s@dWE_Msg 'def:<&4><&l>ERROR<&co> <&c>An impossible error occurred while expanding your selection!'
      - queue clear
      }
    - flag player dWEWand:!
    - flag player dWEWand:|:%pos1%|%pos2%

  contract:
  # /dwe contract <amount> (n/s/e/w/u/d)
    - define command 'contract'
    - inject locally prerun instantly
    - define n '<c.args.get[2].escaped.round_up||0>'
    - define d '<c.args.get[3].escaped||0>'
    - if <def[n].is[OR_LESS].than[0]||true> {
      - run s@dWE_Msg 'def:<&c>SYNTAX<&co> <&e>/dwe contract <&6><&lb><&7>amount<&6><&rb> <&6>(<&7>direction<&6>)'
      - queue clear
      }
    - if <el@[li@n|e|s|w|u|d].contains[%d%].not||true> define d '<proc[getFacing].context[<player.location.pitch.as_money>|<player.location.yaw.as_money>]>'
    - if <el@[li@n|e|s|w|u|d].contains[%d%].not||true> {
      - run s@dWE_Msg 'def:<&4><&l>ERROR<&co> <&c>Unknown direction!'
      - queue clear
      }
    - if <def[d].is[==].to[n]||false> {
      - if <def[pos1].z.is[OR_LESS].than[<def[pos2].z>]> define pos2 '<def[pos2].sub[0,0,%n%]>'
        else define pos1 '<def[pos1].sub[0,0,%n%]>'
      - define direction 'North'
      - inject s@dWE_Msg p:contract
      }
      else if <def[d].is[==].to[e]||false> {
      - if <def[pos1].x.is[OR_MORE].than[<def[pos2].x>]> define pos2 '<def[pos2].add[%n%,0,0]>'
        else define pos1 '<def[pos1].add[%n%,0,0]>'
      - define direction 'East'
      - inject s@dWE_Msg p:contract
      }
      else if <def[d].is[==].to[s]||false> {
      - if <def[pos1].z.is[OR_MORE].than[<def[pos2].z>]> define pos2 '<def[pos2].add[0,0,%n%]>'
        else define pos1 '<def[pos1].add[0,0,%n%]>'
      - define direction 'South'
      - inject s@dWE_Msg p:contract
      }
      else if <def[d].is[==].to[w]||false> {
      - if <def[pos1].x.is[OR_LESS].than[<def[pos2].x>]> define pos2 '<def[pos2].sub[%n%,0,0]>'
        else define pos1 '<def[pos1].sub[%n%,0,0]>'
      - define direction 'West'
      - inject s@dWE_Msg p:contract
      }
      else if <def[d].is[==].to[u]||false> {
      - if <def[pos1].y.is[OR_MORE].than[<def[pos2].y>]> define pos2 '<def[pos2].add[0,%n%,0]>'
        else define pos1 '<def[pos1].add[0,%n%,0]>'
      - define direction 'Up'
      - inject s@dWE_Msg p:contract
      }
      else if <def[d].is[==].to[d]||false> {
      - if <def[pos1].y.is[OR_LESS].than[<def[pos2].y>]> define pos2 '<def[pos2].sub[0,%n%,0]>'
        else define pos1 '<def[pos1].sub[0,%n%,0]>'
      - define direction 'Down'
      - inject s@dWE_Msg p:contract
      }
      else {
      - run s@dWE_Msg 'def:<&4><&l>ERROR<&co> <&c>An impossible error occurred while contracting your selection!'
      - queue clear
      }
    - flag player dWEWand:!
    - flag player dWEWand:|:%pos1%|%pos2%

  inset:
  # /dwe inset <number> -h
    - define command 'inset'
    - inject locally prerun instantly
    - define n '<c.args.filter[is[matches].to[number]].get[1]||0>'
    - if <def[n].is[OR_LESS].than[0]||true> {
      - run s@dWE_Msg 'def:<&c>SYNTAX<&co> <&e>/dwe inset <&6><&lb><&7>amount<&6><&rb> <&6>(<&7>-h<&6>)'
      - queue clear
      }
    - define cuboid cu@%pos1%|%pos2%
    - if '<c.args.contains[-h].not||false>' define cuboid 'cu@<def[cuboid].min.add[0,%n%,0]>|<def[cuboid].max.sub[0,%n%,0]>'
    - define cuboid 'cu@<def[cuboid].min.add[%n%,0,%n%]>|<def[cuboid].max.sub[%n%,0,%n%]>'
    - define pos1 '<def[cuboid].min>'
    - define pos2 '<def[cuboid].max>'
    - flag player dWEWand:!
    - flag player dWEWand:|:%pos1%|%pos2%
    - inject s@dWE_Msg p:inset

  outset:
  # /dwe outset <number> -h
    - define command 'outset'
    - inject locally prerun instantly
    - define n '<c.args.filter[is[matches].to[number]].get[1]||0>'
    - if <def[n].is[OR_LESS].than[0]||true> {
      - run s@dWE_Msg 'def:<&c>SYNTAX<&co> <&e>/dwe outset <&6><&lb><&7>amount<&6><&rb> <&6>(<&7>-h<&6>)'
      - queue clear
      }
    - define cuboid cu@%pos1%|%pos2%
    - if '<c.args.contains[-h].not||false>' define cuboid 'cu@<def[cuboid].min.sub[0,%n%,0]>|<def[cuboid].max.add[0,%n%,0]>'
    - define cuboid 'cu@<def[cuboid].min.sub[%n%,0,%n%]>|<def[cuboid].max.add[%n%,0,%n%]>'
    - define pos1 '<def[cuboid].min>'
    - define pos2 '<def[cuboid].max>'
    - flag player dWEWand:!
    - flag player dWEWand:|:%pos1%|%pos2%
    - inject s@dWE_Msg p:outset

  shift:
  # /dwe shift <amount> (n/s/e/w/u/d)
    - define command 'shift'
    - inject locally prerun instantly
    - define n '<c.args.get[2].escaped.round_up||0>'
    - define d '<c.args.get[3].escaped||0>'
    - if <def[n].is[OR_LESS].than[0]||true> {
      - run s@dWE_Msg 'def:<&c>SYNTAX<&co> <&e>/dwe shift <&6><&lb><&7>amount<&6><&rb> <&6>(<&7>direction<&6>)'
      - queue clear
      }
    - if <el@[li@n|e|s|w|u|d].contains[%d%].not||true> define d '<proc[getFacing].context[<player.location.pitch.as_money>|<player.location.yaw.as_money>]>'
    - if <el@[li@n|e|s|w|u|d].contains[%d%].not||true> {
      - run s@dWE_Msg 'def:<&4><&l>ERROR<&co> <&c>Unknown direction!'
      - queue clear
      }
    - define direction '<def[d].replace[s].with[South].replace[e].with[East].replace[w].with[West].replace[n].with[North]>'
    - define n_math 'sub'
    - define n_coord '0,0,%n%'
    - define s_math 'add'
    - define s_coord '0,0,%n%'
    - define w_math 'sub'
    - define w_coord '%n%,0,0'
    - define e_math 'add'
    - define e_coord '%n%,0,0'
    - define d_math 'sub'
    - define d_coord '0,%n%,0'
    - define u_math 'add'
    - define u_coord '0,%n%,0'
    - define math '<def[%d%_math]>'
    - define coord '<def[%d%_coord]>'
    - repeat 2 {
      - define pos%value% '<def[pos%value%].%math%[%coord%]>'
      }
    - inject s@dWE_Msg p:shift
    - flag player dWEWand:!
    - flag player dWEWand:|:%pos1%|%pos2%



#   END Selection Commands
#-----------------------------
#  Editing Commands
#

  set:
  # /dwe set <material>
    - define command 'set'
    - inject locally prerun instantly
    - define material <c.args.get[2]||null>
    - if %material% !matches material {
      - run s@dWE_Msg 'def:<&c>Must specify a valid material.'
      - queue clear
      }
    - define blocks <cu@%pos1%|%pos2%.get_blocks>
    - define undoMaterials <def[blocks].parse[material.full]>
    - ~modifyblock %blocks% %material% delayed
    - flag player 'dWE_UndoHistory:->:set_blocks;<cu@%pos1%|%pos2%>;%undoMaterials%'
    - run s@dWE_Msg 'def:Set complete!'

  sphere:
  # /dwe sphere <x>,[<y>,<z>] <material>
    - define command 'sphere'
    - inject locally utility_prerun instantly
    - define size <c.args.get[2]||null>
    - define material <c.args.get[3]||null>
    - define commas <def[size].to_list.count[,]>
    - if %commas% != 2 && %commas% != 0 {
      - run s@dWE_Msg 'def:<&c>/dwe sphere <x>,[<y>,<z>] <material>'
      - queue clear
      }
    - if %material% !matches material {
      - run s@dWE_Msg 'def:<&c>/dwe sphere <x>,[<y>,<z>] <material>'
      - queue clear
      }
    - if %commas% == 0 {
      - define size %size%,%size%,%size%
      }
    - if <def[size].contains[@]> || <def[size].is[matches].to[location]> {
      - run s@dWE_Msg 'def:<&c>/dwe sphere <x>,[<y>,<z>] <material>'
      - queue clear
      }
    - define ellipsoid ellipsoid@<player.location.simple>,%size%
    - define blocks <def[ellipsoid].get_blocks>
    - define undoMaterials <def[blocks].parse[material.full]>
    - ~modifyblock %blocks% %material% delayed
    - flag player 'dWE_UndoHistory:->:set_blocks;<def[ellipsoid]>;%undoMaterials%'
    - run s@dWE_Msg 'def:Set complete!'

  copy:
  # /dwe copy
    - define command 'set'
    - inject locally prerun instantly
    - define blocks '<cu@%pos1%|%pos2%.get_blocks>'
    - flag player dWE_Clipboard:!
    - flag player 'dWE_Clipboard:|:<def[blocks].parse[material]>'
    - run s@dWE_Msg 'def:<&7><&o>Selection saved to clipboard'

  paste:
  # /dwe paste
    - if !<player.has_permission[dwe.paste]||<player.is_op||false>> {
      - inject locally help
      - queue clear
      }
    - narrate "stub"

  rotate:
  # /dwe rotate <90/180/270/360>
    - if !<player.has_permission[dwe.rotate]||<player.is_op||false>> {
      - inject locally help
      - queue clear
      }
    - narrate "stub"

  undo:
    - if !<player.has_permission[dwe.undo]||<player.is_op||false>> {
      - inject locally help
      - queue clear
      }
    - define last_action '<player.flag[dWE_UndoHistory].as_list.last||null>'
    - if <def[last_action].is[==].to[null]> run s@dWE_Msg 'def:<&6>Nothing to undo!'
      else {
      - inject locally 'p:undo_<def[last_action].split[;].get[1]>'
      - flag player 'dWE_UndoHistory:<-:%last_action%'
      }

#
#  END dWE Command Arguments
#--------------------------------------
#
#  dWE Command Utilities
#
# Just some commonly used code blocks
#
  prerun:
    - if !<player.has_permission[dwe.%command%]||<player.is_op||false>> {
      - inject locally help
      - queue clear
      }
    - define pos1 '<player.flag[dWEWand].get[1].as_location||null>'
    - define pos2 '<player.flag[dWEWand].get[2].as_location||null>'
    - if <def[pos1].is[==].to[null]>
      || <def[pos2].is[==].to[null]> {
      - run s@dWE_Msg 'def:<&c>No region selected!'
      - queue clear
      }
    - inject s@dWE_Commands p:selection_Size instantly
    - define oldSize '%size%'

  utility_prerun:
    - if !<player.has_permission[dwe.%command%]||<player.is_op||false>> {
      - inject locally help
      - queue clear
      }

  undo_set_blocks:
    - define cuboid '<def[last_action].split[;].get[2].get_blocks||null>'
    - define materials '<def[last_action].split[;].get[3]||li@>'
    - ~modifyblock %cuboid% %materials% delayed
    - run s@dWE_Msg 'def:<&a>Undo complete!'

  selection_Size:
    - define x '<def[pos1].as_location.x.sub[<def[pos2].as_location.x||<c.location.x>>].abs.add[1]||1>'
    - define y '<def[pos1].as_location.y.sub[<def[pos2].as_location.y||<c.location.y>>].abs.add[1]||1>'
    - define z '<def[pos1].as_location.z.sub[<def[pos2].as_location.z||<c.location.z>>].abs.add[1]||1>'
    - define size '<def[x].mul[%y%].mul[%z%].as_int||0>'

#
#  END dWE Command Utilities
#--------------------------------------
#
#  dWE Command Messages
#
# These are not complete! They are mostly just stubs till the rest is fleshed out!
#
  msgsHeader:
    - narrate "<&5>|----------------------------------------|"
    - narrate "<&5>|<&sp><&sp><&sp><&6>dWorldEditor   <&7>%msgsHeaderTitle%"
    - narrate "<&5>|<&f>"

  msgsFooter:
    - define anthony "text:'<&7>|Anthony|',clickEvent:{action:open_url,value:'http://mineconomy.org'},hoverEvent:{action:show_item,value:'{<i@dwe_Author_Anthony.json>}'}"
    - define morphan "text:'<&7>Morphan1',clickEvent:{action:open_url,value:'http://en.wikipedia.org/wiki/Candy'},hoverEvent:{action:show_item,value:'{<i@dwe_Author_Morphan1.json>}'}"
    - define mcmonkey "text:'<&7>mcmonkey',clickEvent:{action:open_url,value:'http://mcmonkey.org'},hoverEvent:{action:show_item,value:'{<i@dwe_Author_mcmonkey.json>}'}"
    - define spacer "text:'  '"
    - define prefix "text:'<&5>|  <&f>Authors:  '"
    - execute as_server "tellraw <player.name> {text:'',extra:[{%prefix%},{%anthony%},{%spacer%},{%morphan%},{%spacer%},{%mcmonkey%}]}"
    - narrate "<&d>|-----------S-c-r-o-l-l---U-p-------------|"

  msgsHelpAdmin:
    - define msgsHeaderTitle 'Admin Help'
    - inject locally msgsHeader instantly
    - narrate "<&5>|<&sp><&sp><&sp><&f>"
    - narrate "<&5>|<&sp><&sp><&f>"
    - narrate "<&5>|<&sp><&sp><&f>"
    - narrate "<&5>|<&sp><&sp><&f>"
    - narrate "<&5>|<&sp><&sp><&f>"
    - narrate "<&5>|<&sp><&sp><&f>"
    - narrate "<&5>|<&sp><&f>"

  msgsHelpUser:
    - define msgsHeaderTitle 'User Help'
    - inject locally msgsHeader instantly
    - narrate "<&5>|<&sp><&sp><&sp><&sp><&f>"
    - narrate "<&5>|<&sp><&sp><&f>"
    - narrate "<&5>|<&sp><&sp><&f>"
    - narrate "<&5>|<&sp><&f>"

#
#  END dWE Command Messages
#--------------------------------------
#
#  other utilities
#
# These are not complete! They are mostly just stubs till the rest is fleshed out!
#


# Usage: <proc[getFacing].context[%pitch%|%yaw%]>
getFacing:
  type: procedure
  definitions: pitch|yaw
  script:
    - if <def[pitch].is[OR_MORE].than[45]||false> determine d
      else if <def[pitch].is[OR_LESS].than[-45]||false> determine u
      else if <def[yaw].is[OR_MORE].than[337.5]||false> || <def[yaw].is[LESS].than[22.5]||false> determine s
      else if <def[yaw].is[OR_MORE].than[292.5]||false> determine se
      else if <def[yaw].is[OR_MORE].than[247.5]||false> determine e
      else if <def[yaw].is[OR_MORE].than[202.5]||false> determine ne
      else if <def[yaw].is[OR_MORE].than[157.5]||false> determine n
      else if <def[yaw].is[OR_MORE].than[112.5]||false> determine nw
      else if <def[yaw].is[OR_MORE].than[67.5]||false> determine w
      else if <def[yaw].is[OR_MORE].than[22.5]||false> determine sw
      else determine 0

#
#  END other utilities
#--------------------------------------
#
#  dWE author banner items
#
# Banner items representing the authors
#
dwe_Author_mcmonkey:
  type: item
  material: creeper_skull
  display name: <&2><&l>MCMONKEY
  lore:
  - <&a>Click to visit http://mcmonkey.org

dwe_Author_Morphan1:
  type: item
  material: creeper_skull
  display name: <&2><&l>Morphan1
  lore:
  - <&a>pls2buymesome

dwe_Author_Anthony:
  type: item
  material: i@human_skull
  display name: "<&f>             |Anthony|"
  lore:
  - <&7>  Owner<&co> <&e>M<&6>ine<&e>C<&6>onomy <&e>N<&6>etwork
  - <&5>-------------------------
  - <&7>
  - <&7>  I`ve been playing minecraft
  - <&7> and running a server since
  - <&7> 2010. I have fun and share
  - <&7> what I do.
  - <&7>
  - <&9>           Click To Visit
#
#  END dWE author banner items
#--------------------------------------
