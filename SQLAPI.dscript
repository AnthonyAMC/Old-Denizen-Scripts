# ---------------------------------------------------------------------------- #
#                                                                              |
#                                                                              |
#                         D e n i z e n   S Q L A P I                          |
#                                                                              |
#                 An API for scripters to easily implement SQL                 |
#                                                                              |
#                               *REQUIRES MYSQL*                               |
#                                                                              |
#                                                                              |
#   Author: |Anthony|                                                          |
#   Version: 0.1.1                                                             |
#   dScript Version: 0.9.6-b1573                                               |
#                                                                              |
#   Dependencies:                                                              |
#   - SQLManager:             http://mcmonkey.org/denizen/repo/entry/19        |
#   - ConfigFileGenerator:    http://mcmonkey.org/denizen/repo/entry/7         |
#                                                                              |
# ---------------------------------------------------------------------------- #
#
#
# ABOUT:
#
#     SQLAPI is a library or API for Denizen scripters to easily implement SQL
#   in their scripts. It is intended to supplement the denizen flag system for
#   those who require data to be shared across a network of servers since
#   Denizen currently has no cross server flag capability.
#
#     The SQL backend functions are almost /completely/ handled by SQLManager.
#   Automatically goes into offline caching mode if the sql database goes
#   offline!
#
#
#------------------------------------------------
#
# USAGE:
#
# -- Setup
#
#   1. Create an empty SQL database on your server. You can name it anything you
#      like. The default name is SQLAPI.
#      Consult your operating system manual or other online documentation for
#      instructions how to install and setup an sql server if needed. That is
#      beyond the scope of this documentation.
#
#   2. Install SQLManager.dscript following the instructions provided. SQLAPI
#      Will not load if SQLManager is not installed!
#
#   3. Install sqlapi.dscript to you Denizen scripts folder and type:
#      /denizen reload scripts
#
#   4. From console or in game (with sqlapi.admin permission) type:
#      /sqlapi --restart
#      This will extract the config file to /Denizen/SQLAPI/config.yml
#      SQLAPI will begin the connection attempt process, but will fail until
#      you edit the config.yml file with valid connection information.
#
#   5. Edit the config.yml file with valid connection information for your SQL
#      database created in step 1. If you have edit config.yml before the
#      connection attempt cycle expires, SQLAPI will proceed with setup, if not
#      you will need to repeat step 4.
#
#   6. SQLAPI is now installed! Rejoice!
#
#
# -- Permissions
#
#    Admin permission: sqlapi.admin
#
#
#------------------------------------------------
#
# API Guidelines and Explanation
#
# -- Notes
#
#  - SQLAPI utilizes the events system for setting/editing/deleting sql flags.
#    - Learn more about the events command: http://mcmonkey.org/denizen/cmds/event
#
#    - The events command in Denizen lacks the ability to handle lists directly
#      in the context section. You MUST use the .escaped tag when supplying a
#      list value!
#
# -- Setting/Editing/Deleting Flags
#
#    Working with SQL flags is easy! You must specify the type, flagName,
#  and flagValue context fields when you do. The duration field is optional. The
#  owner field is not used for the server type flags.
#
#    Full Example:
#    - event 'slqflag set' 'context:type|player|owner|<playerObject>|flagName|myFlag|flagValue|potato|duration|5s'
#
#
# -- Context Fields
#
#  ~ Type
#
#    There are four (4) flag types available through SQLAPI.
#    - Type Values
#      - server - Global flags with no owner
#      - player - Player specific flags
#      - npc    - NPC specific flags
#      - entity - Entity specific flags (not fully implemented)
#
#    Example:
#    'context:type|player'
#
#
#  ~ Owner
#
#    The owner field is required for player, npc, and entity flag types, but is
#   NOT required for server type flags. The owner field must contain a valid
#   entity object for that particular flag type. A player type flag must have
#   a <player> object in the owner field. An NPC flag must have an <npc> object
#   in the owner field. An entity flag must have an <entity> object in the owner
#   field.
#
#    Example:
#    'context:owner|<player>'
#
#
#  ~ FlagName
#
#    The flagName field is where you declare the name of your flag. Flag names
#   MUST be unique. Setting a flag value on an existing flag will overwrite it.
#   Players, NPCs, and entities all have their own flag associations, which
#   means that player A and player B can both have a flag named 'potato' with no
#   conflicts.
#
#    Flag names are limited to roughly 21,844 UTF-8 characters. You should have
#   plenty of room for exotic flag names.
#
#    Example:
#    'context:flagName|potato'
#
#
#  ~ FlagValue
#
#    The flagValue field is where you store the value of your flag. It can hold
#   any string, integer, decimal, boolean, or list value you like. It has a
#   theoretical limit of 5,592,404 UTF-8 characters.
#
#    When working with a list flagValue, you must escape the whole list. This is
#   required to overcome a limitation with the events command. Your data will be
#   stored and returned to you correctly. You may also choose to use your own
#   delimiter. You will be responsible for recreating your lists when you
#   retrieve the value.
#    Example:
#    - define list 'li@a|b|c'
#    - event 'slqflag set' 'context:type|server|flagName|myFlag|flagValue|<def[list].escaped>'
#
#
#  ~ Duration
#
#    The duration field is an optional field for all flags. Setting a duration
#   on a flag will make the flag available for specific amount of time. The
#   value for the duration field can be provided in any of the following
#   formats: T=ticks, M=minutes, S=seconds, H=hours, D=days, W = Weeks.
#   Not using a unit will imply seconds.
#    Example:
#    - event 'slqflag set' 'context:duration|10s'
#
#------------------------------------------------
#
#               C h a n g e l o g
#
# - v0.1.1  -  4/28/15
#   - List index manipulations
#     - Insert: Inserts additional values starting at the specified index
#     - Set: Inserts additional values replacing the specified index
#
# - v0.1.1  -  4/27/15
#   - Correctly distinguish between existent and expired flags when editing lists
#   - Math functions. Can now increment, decrement, multiply, and divide flags
#
# - v0.1.1  -  4/26/15
#   - Make <proc[SQLAPI_GetFlag].context[owner|flag]||null> handle lists natively
#   - Set list function works, may be expanded/revised at a later date
#   - Added Include and Remove list functions
#
# - v0.1.1  -  4/25/15
#   - Don't store escaped values in the db
#
# - v0.1.1  -  4/21/15
#   - Added <proc[SQLAPI_GetFlag].context[owner|flag]||null>
#     - Returns the flag value
#     - Does not return if the flag doesn't exist or is expired.
#
# - v0.1.1  -  4/20/15
#   - Added <proc[SQLAPI_ParseOwner].context[owner]||null>
#     - Specify an owner object and it returns the type.
#     - Return values are player, entity, npc, server, and thisPlayer.
#     - Does not return on invalid input. Notify console instead
#     - 'thisPlayer' is a literal string and should be handled in the calling
#       script. It's intended for the sqlflag command so the literal string
#       'player' can be used to denote the person issuing the command.
#   - Simplified the context required for GetFlagRecord, FlagExists, IsExpired,
#     and HasFlag procedure scripts. Now only require the owner and flag context
#     Eg.: <proc[SQLAPI_HasFlag].context[owner|flag]>
#
# - v0.1.1  -  4/20/15
#   - sqlflag command
#     - Allows setting/editing/deleting flags in game with a command
#     - Currently only the set flag code is written. Don't try to do any list
#       flags or removing flags yet!
#   - Added <proc[SQLAPI_GetFlagRecord].context[tablename|owner|flag]||null>
#     - Returns a raw flag record li@flagName|flagValue|expiriation
#     - Returns "SQLAPI OFFLINE" if the db is offline
#     - Really only meant for internal usage. There will be more user friendly
#       options available in the future.
#   - Added <proc[SQLAPI_FlagExists].context[tablename|owner|flag]>
#     - Boolean tag to check if a flag exists
#     - Does not return if the db is offline
#     - Really only meant for internal usage.
#   - Added <proc[SQLAPI_IsExpired].context[tablename|owner|flag]>
#     - Boolean tag to check if a flag exists
#     - Does not return if the flag does not exist OR the db is offline.
#     - Really only meant for internal usage.
#   - Added <proc[SQLAPI_HasFlag].context[tablename|owner|flag]>
#     - Boolean tag to check if a object has a flag.
#     - Returns true if the flag exists and is not expired.
#     - Returns false if the flag does not exist or is expired.
#     - Does not return if the db is offline.
#
# - v0.1  -  4/13/15
#   - Initial commit
#
#
#------------------------------------------------
#
#          TODO - Future Feature Fluff
#
#
#______________________________________________________________________________#

SQLAPI:
  type: world
  speed: 0
  debug: false
  action_map:
    set_list: '&pipe'
    include: '-&gt'
    remove: '&lt-'
    increment: '++|+'
    decrement: '--|-'
    multiply: '**|*'
    divide: '&fs&fs|&fs'
    clear: '&exc'

  events:
    on server start:
    - run locally start delay:1t

    on sqlflag set:
    - define type '<c.type>'
    - define owner '<c.owner>'
    - define flagName '<c.flagName.sql_escaped>'
    - define flagValue '<c.flagValue.unescaped.sql_escaped>'
    - define expiration '<c.expiration.sql_escaped||null>'
    - inject locally set_flag

    on sqlflag clear:
    - define type '<c.type>'
    - define owner '<c.owner>'
    - define flagName '<c.flagName.sql_escaped>'
    - define flagValue '<c.flagValue.unescaped.sql_escaped>'
    - define expiration '<c.expiration.sql_escaped||null>'
    - inject locally clear_flag

    on sqlflag include:
    - define type '<c.type>'
    - define owner '<c.owner>'
    - define flagName '<c.flagName.sql_escaped>'
    - define flagValue '<c.flagValue.unescaped.sql_escaped>'
    - define expiration '<c.expiration.sql_escaped||null>'
    - inject locally include_flag

    on sqlflag remove:
    - define type '<c.type>'
    - define owner '<c.owner>'
    - define flagName '<c.flagName.sql_escaped>'
    - define flagValue '<c.flagValue.unescaped.sql_escaped>'
    - define expiration '<c.expiration.sql_escaped||null>'
    - inject locally remove_flag

    on sqlflag increment:
    - define type '<c.type>'
    - define owner '<c.owner>'
    - define flagName '<c.flagName.sql_escaped>'
    - define flagValue '<c.flagValue.unescaped.sql_escaped>'
    - define expiration '<c.expiration.sql_escaped||null>'
    - inject locally increment_flag

    on sqlflag decrement:
    - define type '<c.type>'
    - define owner '<c.owner>'
    - define flagName '<c.flagName.sql_escaped>'
    - define flagValue '<c.flagValue.unescaped.sql_escaped>'
    - define expiration '<c.expiration.sql_escaped||null>'
    - inject locally decrement_flag

    on sqlapi command:
    - if !<player.permission[sqlapi.admin]||false> && !<player.is_op> && !<c.server> {
      - queue clear
      }
    - determine passively FULFILLED
    - define arg1 '<c.args.get[1].escaped||null>'
    - if <def[arg1].is[==].to[--restart]> {
      - narrate "<&b>SQLAPI<&co> <&d>Restarting System!"
      - define isRelaod ''
      - inject locally start
      }

    on sqlflag command:
    - if !<player.permission[sqlapi.admin]||false> && !<player.is_op> && !<c.server> {
      - queue clear
      }
    - determine passively FULFILLED
    - if <c.args.size> < 2 {
      - narrate "<&b>SQLAPI<&co><&c> /sqlflag <&lt>owner<&gt> flagName(<&co>action)(<&co>value) (duration<&co>duration)"
      - queue clear
      }

    - define owner '<parse:<c.args.get[1]||null>>'
    - define type '<proc[SQLAPI_ParseOwner].context[%owner%]||null>'
    - if %type% == null {
      - narrate "<&b>SQLAPI<&co><&c> Must specify valid flag holder!"
      - queue clear
      }
      else if %type% == thisPlayer {
      - if <c.server> {
        - announce to_console "<&b>SQLAPI<&co><&c> Must specify valid player object from console!"
        - queue clear
        }
      - define type 'player'
      - define owner '<player>'
      }
      else if %type% != server {
      - define owner '<def[owner].as_%type%>'
      }

    - define preparse '<c.args.get[2].escaped.split[&co]||null>'
    - define size '<def[preparse].size>'
    - define flagName '<def[preparse].get[1].to_lowercase.sql_escaped||null>'
    - if %flagName% contains &lb {
      - define index '<def[flagName].after[&lb].replace[&rb]>'
      - define flagName '<def[flagName].before[&lb]>'
      - if <def[index].length> == 0 || <def[index].is[matches].to[number].not||true> {
        - define index:!
        }
      }

    - if %size% == 1 {
      - define flagValue 'true'
      - define action 'set'
      }
      else if %size% == 2 {
      - define action '<def[preparse].get[2]||null>'
      - inject locally parseAction
      - if %action% == set {
        - define flagValue '<def[preparse].get[2].unescaped.sql_escaped>'
        - if <def[index].exists> {
          - define action 'set_index'
          }
        }
        else if <li@increment|decrement|multiply|divide> contains %action% {
        - define flagValue '1'
        }
        else if %action% == clear {
        - define flagValue 'null'
        }
        else {
        - narrate "<&b>SQLAPI<&co><&c> Must specify a flag value for %action% flag action!"
        - announce to_console "<&b>SQLAPI<&co><&c> Must specify a flag value for %action% flag action!"
        - queue clear
        }
      }
      else {
      - define flagValue '<c.args.get[2].after[<def[preparse].get[2].unescaped><&co>].sql_escaped||null>'
      - define action '<def[preparse].get[2]||null>'
      - inject locally parseAction
      - if %action% == set {
        - define flagValue '<c.args.get[2].after[<def[preparse].get[1].unescaped><&co>].sql_escaped||null>'
        - if <def[index].exists> {
          - define action 'set_index'
          }
        }
        else if <li@increment|decrement|multiply|divide> contains %action% {
        - if %flagValue% !matches decimal {
          - narrate "<&b>SQLAPI<&co><&c> %flagValue% is not a valid number!"
          - queue clear
          }
        }
        else if %action% == set_list {
        - if <def[index].exists> {
          - define action 'set_index'
          }
        }
        else if %action% == include {
        - if <def[index].exists> {
          - define action 'insert_index'
          }
        }
      }

    - define duration '<c.args.get[3]||null>'
    - if <def[duration].starts_with[d<&co>]> || <def[duration].starts_with[duration<&co>]> {
      - define expiration '<def[duration].split[<&co>].get[2].as_duration||null>'
      - if %expiration% == null {
        - announce to_console '<&b>SQLAPI<&co><&c> <def[expiration].split[<&co>].get[2]||null> is not a valid duration!'
        - define expiration '0'
        }
        else {
        - define expiration '<def[expiration].in_milliseconds.add_int[<server.current_time_milliseconds>]>'
        }
      }
      else {
      - define expiration '0'
      }
#    - announce "Narrate values"
#    - narrate "<&2>==="
#    - narrate "size %size%"
#    - narrate "owner %owner% %type% <def[owner].uuid>"
#    - narrate "flag %flagName%"
#    - narrate "action %action%"
#    - narrate "flagvalue %flagvalue%"
#    - narrate "expiration %expiration%"
    - inject locally %action%_flag
    - inject locally msg_%action%
    - queue clear

  parseAction:
    - define actions '<script.list_keys[action_map]>'
    - foreach %actions% {
      - define map '<script.yaml_key[action_map.%value%].as_list||li@>'
      - if <def[map].contains_any[%action%]||false> {
        - define action '<def[value].to_lowercase>'
        - foreach stop
        }
      }
    - if %actions% !contains %action% {
      - define action 'set'
      }


  start:
    - ^define yamlName 'SQLAPI'
    - ^define scriptName '<script.name>'
    - ^inject locally reloadYaml instantly
    - ^inject locally loadData instantly
    - ^if %useSql% {
      - announce "<&b>SQLAPI<&co><&c> Must be configured to use MySQL!" to_console
      - inject locally unload
      - queue stop
      }
    # Verify SQLManager is installed and ready
    - ^if !<server.list_scripts.parse[name].contains[SQLManager]> {
      - announce "<&b>SQLAPI<&co><&c> SQLManager not installed!" to_console
      - inject locally unload
      - queue stop
      }
    - ^repeat %retry% {
      - if !<yaml.list.contains[SQLManager_Offline]> {
        - announce "<&b>SQLAPI<&co><&c> Could not connect to SQLManager!" to_console
        - if %loop_index% == %retry% {
          - inject locally unload
          - queue stop
          }
        - announce "<&b>SQLAPI<&co><&c> Will attempt again in %retryDelay%..." to_console
        - wait %retryDelay%
        }
      }
    # This checks the status as set by SQLManager to not duplicate restart
    # processes. This is the only time this script needs to set the status.
    # The SQLManager will handle every other situation.
    - ^define status '<yaml[SQLManager_Offline].read[Offline_Cache.databases.%db%.status]||null>'
    - ^if <def[status].is[==].to[connecting]> {
      - announce "<&b>SQLManager<&co><&c> Already attempting to reconnect to %db% database!" to_console
      - queue stop
      }
      else {
      - yaml set 'id:SQLManager_Offline' 'Offline_Cache.databases.%db%.status:connecting'
      - yaml 'savefile:SQLManager/cache.yml' 'id:SQLManager_Offline'
      }
    - ^if <def[isReload].exists||false> {
      - run s@SQLManager p:restart delay:1t def:%yamlName%|%scriptName%|%db%
      - queue clear
      }
    - ^inject s@SQLManager
    - ^announce "<&b>SQLAPI<&co><&a> System loaded!" to_console
    - queue stop

  reloadYaml:
  # Reloads the yaml files and generates default files if they don't exist.
    - announce "<&b>SQLAPI<&co><&3> Loading system config files..." to_console
    - if !<server.has_file[SQLAPI/config.yml]> {
      - if <player> != null {
        - flag <player> ConfigFileGeneratorNotify:true
        - run s@ConfigFileGeneratorHelper def:SQLAPI|Configurations|false|false|false instantly
        - flag <player> ConfigFileGeneratorNotify:!
        }
        else {
        - run s@ConfigFileGeneratorHelper def:SQLAPI|Configurations instantly
        }
      }
    - if <yaml.list.contains[SQLAPI_config]> yaml unload 'id:SQLAPI_config'
    - yaml 'load:SQLAPI/config.yml' 'id:SQLAPI_config'
    - inject s@SQLAPI_SQLTables
    - announce "<&b>SQLAPI<&co><&a> System config files Loaded!" to_console

  loadData:
    - ^define yamlName 'SQLAPI'
    - ^define scriptName '<script.name>'
    - ^define useSql '<yaml[SQLAPI_config].read[config.MySQL.useSql]||false>'
    - ^define retry '<yaml[SQLAPI_config].read[config.MySQL.retry]||3>'
    - ^define retryDelay '<yaml[SQLAPI_config].read[config.MySQL.retryDelay]||10s>'
    - ^define db '<yaml[SQLAPI_config].read[config.MySQL.database]||SQLAPI>'
    - ^define PlayerSQLFLagsTable '<yaml[SQLAPI_config].read[config.MySQL.tables.PlayerSQLFLags]||dsqlapi_playersqlflags>'
    - ^define NPCSQLFLagsTable '<yaml[SQLAPI_config].read[config.MySQL.tables.NPCSQLFLags]||dsqlapi_npcsqlflags>'
    - ^define EntitySQLFLagsTable '<yaml[SQLAPI_config].read[config.MySQL.tables.EntitySQLFLags]||dsqlapi_entitysqlflags>'
    - ^define ServerSQLFLagsTable '<yaml[SQLAPI_config].read[config.MySQL.tables.ServerSQLFLags]||dsqlapi_serversqlflags>'

  unload:
    - ^if <yaml.list.contains[SQLAPI_config]> {
      - announce "<&b>SQLAPI<&co><&3> Unloading config.yml file..." to_console
      - yaml unload 'id:SQLAPI_config'
      }
    - ^if <yaml.list.contains[SQLAPI_SQLTables]> {
      - announce "<&b>SQLAPI<&co><&3> Unloading SQLAPI_SQLTables file..." to_console
      - yaml unload 'id:SQLAPI_SQLTables'
      }
    - ^announce "<&b>SQLAPI<&co><&c> System disabled..." to_console


  clear_flag:
    - define yamlName 'SQLAPI'
    - define scriptName 'SQLAPI'
    - define db '<yaml[SQLAPI_config].read[config.MySQL.database]||SQLAPI>'
    - define tableName '<yaml[SQLAPI_config].read[config.MySQL.tables.%type%SQLFLags]||dsqlapi_%type%sqlflags>'
    - define flagExists '<proc[SQLAPI_FlagExists].context[%owner%|%flagName%]||offline>'
    - if %flagExists% == offline {
      - announce to_console "<&b>SQLAPI<&co><&c> System Offline! Can not remove %flagName% for %owner%!"
      - queue clear
      }
    - if !%flagExists% {
      - announce to_console "<&b>SQLAPI<&co><&c> %owner% does not set %flagName%!"
      - if <player.is[!=].to[null]||false> {
        - narrate "<&b>SQLAPI<&co><&c> %owner% does not set %flagName%!"
        }
      - queue clear
      }
    - if %type% == server {
      - define statement "DELETE FROM %tableName% WHERE flag='%flagName%';"
      }
      else {
      - define uuid '<tern[<def[type].is[==].to[npc]>]:<def[owner].id>||<def[owner].uuid>>'
      - define statement "DELETE FROM %tableName% WHERE flag='%flagName%' AND uuid='%uuid%';"
      }
    - inject s@SQLManager_Offline p:managedUpdateStatement

  set_flag:
    - define yamlName 'SQLAPI'
    - define scriptName 'SQLAPI'
    - define db '<yaml[SQLAPI_config].read[config.MySQL.database]||SQLAPI>'
    - define tableName '<yaml[SQLAPI_config].read[config.MySQL.tables.%type%SQLFLags]||dsqlapi_%type%sqlflags>'
    - define flagExists '<proc[SQLAPI_FlagExists].context[%owner%|%flagName%]>'
    - if %flagExists% == offline {
      - announce to_console "<&b>SQLAPI<&co><&c> System Offline! Can not set %flagName% for %owner% to %flagValue% in %tableName%!"
      - queue clear
      }

    - if %type% == server {
      - if %flagExists% {
        - define statement "UPDATE %tableName% SET expiration = '%expiration%', value = '%flagValue%' WHERE flag='%flagName%';"
        }
        else {
        - define statement "INSERT INTO %tableName% (flag, value, expiration) VALUES ('%flagName%', '%flagValue%', '%expiration%');"
        }
      }
      else {
      - define uuid '<tern[<def[type].is[==].to[npc]>]:<def[owner].id>||<def[owner].uuid>>'
      - if %flagExists% {
        - define statement "UPDATE %tableName% SET expiration = '%expiration%', value = '%flagValue%' WHERE flag='%flagName%' AND uuid='%uuid%';"
        }
        else {
        - define statement "INSERT INTO %tableName% (uuid, flag, value, expiration) VALUES ('%uuid%', '%flagName%', '%flagValue%', '%expiration%');"
        }
      }
    - inject s@SQLManager_Offline p:managedUpdateStatement

  set_index_flag:
    - define yamlName 'SQLAPI'
    - define scriptName 'SQLAPI'
    - define db '<yaml[SQLAPI_config].read[config.MySQL.database]||SQLAPI>'
    - define tableName '<yaml[SQLAPI_config].read[config.MySQL.tables.%type%SQLFLags]||dsqlapi_%type%sqlflags>'
    - define record '<proc[SQLAPI_GetFlagRecord].context[%owner%|%flagName%]||null>'
    - if '<def[record].equals_case_sensitive[SQLAPI OFFLINE]>' {
      - announce to_console "<&b>SQLAPI<&co><&c> System Offline! Can not set index %index% %flagName% for %owner% to %flagValue% in %tableName%!"
      - queue clear
      }
    - if %record% != null {
      - define flagExists 'true'
      - define expires '<def[record].get[3].unescaped||0>'
      - if %expires% == 0 || %expires% > <server.current_time_millis> {
        - define isExpired 'false'
        }
        else {
        - define isExpired 'true'
        }
      }
      else {
      - define flagExists 'false'
      - define isExpired 'true'
      }

    - if %flagExists% && !%isExpired% {
      - define flagVal '<def[record].get[2].unescaped||null>'
      - if <def[flagVal].starts_with[|]> {
        - define flagVal '<def[flagVal].as_list>'
        - define flagValue '<&pipe><def[flagVal].get[2].to[<def[flagVal].size>].set[%flagValue%].at[%index%].replace[li@]>'
        }
        else {
        - define flagValue '<&pipe>%flagValue%'
        }
      }
      else {
      - define flagValue '<&pipe>%flagValue%'
      }

    - if %type% == server {
      - if %flagExists% {
        - define statement "UPDATE %tableName% SET expiration = '%expiration%', value = '%flagValue%' WHERE flag='%flagName%';"
        }
        else {
        - define statement "INSERT INTO %tableName% (flag, value, expiration) VALUES ('%flagName%', '%flagValue%', '%expiration%');"
        }
      }
      else {
      - define uuid '<tern[<def[type].is[==].to[npc]>]:<def[owner].id>||<def[owner].uuid>>'
      - if %flagExists% {
        - define statement "UPDATE %tableName% SET expiration = '%expiration%', value = '%flagValue%' WHERE flag='%flagName%' AND uuid='%uuid%';"
        }
        else {
        - define statement "INSERT INTO %tableName% (uuid, flag, value, expiration) VALUES ('%uuid%', '%flagName%', '%flagValue%', '%expiration%');"
        }
      }
    - inject s@SQLManager_Offline p:managedUpdateStatement

  set_list_flag:
    - define yamlName 'SQLAPI'
    - define scriptName 'SQLAPI'
    - define db '<yaml[SQLAPI_config].read[config.MySQL.database]||SQLAPI>'
    - define tableName '<yaml[SQLAPI_config].read[config.MySQL.tables.%type%SQLFLags]||dsqlapi_%type%sqlflags>'
    - define record '<proc[SQLAPI_GetFlagRecord].context[%owner%|%flagName%]||null>'
    - if '<def[record].equals_case_sensitive[SQLAPI OFFLINE]>' {
      - announce to_console "<&b>SQLAPI<&co><&c> System Offline! Can not set %flagName% for %owner% to %flagValue% in %tableName%!"
      - queue clear
      }
    - if %record% != null {
      - define flagExists 'true'
      - define expires '<def[record].get[3].unescaped||0>'
      - if %expires% == 0 || %expires% > <server.current_time_millis> {
        - define isExpired 'false'
        }
        else {
        - define isExpired 'true'
        }
      }
      else {
      - define flagExists 'false'
      - define isExpired 'true'
      }

    - if %flagExists% && !%isExpired% {
      - define flagVal '<def[record].get[2].unescaped||null>'
      - if <def[flagVal].starts_with[|]> {
        - define flagVal '<def[flagVal].as_list>'
        - define flagValue '<&pipe><def[flagVal].get[2].to[<def[flagVal].size>].replace[li@]><&pipe>%flagValue%'
        }
        else {
        - define flagValue '<&pipe>%flagValue%'
        }
      }
      else {
      - define flagValue '<&pipe>%flagValue%'
      }

    - if %type% == server {
      - if %flagExists% {
        - define statement "UPDATE %tableName% SET expiration = '%expiration%', value = '%flagValue%' WHERE flag='%flagName%';"
        }
        else {
        - define statement "INSERT INTO %tableName% (flag, value, expiration) VALUES ('%flagName%', '%flagValue%', '%expiration%');"
        }
      }
      else {
      - define uuid '<tern[<def[type].is[==].to[npc]>]:<def[owner].id>||<def[owner].uuid>>'
      - if %flagExists% {
        - define statement "UPDATE %tableName% SET expiration = '%expiration%', value = '%flagValue%' WHERE flag='%flagName%' AND uuid='%uuid%';"
        }
        else {
        - define statement "INSERT INTO %tableName% (uuid, flag, value, expiration) VALUES ('%uuid%', '%flagName%', '%flagValue%', '%expiration%');"
        }
      }
    - inject s@SQLManager_Offline p:managedUpdateStatement

  include_flag:
    - define yamlName 'SQLAPI'
    - define scriptName 'SQLAPI'
    - define db '<yaml[SQLAPI_config].read[config.MySQL.database]||SQLAPI>'
    - define tableName '<yaml[SQLAPI_config].read[config.MySQL.tables.%type%SQLFLags]||dsqlapi_%type%sqlflags>'
    - define record '<proc[SQLAPI_GetFlagRecord].context[%owner%|%flagName%]||null>'
    - if '<def[record].equals_case_sensitive[SQLAPI OFFLINE]>' {
      - announce to_console "<&b>SQLAPI<&co><&c> System Offline! Can not include %flagValue% in %flagName% for %owner% in %tableName%!"
      - queue clear
      }
    - if %record% != null {
      - define flagExists 'true'
      - define expires '<def[record].get[3].unescaped||0>'
      - if %expires% == 0 || %expires% > <server.current_time_millis> {
        - define isExpired 'false'
        }
        else {
        - define isExpired 'true'
        }
      }
      else {
      - define flagExists 'false'
      - define isExpired 'true'
      }

    - if %flagExists% && !%isExpired% {
      - define flagVal '<def[record].get[2].unescaped||null>'
      - if <def[flagVal].starts_with[|]> {
        - define flagVal '<def[flagVal].as_list>'
        - define flagValue '<&pipe><def[flagVal].get[2].to[<def[flagVal].size>].replace[li@]><&pipe>%flagValue%'
        }
        else {
        - define flagValue '<&pipe>%flagValue%'
        }
      }
      else {
      - define flagValue '<&pipe>%flagValue%'
      }

    - if %type% == server {
      - if %flagExists% {
        - define statement "UPDATE %tableName% SET expiration = '%expiration%', value = '%flagValue%' WHERE flag='%flagName%';"
        }
        else {
        - define statement "INSERT INTO %tableName% (flag, value, expiration) VALUES ('%flagName%', '%flagValue%', '%expiration%');"
        }
      }
      else {
      - define uuid '<tern[<def[type].is[==].to[npc]>]:<def[owner].id>||<def[owner].uuid>>'
      - if %flagExists% {
        - define statement "UPDATE %tableName% SET expiration = '%expiration%', value = '%flagValue%' WHERE flag='%flagName%' AND uuid='%uuid%';"
        }
        else {
        - define statement "INSERT INTO %tableName% (uuid, flag, value, expiration) VALUES ('%uuid%', '%flagName%', '%flagValue%', '%expiration%');"
        }
      }
    - inject s@SQLManager_Offline p:managedUpdateStatement

  insert_index_flag:
    - define yamlName 'SQLAPI'
    - define scriptName 'SQLAPI'
    - define db '<yaml[SQLAPI_config].read[config.MySQL.database]||SQLAPI>'
    - define tableName '<yaml[SQLAPI_config].read[config.MySQL.tables.%type%SQLFLags]||dsqlapi_%type%sqlflags>'
    - define record '<proc[SQLAPI_GetFlagRecord].context[%owner%|%flagName%]||null>'
    - if '<def[record].equals_case_sensitive[SQLAPI OFFLINE]>' {
      - announce to_console "<&b>SQLAPI<&co><&c> System Offline! Can not insert %flagValue% at index %index% for %flagName% for %owner% in %tableName%!"
      - queue clear
      }
    - if %record% != null {
      - define flagExists 'true'
      - define expires '<def[record].get[3].unescaped||0>'
      - if %expires% == 0 || %expires% > <server.current_time_millis> {
        - define isExpired 'false'
        }
        else {
        - define isExpired 'true'
        }
      }
      else {
      - define flagExists 'false'
      - define isExpired 'true'
      }

    - narrate "%flagValue%"
    - if %flagExists% && !%isExpired% {
      - define flagVal '<def[record].get[2].unescaped||null>'
      - if <def[flagVal].starts_with[|]> {
        - define flagVal '<def[flagVal].as_list>'
        - define flagValue '<&pipe><def[flagVal].get[2].to[<def[flagVal].size>].insert[%flagValue%].at[%index%].replace[li@]>'
        }
        else {
        - define flagValue '<&pipe>%flagValue%'
        }
      }
      else {
      - define flagValue '<&pipe>%flagValue%'
      }

    - if %type% == server {
      - if %flagExists% {
        - define statement "UPDATE %tableName% SET expiration = '%expiration%', value = '%flagValue%' WHERE flag='%flagName%';"
        }
        else {
        - define statement "INSERT INTO %tableName% (flag, value, expiration) VALUES ('%flagName%', '%flagValue%', '%expiration%');"
        }
      }
      else {
      - define uuid '<tern[<def[type].is[==].to[npc]>]:<def[owner].id>||<def[owner].uuid>>'
      - if %flagExists% {
        - define statement "UPDATE %tableName% SET expiration = '%expiration%', value = '%flagValue%' WHERE flag='%flagName%' AND uuid='%uuid%';"
        }
        else {
        - define statement "INSERT INTO %tableName% (uuid, flag, value, expiration) VALUES ('%uuid%', '%flagName%', '%flagValue%', '%expiration%');"
        }
      }
    - inject s@SQLManager_Offline p:managedUpdateStatement

  remove_flag:
    - define yamlName 'SQLAPI'
    - define scriptName 'SQLAPI'
    - define db '<yaml[SQLAPI_config].read[config.MySQL.database]||SQLAPI>'
    - define tableName '<yaml[SQLAPI_config].read[config.MySQL.tables.%type%SQLFLags]||dsqlapi_%type%sqlflags>'
    - define record '<proc[SQLAPI_GetFlagRecord].context[%owner%|%flagName%]||null>'
    - if '<def[record].equals_case_sensitive[SQLAPI OFFLINE]>' {
      - announce to_console "<&b>SQLAPI<&co><&c> System Offline! Can not remove %flagValue% from %flagName% for %owner% in %tableName%!"
      - queue clear
      }
    - if %record% != null {
      - define expires '<def[record].get[3].unescaped||0>'
      - if %expires% == 0 || %expires% > <server.current_time_millis> {
        - define flagExists 'true'
        }
        else {
        - define flagExists 'false'
        }
      }
      else {
      - define flagExists 'false'
      }

    - if !%flagExists% {
      - announce to_console "<&b>SQLAPI<&co><&c> %owner% does not set %flagName%!"
      - if <player.is[!=].to[null]||false> {
        - narrate "<&b>SQLAPI<&co><&c> %owner% does not set %flagName%!"
        }
      - queue clear
      }
    - define flagVal '<def[record].get[2].unescaped.as_list||null>'
    - if <def[flagVal].as_list.contains_any[%flagValue%]> {
      - define flagValue '<&pipe><def[flagVal].get[2].to[<def[flagVal].size>].exclude[%flagValue%].replace[li@]>'
      }
      else {
      - announce to_console "<&b>SQLAPI<&co><&c> %flagName% does not contain any %flagValue% for %owner%!"
      - if <player.is[!=].to[null]||false> {
        - narrate "<&b>SQLAPI<&co><&c> %flagName% does not contain any %flagValue% for %owner%!"
        }
      - queue clear
      }

    - if <def[flagValue].is[==].to[<&pipe>]> {
      - define delete 'true'
      }
      else {
      - define delete 'false'
      }

    - if %type% == server {
      - if %delete% {
        - define statement "DELETE FROM %tableName% WHERE flag='%flagName%';"
        }
        else {
        - define statement "UPDATE %tableName% SET expiration = '%expiration%', value = '%flagValue%' WHERE flag='%flagName%';"
        }
      }
      else {
      - define uuid '<tern[<def[type].is[==].to[npc]>]:<def[owner].id>||<def[owner].uuid>>'
      - if %delete% {
        - define statement "DELETE FROM %tableName% WHERE flag='%flagName%' AND uuid='%uuid%';"
        }
        else {
        - define statement "UPDATE %tableName% SET expiration = '%expiration%', value = '%flagValue%' WHERE flag='%flagName%' AND uuid='%uuid%';"
        }
      }
    - inject s@SQLManager_Offline p:managedUpdateStatement

  increment_flag:
    - if %flagValue% !matches decimal {
      - announce to_console "<&b>SQLAPI<&co><&c> %flagValue% is not a valid number! Not incrementing %flagName% for %owner%!"
      - if <player.is[!=].to[null]||false> {
        - narrate "<&b>SQLAPI<&co><&c> %flagValue% is not a valid number! Not incrementing %flagName% for %owner%!"
        }
      - queue clear
      }
    - define yamlName 'SQLAPI'
    - define scriptName 'SQLAPI'
    - define db '<yaml[SQLAPI_config].read[config.MySQL.database]||SQLAPI>'
    - define tableName '<yaml[SQLAPI_config].read[config.MySQL.tables.%type%SQLFLags]||dsqlapi_%type%sqlflags>'
    - define record '<proc[SQLAPI_GetFlagRecord].context[%owner%|%flagName%]||null>'
    - if '<def[record].equals_case_sensitive[SQLAPI OFFLINE]>' {
      - announce to_console "<&b>SQLAPI<&co><&c> System Offline! Can not increment %flagName% for %owner% by %flagValue% in %tableName%!"
      - queue clear
      }
    - if %record% != null {
      - define flagExists 'true'
      - define expires '<def[record].get[3].unescaped||0>'
      - if %expires% == 0 || %expires% > <server.current_time_millis> {
        - define isExpired 'false'
        }
        else {
        - define isExpired 'true'
        }
      }
      else {
      - define flagExists 'false'
      - define isExpired 'true'
      }

    - if %flagExists% {
      - define flagVal '<def[record].get[2].unescaped||null>'
      - if %flagVal% !matches decimal {
        - announce to_console "<&b>SQLAPI<&co> <&c>Not incrementing %flagName% for %owner%! Current value %flagVal% is not numeric!"
        - if <player.is[!=].to[null]||false> {
          - narrate "<&b>SQLAPI<&co> <&c>Not incrementing %flagName% for %owner%! Current value %flagVal% is not numeric!"
          }
        - queue clear
        }
      }

    - if %type% == server {
      - if %flagExists% {
        - if %isExpired% {
          - define statement "UPDATE %tableName% SET expiration = '%expiration%', value = '%flagValue%' WHERE flag='%flagName%';"
          }
          else {
          - define statement "UPDATE %tableName% SET expiration = '%expiration%', value = value + '%flagValue%' WHERE flag='%flagName%';"
          }
        }
        else {
        - define statement "INSERT INTO %tableName% (flag, value, expiration) VALUES ('%flagName%', '%flagValue%', '%expiration%');"
        }
      }
      else {
      - define uuid '<tern[<def[type].is[==].to[npc]>]:<def[owner].id>||<def[owner].uuid>>'
      - if %flagExists% {
        - if %isExpired% {
          - define statement "UPDATE %tableName% SET expiration = '%expiration%', value = '%flagValue%' WHERE flag='%flagName%' AND uuid='%uuid%';"
          }
          else {
          - define statement "UPDATE %tableName% SET expiration = '%expiration%', value = value + '%flagValue%' WHERE flag='%flagName%' AND uuid='%uuid%';"
          }
        }
        else {
        - define statement "INSERT INTO %tableName% (uuid, flag, value, expiration) VALUES ('%uuid%', '%flagName%', '%flagValue%', '%expiration%');"
        }
      }
    - inject s@SQLManager_Offline p:managedUpdateStatement

  decrement_flag:
    - if %flagValue% !matches decimal {
      - announce to_console "<&b>SQLAPI<&co><&c> %flagValue% is not a valid number! Not decrementing %flagName% for %owner%!"
      - if <player.is[!=].to[null]||false> {
        - narrate "<&b>SQLAPI<&co><&c> %flagValue% is not a valid number! Not decrementing %flagName% for %owner%!"
        }
      - queue clear
      }
    - define yamlName 'SQLAPI'
    - define scriptName 'SQLAPI'
    - define db '<yaml[SQLAPI_config].read[config.MySQL.database]||SQLAPI>'
    - define tableName '<yaml[SQLAPI_config].read[config.MySQL.tables.%type%SQLFLags]||dsqlapi_%type%sqlflags>'
    - define record '<proc[SQLAPI_GetFlagRecord].context[%owner%|%flagName%]||null>'
    - if '<def[record].equals_case_sensitive[SQLAPI OFFLINE]>' {
      - announce to_console "<&b>SQLAPI<&co><&c> System Offline! Can not decrement %flagName% for %owner% by %flagValue% in %tableName%!"
      - queue clear
      }
    - if %record% != null {
      - define flagExists 'true'
      - define expires '<def[record].get[3].unescaped||0>'
      - if %expires% == 0 || %expires% > <server.current_time_millis> {
        - define isExpired 'false'
        }
        else {
        - define isExpired 'true'
        }
      }
      else {
      - define flagExists 'false'
      - define isExpired 'true'
      }

    - if %flagExists% {
      - define flagVal '<def[record].get[2].unescaped||null>'
      - if %flagVal% !matches decimal {
        - announce to_console "<&b>SQLAPI<&co> <&c>Not decrementing %flagName% for %owner%! Current value %flagVal% is not numeric!"
        - if <player.is[!=].to[null]||false> {
          - narrate "<&b>SQLAPI<&co> <&c>Not decrementing %flagName% for %owner%! Current value %flagVal% is not numeric!"
          }
        - queue clear
        }
      }

    - if %type% == server {
      - if %flagExists% {
        - if %isExpired% {
          - define statement "UPDATE %tableName% SET expiration = '%expiration%', value = '%flagValue%' WHERE flag='%flagName%';"
          }
          else {
          - define statement "UPDATE %tableName% SET expiration = '%expiration%', value = value - '%flagValue%' WHERE flag='%flagName%';"
          }
        }
        else {
        - define statement "INSERT INTO %tableName% (flag, value, expiration) VALUES ('%flagName%', '%flagValue%', '%expiration%');"
        }
      }
      else {
      - define uuid '<tern[<def[type].is[==].to[npc]>]:<def[owner].id>||<def[owner].uuid>>'
      - if %flagExists% {
        - if %isExpired% {
          - define statement "UPDATE %tableName% SET expiration = '%expiration%', value = '%flagValue%' WHERE flag='%flagName%' AND uuid='%uuid%';"
          }
          else {
          - define statement "UPDATE %tableName% SET expiration = '%expiration%', value = value - '%flagValue%' WHERE flag='%flagName%' AND uuid='%uuid%';"
          }
        }
        else {
        - define statement "INSERT INTO %tableName% (uuid, flag, value, expiration) VALUES ('%uuid%', '%flagName%', '%flagValue%', '%expiration%');"
        }
      }
    - inject s@SQLManager_Offline p:managedUpdateStatement

  multiply_flag:
    - if %flagValue% !matches decimal {
      - announce to_console "<&b>SQLAPI<&co><&c> %flagValue% is not a valid number! Not multiplying %flagName% for %owner%!"
      - if <player.is[!=].to[null]||false> {
        - narrate "<&b>SQLAPI<&co><&c> %flagValue% is not a valid number! Not multiplying %flagName% for %owner%!"
        }
      - queue clear
      }
    - define yamlName 'SQLAPI'
    - define scriptName 'SQLAPI'
    - define db '<yaml[SQLAPI_config].read[config.MySQL.database]||SQLAPI>'
    - define tableName '<yaml[SQLAPI_config].read[config.MySQL.tables.%type%SQLFLags]||dsqlapi_%type%sqlflags>'
    - define record '<proc[SQLAPI_GetFlagRecord].context[%owner%|%flagName%]||null>'
    - if '<def[record].equals_case_sensitive[SQLAPI OFFLINE]>' {
      - announce to_console "<&b>SQLAPI<&co><&c> System Offline! Can not multiply %flagName% for %owner% by %flagValue% in %tableName%!"
      - queue clear
      }
    - if %record% != null {
      - define flagExists 'true'
      - define expires '<def[record].get[3].unescaped||0>'
      - if %expires% == 0 || %expires% > <server.current_time_millis> {
        - define isExpired 'false'
        }
        else {
        - define isExpired 'true'
        }
      }
      else {
      - define flagExists 'false'
      - define isExpired 'true'
      }

    - if %flagExists% {
      - define flagVal '<def[record].get[2].unescaped||null>'
      - if %flagVal% !matches decimal {
        - announce to_console "<&b>SQLAPI<&co> <&c>Not multiplying %flagName% for %owner%! Current value %flagVal% is not numeric!"
        - if <player.is[!=].to[null]||false> {
          - narrate "<&b>SQLAPI<&co> <&c>Not multiplying %flagName% for %owner%! Current value %flagVal% is not numeric!"
          }
        - queue clear
        }
      }

    - if %type% == server {
      - if %flagExists% {
        - if %isExpired% {
          - define statement "UPDATE %tableName% SET expiration = '%expiration%', value = '%flagValue%' WHERE flag='%flagName%';"
          }
          else {
          - define statement "UPDATE %tableName% SET expiration = '%expiration%', value = value * '%flagValue%' WHERE flag='%flagName%';"
          }
        }
        else {
        - define statement "INSERT INTO %tableName% (flag, value, expiration) VALUES ('%flagName%', '%flagValue%', '%expiration%');"
        }
      }
      else {
      - define uuid '<tern[<def[type].is[==].to[npc]>]:<def[owner].id>||<def[owner].uuid>>'
      - if %flagExists% {
        - if %isExpired% {
          - define statement "UPDATE %tableName% SET expiration = '%expiration%', value = '%flagValue%' WHERE flag='%flagName%' AND uuid='%uuid%';"
          }
          else {
          - define statement "UPDATE %tableName% SET expiration = '%expiration%', value = value * '%flagValue%' WHERE flag='%flagName%' AND uuid='%uuid%';"
          }
        }
        else {
        - define statement "INSERT INTO %tableName% (uuid, flag, value, expiration) VALUES ('%uuid%', '%flagName%', '%flagValue%', '%expiration%');"
        }
      }
    - inject s@SQLManager_Offline p:managedUpdateStatement

  divide_flag:
    - if %flagValue% !matches decimal {
      - announce to_console "<&b>SQLAPI<&co><&c> %flagValue% is not a valid number! Not dividing %flagName% for %owner%!"
      - if <player.is[!=].to[null]||false> {
        - narrate "<&b>SQLAPI<&co><&c> %flagValue% is not a valid number! Not dividing %flagName% for %owner%!"
        }
      - queue clear
      }
    - if %flagValue% == 0 {
      - announce to_console "<&b>SQLAPI<&co><&c> Can not divide by 0! Not dividing %flagName% for %owner%!"
      - if <player.is[!=].to[null]||false> {
        - narrate "<&b>SQLAPI<&co><&c> Can not divide by 0! Not dividing %flagName% for %owner%!"
        }
      - queue clear
      }
    - define yamlName 'SQLAPI'
    - define scriptName 'SQLAPI'
    - define db '<yaml[SQLAPI_config].read[config.MySQL.database]||SQLAPI>'
    - define tableName '<yaml[SQLAPI_config].read[config.MySQL.tables.%type%SQLFLags]||dsqlapi_%type%sqlflags>'
    - define record '<proc[SQLAPI_GetFlagRecord].context[%owner%|%flagName%]||null>'
    - if '<def[record].equals_case_sensitive[SQLAPI OFFLINE]>' {
      - announce to_console "<&b>SQLAPI<&co><&c> System Offline! Can not divide %flagName% for %owner% by %flagValue% in %tableName%!"
      - queue clear
      }
    - if %record% != null {
      - define flagExists 'true'
      - define expires '<def[record].get[3].unescaped||0>'
      - if %expires% == 0 || %expires% > <server.current_time_millis> {
        - define isExpired 'false'
        }
        else {
        - define isExpired 'true'
        }
      }
      else {
      - define flagExists 'false'
      - define isExpired 'true'
      }

    - if %flagExists% {
      - define flagVal '<def[record].get[2].unescaped||null>'
      - if %flagVal% !matches decimal {
        - announce to_console "<&b>SQLAPI<&co> <&c>Not dividing %flagName% for %owner%! Current value %flagVal% is not numeric!"
        - if <player.is[!=].to[null]||false> {
          - narrate "<&b>SQLAPI<&co> <&c>Not dividing %flagName% for %owner%! Current value %flagVal% is not numeric!"
          }
        - queue clear
        }
      }

    - if %type% == server {
      - if %flagExists% {
        - if %isExpired% {
          - define statement "UPDATE %tableName% SET expiration = '%expiration%', value = '%flagValue%' WHERE flag='%flagName%';"
          }
          else {
          - define statement "UPDATE %tableName% SET expiration = '%expiration%', value = value / '%flagValue%' WHERE flag='%flagName%';"
          }
        }
        else {
        - define statement "INSERT INTO %tableName% (flag, value, expiration) VALUES ('%flagName%', '%flagValue%', '%expiration%');"
        }
      }
      else {
      - define uuid '<tern[<def[type].is[==].to[npc]>]:<def[owner].id>||<def[owner].uuid>>'
      - if %flagExists% {
        - if %isExpired% {
          - define statement "UPDATE %tableName% SET expiration = '%expiration%', value = '%flagValue%' WHERE flag='%flagName%' AND uuid='%uuid%';"
          }
          else {
          - define statement "UPDATE %tableName% SET expiration = '%expiration%', value = value / '%flagValue%' WHERE flag='%flagName%' AND uuid='%uuid%';"
          }
        }
        else {
        - define statement "INSERT INTO %tableName% (uuid, flag, value, expiration) VALUES ('%uuid%', '%flagName%', '%flagValue%', '%expiration%');"
        }
      }
    - inject s@SQLManager_Offline p:managedUpdateStatement

#########################
# Command messages
  msg_set:
    - narrate "<&b>SQLAPI<&co><&7> Set <def[flagName].unescaped> to <def[flagValue].unescaped> for %owner%<tern[<def[expiration].is[==].to[0]>]:<&dot>||<&dot> Expires in <def[duration].split[<&co>].get[2].as_duration.formatted><&dot>>"

  msg_clear:
    - narrate "<&b>SQLAPI<&co><&7> Cleared <def[flagName].unescaped> for %owner%"

  msg_set_list:
    - narrate "<&b>SQLAPI<&co><&7> Set list flag <def[flagName].unescaped.after[<&pipe>]> to <def[flagValue].unescaped.after[<&pipe>]> for %owner%<tern[<def[expiration].is[==].to[0]>]:<&dot>||<&dot> Expires in <def[duration].split[<&co>].get[2].as_duration.formatted><&dot>>"

  msg_set_index:
    - narrate "<&b>SQLAPI<&co><&7> Set <def[flagName].unescaped> list to <def[flagValue].unescaped.after[<&pipe>]> starting at index %index% for %owner%<tern[<def[expiration].is[==].to[0]>]:<&dot>||<&dot> Expires in <def[duration].split[<&co>].get[2].as_duration.formatted><&dot>>"

  msg_include:
    - narrate "<&b>SQLAPI<&co><&7> Included <def[flagValue].unescaped.after[<&pipe>]> in <def[flagName].unescaped> list for %owner%<tern[<def[expiration].is[==].to[0]>]:<&dot>||<&dot> Expires in <def[duration].split[<&co>].get[2].as_duration.formatted><&dot>>"

  msg_insert_index:
    - narrate "<&b>SQLAPI<&co><&7> Included <def[flagValue].unescaped.after[<&pipe>]> in <def[flagName].unescaped> list starting at index %index% for %owner%<tern[<def[expiration].is[==].to[0]>]:<&dot>||<&dot> Expires in <def[duration].split[<&co>].get[2].as_duration.formatted><&dot>>"

  msg_remove:
    - if <def[flagValue].is[==].to[<&pipe>]> {
      - narrate "<&b>SQLAPI<&co><&7> Cleared <def[flagName].unescaped> for %owner%"
      }
      else {
      - narrate "<&b>SQLAPI<&co><&7> Removed <def[flagValue].unescaped.after[<&pipe>]> from <def[flagName].unescaped> list for %owner%<tern[<def[expiration].is[==].to[0]>]:<&dot>||<&dot> Expires in <def[duration].split[<&co>].get[2].as_duration.formatted><&dot>>"
      }

  msg_increment:
    - narrate "<&b>SQLAPI<&co><&7> Increased <def[flagName].unescaped> for %owner% by <def[flagValue].unescaped><tern[<def[expiration].is[==].to[0]>]:<&dot>||<&dot> Expires in <def[duration].split[<&co>].get[2].as_duration.formatted><&dot>>"

  msg_decrement:
    - narrate "<&b>SQLAPI<&co><&7> Decreased <def[flagName].unescaped> for %owner% by <def[flagValue].unescaped><tern[<def[expiration].is[==].to[0]>]:<&dot>||<&dot> Expires in <def[duration].split[<&co>].get[2].as_duration.formatted><&dot>>"

  msg_multiply:
    - narrate "<&b>SQLAPI<&co><&7> Multiplied <def[flagName].unescaped> for %owner% by <def[flagValue].unescaped><tern[<def[expiration].is[==].to[0]>]:<&dot>||<&dot> Expires in <def[duration].split[<&co>].get[2].as_duration.formatted><&dot>>"

  msg_divide:
    - narrate "<&b>SQLAPI<&co><&7> Divided <def[flagName].unescaped> for %owner% by <def[flagValue].unescaped><tern[<def[expiration].is[==].to[0]>]:<&dot>||<&dot> Expires in <def[duration].split[<&co>].get[2].as_duration.formatted><&dot>>"



SQLAPI_ParseOwner:
# Usage: <proc[SQLAPI_ParseOwner].context[owner]||null>
  type: procedure
  debug: false
  definitions: owner
  script:
    - define owner "<parse:<def[owner]>>"
    - inject locally <def[owner].type||null>
    - announce to_console "<&b>SQLAPI<&co><&c> Must specify valid owner object!"
    - announce to_console "<&b>SQLAPI<&co><&c> Can not parse %owner%"

  player:
    - determine 'player'

  entity:
    - determine 'entity'

  npc:
    - determine 'npc'

  element:
    - if %owner% == server {
      - determine 'server'
      }
      else if %owner% == player {
      - determine 'thisPlayer'
      }

SQLAPI_GetFlagRecord:
# Usage: <proc[SQLAPI_GetFlagRecord].context[owner|flag]||null>
  type: procedure
  debug: false
  definitions: owner|flag
  script:
    - define type '<proc[SQLAPI_ParseOwner].context[%owner%]||null>'
    - if li@player|entity|npc|server !contains %type% {
      - announce to_console "<&b>SQLAPI<&co> <&c>Invalid type specified in flag lookup!"
      - announce to_console "<&b>SQLAPI<&co> <&b>Attempted<&co> %owner% %type% %flag%"
      - queue clear
      }
    - define tableName '<yaml[SQLAPI_config].read[config.MySQL.tables.%type%SQLFLags]||dsqlapi_%type%sqlflags>'
    - define db '<yaml[SQLAPI_config].read[config.MySQL.database]||SQLAPI>'
    - if !<proc[SQLManager_ConnectionCheck].context[%db%]> {
      - announce to_console "<&b>SQLAPI<&co> <&c>Database Offline!"
      - yaml set 'id:SQLManager_Offline' 'Offline_Cache.databases.%db%.status:offline'
      - yaml 'savefile:SQLManager/cache.yml' 'id:SQLManager_Offline'
      - run s@SQLManager p:restart def:SQLAPI|SQLAPI|%db%
      - determine 'SQLAPI OFFLINE'
      }
    - if %owner% == server {
      - sql id:%db% "query:SELECT flag,value,expiration FROM %tablename% WHERE flag='%flag%';" save:record
      }
      else {
      - define uuid '<tern[<def[owner].type.is[==].to[npc]>]:<def[owner].id>||<def[owner].uuid>>'
      - sql id:%db% "query:SELECT flag,value,expiration FROM %tablename% WHERE flag='%flag%' AND uuid='%uuid%';" save:record
      }
    - define record '<entry[record].result>'
    - if <def[record].size> == 1 {
      - determine '<entry[record].result.get[1].split[/]||null>'
      }
    - if <def[record].size> != 0 {
      - announce to_console "<&b>SQLAPI<&co> <&c>%tablename% has <def[record].size> records of %flag% for %uuid%!"
      - announce to_console "<&b>SQLAPI<&co> <&c>Only returning the first record!"
      - determine '<entry[record].result.get[1].split[/]||null>'
      }


SQLAPI_FlagExists:
# Usage: <proc[SQLAPI_FlagExists].context[owner|flag]>
  type: procedure
  debug: false
  definitions: owner|flag
  script:
    - define record '<proc[SQLAPI_GetFlagRecord].context[%owner%|%flag%]||null>'
    - if '<def[record].equals_case_sensitive[SQLAPI OFFLINE]>' {
      - queue clear
      }
    - if %record% != null {
      - determine 'true'
      }
    - determine 'false'


SQLAPI_IsExpired:
# Usage: <proc[SQLAPI_IsExpired].context[owner|flag]>
  type: procedure
  debug: false
  definitions: owner|flag
  script:
    - define record '<proc[SQLAPI_GetFlagRecord].context[%owner%|%flag%]||null>'
    - if '<def[record].equals_case_sensitive[SQLAPI OFFLINE]>' {
      - queue clear
      }
    - if %record% != null {
      - define expiration '<def[record].get[3].unescaped||null>'
      - if %expiration% == 0 || %expiration% > <server.current_time_millis> {
        - determine 'false'
        }
      - determine 'true'
      }


SQLAPI_HasFlag:
# Usage: <proc[SQLAPI_HasFlag].context[owner|flag]>
  type: procedure
  debug: false
  definitions: owner|flag
  script:
    - define record '<proc[SQLAPI_GetFlagRecord].context[%owner%|%flag%]||null>'
    - if '<def[record].equals_case_sensitive[SQLAPI OFFLINE]>' {
      - queue clear
      }
    - if %record% != null {
      - define expiration '<def[record].get[3].unescaped||0>'
      - if %expiration% == 0 || %expiration% > <server.current_time_millis> {
        - determine 'true'
        }
      }
    - determine 'false'


SQLAPI_GetFlag:
# Usage: <proc[SQLAPI_GetFlag].context[owner|flag]||null>
  type: procedure
  debug: false
  definitions: owner|flag
  script:
    - define record '<proc[SQLAPI_GetFlagRecord].context[%owner%|%flag%]||null>'
    - if %record% == null || <def[record].equals_case_sensitive[SQLAPI OFFLINE]> {
      - queue clear
      }
    - define expiration '<def[record].get[3].unescaped||0>'
    - if %expiration% == 0 || %expiration% > <server.current_time_millis> {
      - define flagVal '<def[record].get[2].unescaped||null>'
      - if <def[flagVal].starts_with[|]> {
        - define flagVal '<def[flagVal].as_list>'
        - determine '<def[flagVal].get[2].to[<def[flagVal].size>]>'
        }
        else {
        - determine '%flagVal%'
        }
      }


################################################################################
#                                                                              #
# Configuration Files                                                          #
#                                                                              #
#   These are the default config files. They will be used to build the default #
# config file and data storage files.                                          #
#                                                                              #
#______________________________________________________________________________#
#                                                                              #
#______________________________DO_NOT_EDIT_THIS_DATA___________________________#
#______________________________________________________________________________#


SQLAPI_Configurations:
  type: yaml data
  debug: false

  config:
    MySQL:
      useSql: false
      connection:
        keepAlive: 5m
        retry: 3
        retryDelay: 10s
        host: localhost
        port: 3306
        username: root
        password: password
      database: SQLAPI
      tables:
        PlayerSQLFLags: dsqlapi_playersqlflags
        NPCSQLFLags: dsqlapi_npcsqlflags
        EntitySQLFLags: dsqlapi_entitysqlflags
        ServerSQLFLags: dsqlapi_serversqlflags


################################################################################
#                                                                              #
# SQL Table Structure                                                          #
#                                                                              #
#   This is where the table structure is defined. It would be best if you do   #
# not touch anything in this section!                                          #
#                                                                              #
#______________________________________________________________________________#
#                                                                              #
#______________________________DO_NOT_EDIT_THIS_DATA___________________________#
#______________________________________________________________________________#


SQLAPI_SQLTables:
# This script gets injected from the SQLManager on system start. It sets up some
# data it needs and loads the table structure so it's ready for the SQLManager.
  type: task
  debug: false

  script:
    - define sqlScriptName '<script.name>'
    - define sqlFile '<script.relative_filename>'
    - if <yaml.list.contains[%sqlScriptName%]> yaml unload 'id:%sqlScriptName%'
    - yaml 'load:%sqlFile%' fix_formatting 'id:%sqlScriptName%'
    - if !<yaml.list.contains[%sqlScriptName%]> {
      - announce "<&c>SQLAPI<&co><&b> An error occurred while loading %sqlScriptname%!" to_console
      - announce "<&b>SQLAPI<&co><&3> Aborting..." to_console
      - inject s@%scriptName% p:unload
      - queue stop
      }

  tables:
    PlayerSQLFLags:
      columns:
        id: INT AUTO_INCREMENT PRIMARY KEY
        uuid: varchar(36)
        flag: BLOB
        value: MEDIUMBLOB
        expiration: BIGINT
    NPCSQLFLags:
      columns:
        id: INT AUTO_INCREMENT PRIMARY KEY
        uuid: varchar(36)
        flag: BLOB
        value: MEDIUMBLOB
        expiration: BIGINT
    EntitySQLFLags:
      columns:
        id: INT AUTO_INCREMENT PRIMARY KEY
        uuid: varchar(36)
        flag: BLOB
        value: MEDIUMBLOB
        expiration: BIGINT
    ServerSQLFLags:
      columns:
        id: INT AUTO_INCREMENT PRIMARY KEY
        flag: BLOB
        value: MEDIUMBLOB
        expiration: BIGINT


#
